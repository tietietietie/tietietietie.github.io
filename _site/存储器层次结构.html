<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <title>CSAPP笔记：存储器层次结构</title>

  <!-- Begin Jekyll SEO tag v2.6.1 -->
<meta name="generator" content="Jekyll v3.8.7" />
<meta property="og:title" content="CSAPP笔记：存储器层次结构" />
<meta name="author" content="tie" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="存储器层次结构 存储技术及趋势 随机存储器（RAM） 特点：封装成芯片，多个RAM芯片组成内存，以每个比特为一个单位。 种类：静态RAM（SRAM）和动态存储器（DRAM），其中SRAM的成本高，速度快，只要有电就可以永久保持值，不需刷新，常用作缓存。DRAM的成本低，速度慢，需要经常刷新（充电）. 属于易失性存储器，断电会丢失信息 只读存储器（ROM） 其实可以写（再编程）很多次，由于历史原因一直被叫做只读存储器 EPROM：可擦写可编程ROM，可以重新编程1000次 闪存：也是非易失性存储器，基于EPROM SSD：固态硬盘，基于缓存的磁盘驱动器，比传统磁盘更快 固件：（firmware)，存储在ROM上的程序，如BIOS，驱动控制器等 总线结构（BUS STRCTURE）连接CPU和主存 主存读取（read） 包括：1，CPU将想要读取数据的地址传给主存。2，主存根据此地址获得所需数据，放在总线上传输3。，CPU从总线上读取数据，放入寄存器。 主存存储（write） 包括：1，CPU将想要存储的地址传到主存，主存知道了A处地址将要写入数据并等待数据传入。2，CPU将数据放在总线上。3，主存从总线上读取数据，写入到A。 由此可见，从主存中读取或写入数据都很耗时，大约是用寄存器操作数据的100多倍时间。 磁盘 几何结构：包括盘片（platters）（双面），磁道（tracks），柱面，扇区（sectors），间隙（gaps)等 容量：取决于记录密度（每个扇区能记录多少数据）和磁道密度。以前每个磁道的扇区数量相同，造成空间浪费，现在将磁盘分成不同的记录区域（recording zone），每个zone的扇区密度和磁道密度都不同。 如何在磁盘上读取数据：磁盘逆时针旋转，通过磁头（读/写头）在不同磁道的表面读写数据 磁盘读取速度：寻道时间+旋转等待时间+数据传输时间，由磁盘旋转速度（7200RPM）寻道速度（最慢）加上平均扇区读写时间 磁盘速度很慢，比SRAM慢40000倍，比DRAM慢2500倍。 对CPU来说，磁盘相当于连续的逻辑单元，将所需的逻辑单元号传给磁盘控制器（disk controller），可确定具体盘面，磁道，扇区在哪。 磁盘的格式容量（可用容量）比最大物理容量小，因为有些柱面预留给损害了的柱面备用。 I/0 总线（bus）：之前的PCI总线是广播总线，在总线上传入一个值，所有设备都能获取到。现代总线称为PCI express总线，点对点传输，速度更快。 CPU读取磁盘过程：1，传入三元信号（指令，逻辑单元号，目标内存地址）给磁盘控制器。2，磁盘控制器读取扇区数据，直接传给主存（DMA）（direct memory access）。3，当DMA完成后，磁盘给CPU一个中断信号，表示已经完成读取。 SSD 在CPU看来和磁盘完全相同，都是连续的逻辑单元。 读取速度比写入速度快，因为写入时，只能整块数据（不是logical blocks）被擦除后再写入。 在1985-2003年，制造商靠增加时钟频率来提高CPU速度，但是遇到功率瓶颈，发热量过大，在03年后靠增加核心数，提高速度。 DRAM/SSD等与CPU的差距越来越大。 利用局部性解决CPU/内存间性能差距。 局部性 定义：程序趋向于使用它们最近访问过的地址附近的，数据或指令。 两种局部性：时间局部性（某一个指令或数据被访问过后，之后很可能再被访问）空间局部性（可能访问某个指令或数据的周围指令） 学会分辨哪些程序有良好的局部性。（heapsort不具备局部性） 缓存在储存结构中的体现 越往顶部，容量越小，速度越快，单字节造价越高 Lk级是Lk+1级的缓存 缓存：使用速度更快，容量更小的存储设备来暂存大容量设备的一部分数据。 设计此存储结构的原因：利用程序的局部性，程序更有可能使用Lk级的数据而不是Lk+1级。 优点：能够以接近底部存储的造价获得空间，并以接近顶部存储设备的速度为程序提供数据。 数据按块的形式（block-sized）的形式利用传输单元在设备间传输。 缓存命中：所需数据刚好在缓存中 缓存不命中：缓存区没有我们所需要的block 缓存不命中的类型：1，cold miss：因为刚开始的时候缓存是没有数据的，所以刚开始一定会出现miss。2，Capacity miss：由于所需的工作Block数量超过了缓存区的容量，造成不命中。3，冲突不命中/conflict miss：由于缓存映射方式（放置算法）的限制，来自Lk+1级的块只能通过算法放在Lk级的某一小块位置，从而造成了某一小块位置不断被置换（或者叫evict/驱逐）。" />
<meta property="og:description" content="存储器层次结构 存储技术及趋势 随机存储器（RAM） 特点：封装成芯片，多个RAM芯片组成内存，以每个比特为一个单位。 种类：静态RAM（SRAM）和动态存储器（DRAM），其中SRAM的成本高，速度快，只要有电就可以永久保持值，不需刷新，常用作缓存。DRAM的成本低，速度慢，需要经常刷新（充电）. 属于易失性存储器，断电会丢失信息 只读存储器（ROM） 其实可以写（再编程）很多次，由于历史原因一直被叫做只读存储器 EPROM：可擦写可编程ROM，可以重新编程1000次 闪存：也是非易失性存储器，基于EPROM SSD：固态硬盘，基于缓存的磁盘驱动器，比传统磁盘更快 固件：（firmware)，存储在ROM上的程序，如BIOS，驱动控制器等 总线结构（BUS STRCTURE）连接CPU和主存 主存读取（read） 包括：1，CPU将想要读取数据的地址传给主存。2，主存根据此地址获得所需数据，放在总线上传输3。，CPU从总线上读取数据，放入寄存器。 主存存储（write） 包括：1，CPU将想要存储的地址传到主存，主存知道了A处地址将要写入数据并等待数据传入。2，CPU将数据放在总线上。3，主存从总线上读取数据，写入到A。 由此可见，从主存中读取或写入数据都很耗时，大约是用寄存器操作数据的100多倍时间。 磁盘 几何结构：包括盘片（platters）（双面），磁道（tracks），柱面，扇区（sectors），间隙（gaps)等 容量：取决于记录密度（每个扇区能记录多少数据）和磁道密度。以前每个磁道的扇区数量相同，造成空间浪费，现在将磁盘分成不同的记录区域（recording zone），每个zone的扇区密度和磁道密度都不同。 如何在磁盘上读取数据：磁盘逆时针旋转，通过磁头（读/写头）在不同磁道的表面读写数据 磁盘读取速度：寻道时间+旋转等待时间+数据传输时间，由磁盘旋转速度（7200RPM）寻道速度（最慢）加上平均扇区读写时间 磁盘速度很慢，比SRAM慢40000倍，比DRAM慢2500倍。 对CPU来说，磁盘相当于连续的逻辑单元，将所需的逻辑单元号传给磁盘控制器（disk controller），可确定具体盘面，磁道，扇区在哪。 磁盘的格式容量（可用容量）比最大物理容量小，因为有些柱面预留给损害了的柱面备用。 I/0 总线（bus）：之前的PCI总线是广播总线，在总线上传入一个值，所有设备都能获取到。现代总线称为PCI express总线，点对点传输，速度更快。 CPU读取磁盘过程：1，传入三元信号（指令，逻辑单元号，目标内存地址）给磁盘控制器。2，磁盘控制器读取扇区数据，直接传给主存（DMA）（direct memory access）。3，当DMA完成后，磁盘给CPU一个中断信号，表示已经完成读取。 SSD 在CPU看来和磁盘完全相同，都是连续的逻辑单元。 读取速度比写入速度快，因为写入时，只能整块数据（不是logical blocks）被擦除后再写入。 在1985-2003年，制造商靠增加时钟频率来提高CPU速度，但是遇到功率瓶颈，发热量过大，在03年后靠增加核心数，提高速度。 DRAM/SSD等与CPU的差距越来越大。 利用局部性解决CPU/内存间性能差距。 局部性 定义：程序趋向于使用它们最近访问过的地址附近的，数据或指令。 两种局部性：时间局部性（某一个指令或数据被访问过后，之后很可能再被访问）空间局部性（可能访问某个指令或数据的周围指令） 学会分辨哪些程序有良好的局部性。（heapsort不具备局部性） 缓存在储存结构中的体现 越往顶部，容量越小，速度越快，单字节造价越高 Lk级是Lk+1级的缓存 缓存：使用速度更快，容量更小的存储设备来暂存大容量设备的一部分数据。 设计此存储结构的原因：利用程序的局部性，程序更有可能使用Lk级的数据而不是Lk+1级。 优点：能够以接近底部存储的造价获得空间，并以接近顶部存储设备的速度为程序提供数据。 数据按块的形式（block-sized）的形式利用传输单元在设备间传输。 缓存命中：所需数据刚好在缓存中 缓存不命中：缓存区没有我们所需要的block 缓存不命中的类型：1，cold miss：因为刚开始的时候缓存是没有数据的，所以刚开始一定会出现miss。2，Capacity miss：由于所需的工作Block数量超过了缓存区的容量，造成不命中。3，冲突不命中/conflict miss：由于缓存映射方式（放置算法）的限制，来自Lk+1级的块只能通过算法放在Lk级的某一小块位置，从而造成了某一小块位置不断被置换（或者叫evict/驱逐）。" />
<link rel="canonical" href="https://github.com/tietietietie/tietietietie.github.io/%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.html" />
<meta property="og:url" content="https://github.com/tietietietie/tietietietie.github.io/%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.html" />
<meta property="og:site_name" content="tie’s blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-03-11T08:03:00+08:00" />
<script type="application/ld+json">
{"url":"https://github.com/tietietietie/tietietietie.github.io/%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.html","headline":"CSAPP笔记：存储器层次结构","dateModified":"2020-03-11T08:03:00+08:00","datePublished":"2020-03-11T08:03:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://github.com/tietietietie/tietietietie.github.io/%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.html"},"author":{"@type":"Person","name":"tie"},"description":"存储器层次结构 存储技术及趋势 随机存储器（RAM） 特点：封装成芯片，多个RAM芯片组成内存，以每个比特为一个单位。 种类：静态RAM（SRAM）和动态存储器（DRAM），其中SRAM的成本高，速度快，只要有电就可以永久保持值，不需刷新，常用作缓存。DRAM的成本低，速度慢，需要经常刷新（充电）. 属于易失性存储器，断电会丢失信息 只读存储器（ROM） 其实可以写（再编程）很多次，由于历史原因一直被叫做只读存储器 EPROM：可擦写可编程ROM，可以重新编程1000次 闪存：也是非易失性存储器，基于EPROM SSD：固态硬盘，基于缓存的磁盘驱动器，比传统磁盘更快 固件：（firmware)，存储在ROM上的程序，如BIOS，驱动控制器等 总线结构（BUS STRCTURE）连接CPU和主存 主存读取（read） 包括：1，CPU将想要读取数据的地址传给主存。2，主存根据此地址获得所需数据，放在总线上传输3。，CPU从总线上读取数据，放入寄存器。 主存存储（write） 包括：1，CPU将想要存储的地址传到主存，主存知道了A处地址将要写入数据并等待数据传入。2，CPU将数据放在总线上。3，主存从总线上读取数据，写入到A。 由此可见，从主存中读取或写入数据都很耗时，大约是用寄存器操作数据的100多倍时间。 磁盘 几何结构：包括盘片（platters）（双面），磁道（tracks），柱面，扇区（sectors），间隙（gaps)等 容量：取决于记录密度（每个扇区能记录多少数据）和磁道密度。以前每个磁道的扇区数量相同，造成空间浪费，现在将磁盘分成不同的记录区域（recording zone），每个zone的扇区密度和磁道密度都不同。 如何在磁盘上读取数据：磁盘逆时针旋转，通过磁头（读/写头）在不同磁道的表面读写数据 磁盘读取速度：寻道时间+旋转等待时间+数据传输时间，由磁盘旋转速度（7200RPM）寻道速度（最慢）加上平均扇区读写时间 磁盘速度很慢，比SRAM慢40000倍，比DRAM慢2500倍。 对CPU来说，磁盘相当于连续的逻辑单元，将所需的逻辑单元号传给磁盘控制器（disk controller），可确定具体盘面，磁道，扇区在哪。 磁盘的格式容量（可用容量）比最大物理容量小，因为有些柱面预留给损害了的柱面备用。 I/0 总线（bus）：之前的PCI总线是广播总线，在总线上传入一个值，所有设备都能获取到。现代总线称为PCI express总线，点对点传输，速度更快。 CPU读取磁盘过程：1，传入三元信号（指令，逻辑单元号，目标内存地址）给磁盘控制器。2，磁盘控制器读取扇区数据，直接传给主存（DMA）（direct memory access）。3，当DMA完成后，磁盘给CPU一个中断信号，表示已经完成读取。 SSD 在CPU看来和磁盘完全相同，都是连续的逻辑单元。 读取速度比写入速度快，因为写入时，只能整块数据（不是logical blocks）被擦除后再写入。 在1985-2003年，制造商靠增加时钟频率来提高CPU速度，但是遇到功率瓶颈，发热量过大，在03年后靠增加核心数，提高速度。 DRAM/SSD等与CPU的差距越来越大。 利用局部性解决CPU/内存间性能差距。 局部性 定义：程序趋向于使用它们最近访问过的地址附近的，数据或指令。 两种局部性：时间局部性（某一个指令或数据被访问过后，之后很可能再被访问）空间局部性（可能访问某个指令或数据的周围指令） 学会分辨哪些程序有良好的局部性。（heapsort不具备局部性） 缓存在储存结构中的体现 越往顶部，容量越小，速度越快，单字节造价越高 Lk级是Lk+1级的缓存 缓存：使用速度更快，容量更小的存储设备来暂存大容量设备的一部分数据。 设计此存储结构的原因：利用程序的局部性，程序更有可能使用Lk级的数据而不是Lk+1级。 优点：能够以接近底部存储的造价获得空间，并以接近顶部存储设备的速度为程序提供数据。 数据按块的形式（block-sized）的形式利用传输单元在设备间传输。 缓存命中：所需数据刚好在缓存中 缓存不命中：缓存区没有我们所需要的block 缓存不命中的类型：1，cold miss：因为刚开始的时候缓存是没有数据的，所以刚开始一定会出现miss。2，Capacity miss：由于所需的工作Block数量超过了缓存区的容量，造成不命中。3，冲突不命中/conflict miss：由于缓存映射方式（放置算法）的限制，来自Lk+1级的块只能通过算法放在Lk级的某一小块位置，从而造成了某一小块位置不断被置换（或者叫evict/驱逐）。","@type":"BlogPosting","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

  <link type="application/atom+xml" rel="alternate" href="https://github.com/tietietietie/tietietietie.github.io/feed.xml" title="tie's blog" />

  <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
  <link rel="stylesheet" href="/assets/css/main.css" />
</head><body a="auto">
    <main class="page-content" aria-label="Content">
      <div class="w">
        <a href="/">..</a>

<article>
  <p class="post-meta">
    <time datetime="2020-03-11 08:03:00 +0800">2020-03-11</time>
  </p>
  
  <h1>CSAPP笔记：存储器层次结构</h1>

  <h1 id="存储器层次结构">存储器层次结构</h1>

<h2 id="存储技术及趋势">存储技术及趋势</h2>

<h3 id="随机存储器ram">随机存储器（RAM）</h3>

<ul>
  <li>特点：封装成芯片，多个RAM芯片组成内存，以每个比特为一个单位。</li>
  <li>种类：静态RAM（SRAM）和动态存储器（DRAM），其中SRAM的成本高，速度快，只要有电就可以永久保持值，不需刷新，常用作缓存。DRAM的成本低，速度慢，需要经常刷新（充电）.</li>
  <li>属于易失性存储器，断电会丢失信息</li>
</ul>

<h3 id="只读存储器rom">只读存储器（ROM）</h3>

<ul>
  <li>其实可以写（再编程）很多次，由于历史原因一直被叫做只读存储器</li>
  <li>EPROM：可擦写可编程ROM，可以重新编程1000次</li>
  <li>闪存：也是非易失性存储器，基于EPROM</li>
  <li>SSD：固态硬盘，基于缓存的磁盘驱动器，比传统磁盘更快</li>
  <li>固件：（firmware)，存储在ROM上的程序，如BIOS，驱动控制器等</li>
</ul>

<h3 id="总线结构bus-strcture连接cpu和主存">总线结构（BUS STRCTURE）连接CPU和主存</h3>

<p><a href="https://imgchr.com/i/ysTrl9"><img src="https://s3.ax1x.com/2021/02/14/ysTrl9.png" alt="ysTrl9.png" /></a></p>

<ol>
  <li>
    <p>主存读取（read）</p>

    <p>包括：1，CPU将想要读取数据的地址传给主存。2，主存根据此地址获得所需数据，放在总线上传输3。，CPU从总线上读取数据，放入寄存器。</p>
  </li>
  <li>
    <p>主存存储（write）</p>

    <p>包括：1，CPU将想要存储的地址传到主存，主存知道了A处地址将要写入数据并等待数据传入。2，CPU将数据放在总线上。3，主存从总线上读取数据，写入到A。</p>
  </li>
</ol>

<p>由此可见，从主存中读取或写入数据都很耗时，大约是用寄存器操作数据的100多倍时间。</p>

<h3 id="磁盘">磁盘</h3>

<ul>
  <li>几何结构：包括盘片（platters）（双面），磁道（tracks），柱面，扇区（sectors），间隙（gaps)等</li>
  <li>容量：取决于记录密度（每个扇区能记录多少数据）和磁道密度。以前每个磁道的扇区数量相同，造成空间浪费，现在将磁盘分成不同的记录区域（recording zone），每个zone的扇区密度和磁道密度都不同。</li>
  <li>如何在磁盘上读取数据：磁盘逆时针旋转，通过磁头（读/写头）在不同磁道的表面读写数据</li>
  <li>磁盘读取速度：寻道时间+旋转等待时间+数据传输时间，由磁盘旋转速度（7200RPM）寻道速度（最慢）加上平均扇区读写时间</li>
  <li>磁盘速度很慢，比SRAM慢40000倍，比DRAM慢2500倍。</li>
  <li>对CPU来说，磁盘相当于连续的逻辑单元，将所需的逻辑单元号传给磁盘控制器（disk controller），可确定具体盘面，磁道，扇区在哪。</li>
  <li>磁盘的格式容量（可用容量）比最大物理容量小，因为有些柱面预留给损害了的柱面备用。</li>
  <li>I/0 总线（bus）：之前的PCI总线是广播总线，在总线上传入一个值，所有设备都能获取到。现代总线称为PCI express总线，点对点传输，速度更快。</li>
  <li>CPU读取磁盘过程：1，传入三元信号（指令，逻辑单元号，目标内存地址）给磁盘控制器。2，磁盘控制器读取扇区数据，直接传给主存（DMA）（direct memory access）。3，当DMA完成后，磁盘给CPU一个中断信号，表示已经完成读取。</li>
</ul>

<h3 id="ssd">SSD</h3>

<ul>
  <li>在CPU看来和磁盘完全相同，都是连续的逻辑单元。</li>
  <li>读取速度比写入速度快，因为写入时，只能整块数据（不是logical blocks）被擦除后再写入。</li>
</ul>

<p><a href="https://imgchr.com/i/ysTWFO"><img src="https://s3.ax1x.com/2021/02/14/ysTWFO.png" alt="ysTWFO.png" /></a></p>

<blockquote>
  <p>在1985-2003年，制造商靠增加时钟频率来提高CPU速度，但是遇到功率瓶颈，发热量过大，在03年后靠增加核心数，提高速度。</p>

  <p>DRAM/SSD等与CPU的差距越来越大。</p>
</blockquote>

<p>利用<strong>局部性</strong>解决CPU/内存间性能差距。</p>

<h2 id="局部性">局部性</h2>

<p>定义：程序趋向于使用它们最近访问过的地址附近的，数据或指令。</p>

<ul>
  <li>两种局部性：时间局部性（某一个指令或数据被访问过后，之后很可能再被访问）空间局部性（可能访问某个指令或数据的周围指令）</li>
  <li>学会分辨哪些程序有良好的局部性。（heapsort不具备局部性）</li>
</ul>

<h2 id="缓存在储存结构中的体现">缓存在储存结构中的体现</h2>

<p><a href="https://imgchr.com/i/ysTcex"><img src="https://s3.ax1x.com/2021/02/14/ysTcex.png" alt="ysTcex.png" /></a></p>

<ol>
  <li>越往顶部，容量越小，速度越快，单字节造价越高</li>
  <li>Lk级是Lk+1级的缓存</li>
  <li>缓存：使用速度更快，容量更小的存储设备来暂存大容量设备的一部分数据。</li>
  <li>设计此存储结构的原因：利用程序的局部性，程序更有可能使用Lk级的数据而不是Lk+1级。</li>
  <li>优点：能够以接近底部存储的造价获得空间，并以接近顶部存储设备的速度为程序提供数据。</li>
</ol>

<p><a href="https://imgchr.com/i/ysTsyR"><img src="https://s3.ax1x.com/2021/02/14/ysTsyR.png" alt="ysTsyR.png" /></a></p>

<ul>
  <li>数据按块的形式（block-sized）的形式利用传输单元在设备间传输。</li>
  <li>缓存命中：所需数据刚好在缓存中</li>
  <li>缓存不命中：缓存区没有我们所需要的block</li>
  <li>缓存不命中的类型：1，cold miss：因为刚开始的时候缓存是没有数据的，所以刚开始一定会出现miss。2，Capacity miss：由于所需的工作Block数量超过了缓存区的容量，造成不命中。3，冲突不命中/conflict miss：由于缓存映射方式（放置算法）的限制，来自Lk+1级的块只能通过算法放在Lk级的某一小块位置，从而造成了某一小块位置不断被置换（或者叫evict/驱逐）。</li>
</ul>

<p><a href="https://imgchr.com/i/ysTyO1"><img src="https://s3.ax1x.com/2021/02/14/ysTyO1.png" alt="ysTyO1.png" /></a></p>

</article>
      </div>
    </main>

    
  </body>
</html>