<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <title>社区论坛：项目搭建，学习Spring，开发论坛首页</title>

  <!-- Begin Jekyll SEO tag v2.6.1 -->
<meta name="generator" content="Jekyll v3.8.7" />
<meta property="og:title" content="社区论坛：项目搭建，学习Spring，开发论坛首页" />
<meta name="author" content="tie" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="初识Spring Boot 项目介绍 功能介绍 某课网讨论区开发，包括发帖，私信，用户注册，网站流量统计，点赞，关注等功能。 技术介绍 Java web的主流框架：Spring（事实上的行业标准）（学习重点） 一般的项目需求，都能在Spring中找到解决方案。 Spring Boot：可以简化Spring框架。 Spring MVC：处理请求 MyBatis：数据库(用Spring整合) SSM:Spring+Spring MVC+MyBatis.(常用功能都可以实现) Redis:No-server数据库,内存中数据库,性能好,提高服务性能. Kafka:消息队列(进行消息发布) Elasticsearch:流行的搜索引擎 上三者都能提高性能,都可以用Spring整合. Spring Security, Spring Actuator:安全和系统状态统计. 工具介绍 Maven:项目构建 集成开发工具:IntelliJ IDEA 数据库:MySQL+Redis 服务器:Tomcat 版本控制:Git 开发环境搭建 注意事项: java –version:&gt;= 8.0 路径名全部为英文且不许有空格. Maven 作用:构建项目+管理jar包 Maven仓库: 本地仓库:存放构件的位置,~/.m2/repository 远程仓库:中央仓库,镜像仓库(访问比较快),私服仓库(公司自己用的仓库) 本地仓库和远程仓库的联系:现在本地查找,在从远程查找所需要的包. 下载: binary:不提供源码,zip供Windows使用 初始化一个Maven项目，使用如下命令行： mvn archetype:generate -DgroupId=com.mycompany.app -DartifactId=my-app -DarchetypeArtifactId=maven-archetype-quickstart -DarchetypeVersion=1.4 -DinteractiveMode=false Dgruopid：为公司名，通常是域名的倒序。 Dartifactid：当前项目的id Darchetype…：项目模板 Darchetype..：项目版本 还可以设置是否交互，选择否（因为交互模式需要每次确认是/否) 遇到的问题 在setting.xml中设置了镜像仓库地址，但是报错不能访问，后改正直接访问中央仓库。 卡在Generating project in Batch mode这一步，参考这里解决。 阅读Maven手册，5分钟创建Maven 编译：mvn compile：编译项目，生成在target文件夹里面的class中 mvn clean：将生成的target文件夹删除。 mvn test：在target中包含了test文件夹，test包含了compile。 IntelliJ IDEA 在IDEA中连接Maven 因为使用mvn来构建编译项目 找不到build tool里面的maven选项，因为没有安装maven插件。 修改maven工作路径 遇到的问题 创建新Maven项目时，无法导入Maven文件，查看log，发现如下错误： 解决办法：因为Maven版本太新，IDEA版本不支持，下载Maven 3.6.1 IDEA如何清除缓存/项目： 删除缓存：可以现在Maven中搜索“cache….”可以删除缓存 删除项目：现在IDEA中移除项目，然后在对应的文件夹删除，注意清空回收站才算完全清除 编译项目 IDEA右侧有Maven快捷命令，可以点击即可。 还可以直接点:build–&gt;build project 也可以直接在对应的.java文件右键，点击run（右键找不到run选项） 快捷健 快速查找：按两次shift 快速找到接口需要实现的方法：ctrl+I Spring Boot 帮助优化Maven管理jar包，因为maven中的包搜索相对麻烦。 Maven搜索包 www.mvnrepository.com下载，然后复制对应的语句到pom文件的dependencies位置，Maven会自动下载。 Spring Initializer 使用Spring Initializer,可以把某个功能的包一次性下载下来。在start.spring.io中设置相关名称，及添加所需工具包即可。 我选择了Thymeleaf,Spring web,和Spring boot devTools三个依赖（AOP依赖没有找到） 得到一个文件压缩包，解压缩到某一地址，然后用IDEA打开即可。 遇到的问题 无法下载插件 因为连接的是国外镜像，无法下载速度慢，需要设置为国内阿里云的镜像，但是会出现连接不上的问题，此时需要在settings–&gt;Maven–&gt;importing–&gt;VM importer options处添加如下代码： -Dmaven.wagon.http.ssl.insecure=true -Dmaven.wagon.http.ssl.allowall=true 没法显示外部库 没有解决。。 启动程序 Jar包里内置了tomcat，启动可以运行tomcat服务器，默认端口在8080。 特点（核心价值） 起步依赖：starter,帮我们自动添加很多依赖（dependencies） 自动配置：减少很多配置 端点监控：对服务器进行监控。 示例 如何response浏览器发出的请求，在controller下编写对应代码，如下： 在浏览器输入：localhost:8080/alpha/hello，即可返回sayHello()函数的返回值。 修改服务器端口 server.port = 15213 server.servlet.context-path = /community 在resources的application.properties文件 会发现并不能生效，因为在target文件中也会存在着配置文件，修改那里的配置文件才会生效。 此时在浏览器输入：localhost:15213/community/alpha/hello可访问对应文件（or class) Spring入门 多套框架（Spring全家桶），包括： Spring+Spring Boot+Spring Cloud(将项目拆分为若干个子项目/微服务）+Spring Cloud Data Flow（多种客服端集成数据） 文档手册：Spring.io Spring Framework 包括 Spring core ：IoC Spring Data Access Web Servlet Integration 详细内容点这里 Spring IoC 控制反转（与常见的对象关系不同） 依赖注入 IoC容器：一个工厂，管理各种Bean和配置文件（需要提供两种数据，bean对象以及配置文件）（对象之间不会直接产生关联，降低耦合度） More:Bean的详细解释见这里 遇到的问题 不显示external libraries 搜索文件：projectView.xml，修改其中的“showLibraryContents”为true。 ctrl+鼠标右键不能进入函数源码 原因：热键冲突 解决办法：在settings–&gt;keymap–&gt;main view –&gt; navigation中找到declaration，发现其快捷键其实是ctrl+alt+鼠标右键。 访问目标函数时，需要进行登录 原因：Spring Security在起作用 解决办法：在pom文件中注释掉Security的dependency即可。参考这里 More：IDEA注释快捷键：ctrl+shift+/ 怎样才能被容器扫描 容器会自动创建(项目启动时），但是哪些Bean会被扫描呢？在mian函数的子包的所有类，都可能被扫描（取决于注解） 在main函数中，我们传入SpringApplication的其实是一个配置文件： import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; @SpringBootApplication //这个注解标识的类，其实是一个配置文件，项目启动的时候帮我们配置 public class CommunityApplication { public static void main(String[] args) { SpringApplication.run(CommunityApplication.class, args); } } 其中，SpringBootApplication下存放着配置文件，可以放入IoC容器的Bean，哪些函数（Bean)会被放入IoC文件呢，前面有四种注解的函数，会被扫描： @Controller(处理请求) @Service（提供服务/业务） @Repository(处理数据库) @Conponent(通用) 演示IoC 在test中演示，如何获得容器，代码如下： @SpringBootTest @ContextConfiguration(classes = CommunityApplication.class) //用正式项目的配置类来配置test public class CommunityApplicationTests implements ApplicationContextAware //必须要这个接口{ private ApplicationContext applicationContext; //这个其实就是容器 //需要重载这个方法 @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException { this.applicationContext = applicationContext; } @Test public void testApplicationContext() { System.out.println(applicationContext); } } ApplicationContextAware接口可以帮助我们实现容器的传递，在实现了serApplicationContext方法后，我们便可以通过其参数applicationcontext访问容器的 将容器的内容打印出来 使用容器降低耦合度（生成bean） 举例：在项目中实现了AlphaDao接口，并且实现了一个类叫做AlphaDaoHibernateImpl，通过注解@repository，它可以被容器扫描并管理，项目中的其他函数调用时，都是基于容器getBean方法，某一天，需要将此接口的技术升级，实现类变成AlphaDaoMyBatisImpl，此时只需要在这个类加上@Primary，即可实现此接口的升级（面向接口）,因为此时向容器中寻找AlphaBao类，默认会给你AlphaDaoMyBatisImpl。 @Repository @Primary public class AlphaDaoMyBatisImpl implements AlphaDao { @Override public String select() { return &quot;MyBatis&quot;; } } @Test public void testApplicationContext() { System.out.println(applicationContext); AlphaDao alphaDao = applicationContext.getBean(AlphaDao.class); System.out.println(alphaDao.select()); } 如果想要访问特定的bean，则可以通过名字，强制返回指定bean @Repository(&quot;alphaHibernate&quot;) public class AlphaDaoHibernateImpl implements AlphaDao { @Override public String select() { return &quot;Hibernate&quot;; } } @Test public void testApplicationContext() { System.out.println(applicationContext); AlphaDao alphaDao = applicationContext.getBean(AlphaDao.class); System.out.println(alphaDao.select()); alphaDao = applicationContext.getBean(&quot;alphaHibernate&quot;, AlphaDao.class); System.out.println(alphaDao.select()); } 容器管理bean的方法 除了自动构建bean外，还可以初始化bean,以及销毁bean，其中初始化函数是在对象构造函数调用之后，销毁函数是在对象销毁之前，具体如下所示： @Service public class AlphaService { public AlphaService() { System.out.println(&quot;实例化AlphaService&quot;); } @PostConstruct public void init() { System.out.println(&quot;初始化AlphaService&quot;); } @PreDestroy public void destroy() { System.out.println(&quot;销毁AlphaService&quot;); } } 并且默认情况，容器内的bean只会被实例一次（单例模式），如果需要每次调用bean都要实例化，则在对应bean加上注解@Scope(“prototype”) 容器中装配第三方的bean 配置类+注解（把所有的配置类都放在config包下） 如何装配一个外部、bean：使用@Configuration + @Bean， 代码如下所示： @Configuration //表明这是一个配置类 public class AlphaConfig { @Bean //这是一个需要装配的bean，bean的名称是“simpleDateFormat” public SimpleDateFormat simpleDateFormat() { return new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); } } 作用：把时间格式统一规定，如果需要输出时间，则调用这个bean即可。 @Test public void testBeanConfig() { SimpleDateFormat simpleDateFormat = applicationContext.getBean(SimpleDateFormat.class); System.out.println(simpleDateFormat.format(new Date())); } 更简单使用容器的方式 依赖注入（Dependency Injection) 直接声明一个bean类型，然后给他加上注解就可以使用，如果是依赖接口 @Autowired @Qualifier(&quot;alphaHibernate&quot;) private AlphaDao alphaDao; @Autowired private AlphaService alphaService; @Autowired private SimpleDateFormat simpleDateFormat; @Test public void testDI() { System.out.println(alphaDao); System.out.println(alphaService); System.out.println(simpleDateFormat); } 不用我们自己实例化，如果是依赖接口，还能降低耦合度。 综合演示依赖注入 controller调用service，service调用dao，所以在controller中注入service,在service中注入dao。即可实现依赖注入。具体代码如下： 在AlphaController中注入AlphaService public class AlphaController { @Autowired private AlphaService alphaService; @RequestMapping(&quot;/hello&quot;) @ResponseBody public String sayHello() { return &quot;Hello, Spring Boot.&quot;; } @RequestMapping(&quot;/data&quot;) @ResponseBody public String getData() { return alphaService.find(); } } 在AlphaService注入AlphaDao public class AlphaService { @Autowired private AlphaDao alphaDao; public AlphaService() { System.out.println(&quot;实例化AlphaService&quot;); } @PostConstruct public void init() { System.out.println(&quot;初始化AlphaService&quot;); } @PreDestroy public void destroy() { System.out.println(&quot;销毁AlphaService&quot;); } public String find() { return alphaDao.select(); } } Spring MVC入门 HTTP的文档：在这里可以查到相关信息。 右键网页—&gt;检查—&gt;network—&gt;刷新网页：可以发现浏览器与服务器之间有多次信息交流，第一次是请求http，获得了一个html，之后浏览器会根据这个html文件所缺失的信息继续请求内容。 三层架构 服务器的三层结构：表现层/业务层/数据层 MVC的三层结构（在表现层）：控制层（controller）+模型层（Model）+视图层（View） 核心组件：DispatherServlet（前端控制器/一个类）调度MVC三个层 上图表示Spring MVC是如何处理服务器发来的请求的。 模板引擎 作用：生成动态HTML 需要：模板文件+model数据 特点：自然模板，以HTML文件为模板（便于交流） 语法：常用表达式/判断循环/模板布局 手册看这里 举例 如何查看项目的常用配置 查看这里可以找到相应的配置类，配置文件通过给配置类赋值，来改变相应配置。 使用HttpServletRequest和HttpServletResponse来获得服务器请求，以及向服务器传输数据 代码： @RequestMapping(&quot;/http&quot;) public void http(HttpServletRequest request, HttpServletResponse response) { //输出请求信息（在服务器控制台） System.out.println(request.getMethod()); System.out.println(request.getServletPath()); Enumeration&lt;String&gt; enumeration = request.getHeaderNames(); while (enumeration.hasMoreElements()) { String name = enumeration.nextElement(); String value = request.getHeader(name); System.out.println(name + &quot; : &quot; + value); } //通过向response写数据，从而向服务器输出 response.setContentType(&quot;text/html;charset=utf-8&quot;); try (PrintWriter writer = response.getWriter();) { writer.write(&quot;&lt;h1&gt;ZT的牛客网&lt;h1&gt;&quot;); } catch (IOException e) { e.printStackTrace(); } } Spring还提供了更简单的处理方式：直接用注解，返回Responsebody下面函数的返回值 如何获得浏览器传来的参数 @Requestmapping()可以指定请求的方法（默认get），以及路径 在传入参数中添加注解，可以设置浏览器传来参数的名称，默认是否必须，默认值（处理传入参数很容易） @RequestMapping(path = &quot;/students&quot;, method = RequestMethod.GET) @ResponseBody public String getStudents( @RequestParam(name = &quot;current&quot;, required = false, defaultValue = &quot;1&quot;) int current, @RequestParam(name = &quot;limit&quot;, required = false, defaultValue = &quot;10&quot;) int limit) { System.out.println(current); System.out.println(limit); return &quot;Some Students&quot;; } 参数也可以是路径的一部分，添加注解即可，如下所示 @RequestMapping(path = &quot;/student/{id}&quot;, method = RequestMethod.GET) @ResponseBody public String getStudent(@PathVariable(&quot;id&quot;) int id) { return &quot;a student : &quot; + id; } Post post是指网页向服务器发送数据，在static中创建一个静态网页,设置了action后,点击submit,即可向对应path的函数传参 为什么不用get传数据呢?因为get请求会使用url传输参数,长度有限 静态网页如下 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;增加学生&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form method=&quot;post&quot; action=&quot;/community/alpha/student&quot;&gt; &lt;p&gt; 姓名：&lt;input type=&quot;text&quot; name=&quot;name&quot;&gt; &lt;/p&gt; &lt;p&gt; 年龄：&lt;input type=&quot;text&quot; name=&quot;age&quot;&gt; &lt;/p&gt; &lt;p&gt; &lt;input type=&quot;submit&quot; name=&quot;保存&quot;&gt; &lt;/p&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 响应函数如下(可以加注解): //post请求 @RequestMapping(path = &quot;/student&quot;, method = RequestMethod.POST) @ResponseBody public String saveStudent(String name, int age) { System.out.println(name); System.out.println(age); return &quot;success&quot;; } 如何响应数据(response) 返回网页方法一 //响应html数据 @RequestMapping(path = &quot;/teacher&quot;, method = RequestMethod.GET) public ModelAndView gerTeacher() { ModelAndView modelAndView = new ModelAndView(); modelAndView.addObject(&quot;name&quot;, &quot;张铁&quot;); modelAndView.addObject(&quot;age&quot;, &quot;24&quot;); modelAndView.setViewName(&quot;/demo/view&quot;); return modelAndView; } 设置普通html为模板,以及填充传入参数的方法:(注意thymeleaf(th)的语法) &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot; xmlns:th=&quot;http://thymeleaf.org&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Teacher&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p th:text=&quot;${name}&quot;&gt;&lt;/p&gt; &lt;p th:text=&quot;${age}&quot;&gt;&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 返回网页方法二 model和view分开,view以字符串形式返回 //查询学校 @RequestMapping(path = &quot;/school&quot;, method = RequestMethod.GET) public String getSchool(Model model) { model.addAttribute(&quot;name&quot;, &quot;HUST&quot;); model.addAttribute(&quot;age&quot;, 100); return &quot;/demo/view&quot;; } 响应json数据 在异步请求中(没有刷新页面,但是悄悄地访问了服务器一次)(所以这次服务器返回结果不是html) json数据:把java对象返回给浏览器时,由于浏览器是JS对象,所以需要使用json,起到现阶对象. Json字符串:跨语言地常用工具 @RequestMapping(path = &quot;/emp&quot;, method = RequestMethod.GET) @ResponseBody public Map&lt;String, Object&gt; getEmp() { Map&lt;String, Object&gt; emp = new HashMap&lt;&gt;(); emp.put(&quot;name&quot;, &quot;zhangtie&quot;); emp.put(&quot;age&quot;, 23); emp.put(&quot;salary&quot;, 20000); return emp; } 返回结果如下 {&quot;name&quot;:&quot;zhangtie&quot;,&quot;salary&quot;:20000,&quot;age&quot;:23} 也可以返回集合,json字符串也能表示 @RequestMapping(path = &quot;/emps&quot;, method = RequestMethod.GET) @ResponseBody public List&lt;Map&lt;String, Object&gt;&gt; getEmps() { Map&lt;String, Object&gt; emp = new HashMap&lt;&gt;(); List&lt;Map&lt;String, Object&gt;&gt; list = new ArrayList&lt;&gt;(); emp.put(&quot;name&quot;, &quot;zhangtie&quot;); emp.put(&quot;age&quot;, 23); emp.put(&quot;salary&quot;, 20000); list.add(emp); emp = new HashMap&lt;&gt;(); emp.put(&quot;name&quot;, &quot;lisi&quot;); emp.put(&quot;age&quot;, &quot;22&quot;); list.add(emp); emp = new HashMap&lt;&gt;(); emp.put(&quot;name&quot;, &quot;wangwu&quot;); emp.put(&quot;age&quot;, &quot;23&quot;); list.add(emp); return list; } 返回结果如下: [{&quot;name&quot;:&quot;zhangtie&quot;,&quot;salary&quot;:20000,&quot;age&quot;:23},{&quot;name&quot;:&quot;lisi&quot;,&quot;age&quot;:&quot;22&quot;},{&quot;name&quot;:&quot;wangwu&quot;,&quot;age&quot;:&quot;23&quot;}] MyBatis入门 安装MySQL 初始化MySQL，就算有环境变量，也要cd到bin目录下 按照以下步骤初始化 mysqld --initialized --console mysqld install net start mysql MyBatis 学习手册分别为:这里和这里 核心组件 SqlSessionFactory/SqlSession/XML配置文件:Spring已经整合帮我们初始化了. Mapper:DAO接口 Mapper映射器:对应sql和实体类映射 举例 对user表进行CRUD(增删改查) 导入jar包,(mybatis,mysql) 在application.properties中配置mysql 在jar包entity中定义查询sql返回类型(为User) 在DAO中声明接口（UserMapper） 在resourses中的mapper中定义配置文件(映射文件),使得UserMapper中定义的接口函数与sql操作一一对应 如何便于debug： 在日志中打印出具体执行的sql，在设置中添加如下代码 #logger logging.level.com.nowcoder.community=debug 开发社区首页 先开发DAO再开发Service再开发Controller 功能拆解： 按照：DAO—&gt;Service—&gt;Controller的顺序开发 查询讨论帖数据 和之前举例方法一样，先定义返回类型：DiscussPost，在DAO中声明接口：DiscussPostMapper，最后建立映射：discusspost_mapper.xml。 代码就不列举了。。 开发业务层 简单的使用数据层的bean即可。 开发控制层 需要使用模板引擎生成动态页面，显示十条数据 @Controller public class HomeController { @Autowired private DiscussPostService discussPostService; @Autowired private UserService userService; @RequestMapping(path = &quot;/index&quot;, method = RequestMethod.GET) public String getIndexPage(Model model) { List&lt;DiscussPost&gt; list = discussPostService.findDiscussPosts(0, 0, 10); List&lt;Map&lt;String, Object&gt;&gt; discussPosts = new ArrayList&lt;&gt;(); for (DiscussPost post : list) { Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;post&quot;, post); User user = userService.findUserById(post.getUserId()); map.put(&quot;user&quot;, user); discussPosts.add(map); } model.addAttribute(&quot;discussPosts&quot;, discussPosts); return &quot;/index&quot;; } } 分页 客户需要传送分页数据（哪一页），服务端返回所需数据 分页组件 把分页需要的条件都封装在Page类中，代码如下： package com.nowcoder.community.entity; //封装分页相关信息 public class Page { //当前页码 private int current = 1; //显示上限 private int limit = 10; //数据总数(用于计算总页数） private int rows; //查询路径(复用分页链接） private String path; public int getCurrent() { return current; } public void setCurrent(int current) { if (current &gt;= 1) this.current = current; } public int getLimit() { return limit; } public void setLimit(int limit) { if (limit &gt;= 1 &amp;&amp; limit &lt;= 100) this.limit = limit; } public int getRows() { return rows; } public void setRows(int rows) { if (rows &gt;= 0) this.rows = rows; } public String getPath() { return path; } public void setPath(String path) { this.path = path; } //获取当前页的起始行 public int getOffSet() { return (current - 1) * limit; } //获得总页数 public int getTotal() { if (rows % limit == 0) return rows / limit; return rows / limit + 1; } //获取起始页面 public int getFrom() { int from = current - 2; return from &lt; 1 ? 1 : from; } //获取终止页面 public int getTo() { int to = current + 2; int total = this.getTotal(); return to &gt; total ? total : to; } } 实现分页：主要使处理动态的html模板 代码略，注意如果html模板写错很难调试。。。 项目调式技巧 响应状态码的含义 可以在html手册查阅，常见状态码如下 200 请求成功 302 重定向：返回建议，使浏览器重新请求建议里的路径，从而返回新的网页。 所以302一般返回的是下一个请求的建议（路径）。（功能跳转） 404 访问的功能不存在（地址写错？表单写错？） 500 服务器接收到了请求，但是服务器处理请求时发生了错误。 服务端断点调试技巧 客户端断点调试技巧 设置日志 怎么利用logback日志工具，来查询程序错误信息。文档在这里 有各种日志输出的级别，日志越详细越消耗性能。 如何把日志打印到文件 可以直接在application里面设置（简单设置），也可以在logback官网上下载.xml配置文件。 logback-spring.xml文件必须放在resource下面，且名字不能变，spring会自动识别。 Git 如何在IDEA集成git 下载git插件，然后指定git/bin下面的git.exe路径，即可继承git，下面会出现version control按钮，点击绿勾可以commit。" />
<meta property="og:description" content="初识Spring Boot 项目介绍 功能介绍 某课网讨论区开发，包括发帖，私信，用户注册，网站流量统计，点赞，关注等功能。 技术介绍 Java web的主流框架：Spring（事实上的行业标准）（学习重点） 一般的项目需求，都能在Spring中找到解决方案。 Spring Boot：可以简化Spring框架。 Spring MVC：处理请求 MyBatis：数据库(用Spring整合) SSM:Spring+Spring MVC+MyBatis.(常用功能都可以实现) Redis:No-server数据库,内存中数据库,性能好,提高服务性能. Kafka:消息队列(进行消息发布) Elasticsearch:流行的搜索引擎 上三者都能提高性能,都可以用Spring整合. Spring Security, Spring Actuator:安全和系统状态统计. 工具介绍 Maven:项目构建 集成开发工具:IntelliJ IDEA 数据库:MySQL+Redis 服务器:Tomcat 版本控制:Git 开发环境搭建 注意事项: java –version:&gt;= 8.0 路径名全部为英文且不许有空格. Maven 作用:构建项目+管理jar包 Maven仓库: 本地仓库:存放构件的位置,~/.m2/repository 远程仓库:中央仓库,镜像仓库(访问比较快),私服仓库(公司自己用的仓库) 本地仓库和远程仓库的联系:现在本地查找,在从远程查找所需要的包. 下载: binary:不提供源码,zip供Windows使用 初始化一个Maven项目，使用如下命令行： mvn archetype:generate -DgroupId=com.mycompany.app -DartifactId=my-app -DarchetypeArtifactId=maven-archetype-quickstart -DarchetypeVersion=1.4 -DinteractiveMode=false Dgruopid：为公司名，通常是域名的倒序。 Dartifactid：当前项目的id Darchetype…：项目模板 Darchetype..：项目版本 还可以设置是否交互，选择否（因为交互模式需要每次确认是/否) 遇到的问题 在setting.xml中设置了镜像仓库地址，但是报错不能访问，后改正直接访问中央仓库。 卡在Generating project in Batch mode这一步，参考这里解决。 阅读Maven手册，5分钟创建Maven 编译：mvn compile：编译项目，生成在target文件夹里面的class中 mvn clean：将生成的target文件夹删除。 mvn test：在target中包含了test文件夹，test包含了compile。 IntelliJ IDEA 在IDEA中连接Maven 因为使用mvn来构建编译项目 找不到build tool里面的maven选项，因为没有安装maven插件。 修改maven工作路径 遇到的问题 创建新Maven项目时，无法导入Maven文件，查看log，发现如下错误： 解决办法：因为Maven版本太新，IDEA版本不支持，下载Maven 3.6.1 IDEA如何清除缓存/项目： 删除缓存：可以现在Maven中搜索“cache….”可以删除缓存 删除项目：现在IDEA中移除项目，然后在对应的文件夹删除，注意清空回收站才算完全清除 编译项目 IDEA右侧有Maven快捷命令，可以点击即可。 还可以直接点:build–&gt;build project 也可以直接在对应的.java文件右键，点击run（右键找不到run选项） 快捷健 快速查找：按两次shift 快速找到接口需要实现的方法：ctrl+I Spring Boot 帮助优化Maven管理jar包，因为maven中的包搜索相对麻烦。 Maven搜索包 www.mvnrepository.com下载，然后复制对应的语句到pom文件的dependencies位置，Maven会自动下载。 Spring Initializer 使用Spring Initializer,可以把某个功能的包一次性下载下来。在start.spring.io中设置相关名称，及添加所需工具包即可。 我选择了Thymeleaf,Spring web,和Spring boot devTools三个依赖（AOP依赖没有找到） 得到一个文件压缩包，解压缩到某一地址，然后用IDEA打开即可。 遇到的问题 无法下载插件 因为连接的是国外镜像，无法下载速度慢，需要设置为国内阿里云的镜像，但是会出现连接不上的问题，此时需要在settings–&gt;Maven–&gt;importing–&gt;VM importer options处添加如下代码： -Dmaven.wagon.http.ssl.insecure=true -Dmaven.wagon.http.ssl.allowall=true 没法显示外部库 没有解决。。 启动程序 Jar包里内置了tomcat，启动可以运行tomcat服务器，默认端口在8080。 特点（核心价值） 起步依赖：starter,帮我们自动添加很多依赖（dependencies） 自动配置：减少很多配置 端点监控：对服务器进行监控。 示例 如何response浏览器发出的请求，在controller下编写对应代码，如下： 在浏览器输入：localhost:8080/alpha/hello，即可返回sayHello()函数的返回值。 修改服务器端口 server.port = 15213 server.servlet.context-path = /community 在resources的application.properties文件 会发现并不能生效，因为在target文件中也会存在着配置文件，修改那里的配置文件才会生效。 此时在浏览器输入：localhost:15213/community/alpha/hello可访问对应文件（or class) Spring入门 多套框架（Spring全家桶），包括： Spring+Spring Boot+Spring Cloud(将项目拆分为若干个子项目/微服务）+Spring Cloud Data Flow（多种客服端集成数据） 文档手册：Spring.io Spring Framework 包括 Spring core ：IoC Spring Data Access Web Servlet Integration 详细内容点这里 Spring IoC 控制反转（与常见的对象关系不同） 依赖注入 IoC容器：一个工厂，管理各种Bean和配置文件（需要提供两种数据，bean对象以及配置文件）（对象之间不会直接产生关联，降低耦合度） More:Bean的详细解释见这里 遇到的问题 不显示external libraries 搜索文件：projectView.xml，修改其中的“showLibraryContents”为true。 ctrl+鼠标右键不能进入函数源码 原因：热键冲突 解决办法：在settings–&gt;keymap–&gt;main view –&gt; navigation中找到declaration，发现其快捷键其实是ctrl+alt+鼠标右键。 访问目标函数时，需要进行登录 原因：Spring Security在起作用 解决办法：在pom文件中注释掉Security的dependency即可。参考这里 More：IDEA注释快捷键：ctrl+shift+/ 怎样才能被容器扫描 容器会自动创建(项目启动时），但是哪些Bean会被扫描呢？在mian函数的子包的所有类，都可能被扫描（取决于注解） 在main函数中，我们传入SpringApplication的其实是一个配置文件： import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; @SpringBootApplication //这个注解标识的类，其实是一个配置文件，项目启动的时候帮我们配置 public class CommunityApplication { public static void main(String[] args) { SpringApplication.run(CommunityApplication.class, args); } } 其中，SpringBootApplication下存放着配置文件，可以放入IoC容器的Bean，哪些函数（Bean)会被放入IoC文件呢，前面有四种注解的函数，会被扫描： @Controller(处理请求) @Service（提供服务/业务） @Repository(处理数据库) @Conponent(通用) 演示IoC 在test中演示，如何获得容器，代码如下： @SpringBootTest @ContextConfiguration(classes = CommunityApplication.class) //用正式项目的配置类来配置test public class CommunityApplicationTests implements ApplicationContextAware //必须要这个接口{ private ApplicationContext applicationContext; //这个其实就是容器 //需要重载这个方法 @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException { this.applicationContext = applicationContext; } @Test public void testApplicationContext() { System.out.println(applicationContext); } } ApplicationContextAware接口可以帮助我们实现容器的传递，在实现了serApplicationContext方法后，我们便可以通过其参数applicationcontext访问容器的 将容器的内容打印出来 使用容器降低耦合度（生成bean） 举例：在项目中实现了AlphaDao接口，并且实现了一个类叫做AlphaDaoHibernateImpl，通过注解@repository，它可以被容器扫描并管理，项目中的其他函数调用时，都是基于容器getBean方法，某一天，需要将此接口的技术升级，实现类变成AlphaDaoMyBatisImpl，此时只需要在这个类加上@Primary，即可实现此接口的升级（面向接口）,因为此时向容器中寻找AlphaBao类，默认会给你AlphaDaoMyBatisImpl。 @Repository @Primary public class AlphaDaoMyBatisImpl implements AlphaDao { @Override public String select() { return &quot;MyBatis&quot;; } } @Test public void testApplicationContext() { System.out.println(applicationContext); AlphaDao alphaDao = applicationContext.getBean(AlphaDao.class); System.out.println(alphaDao.select()); } 如果想要访问特定的bean，则可以通过名字，强制返回指定bean @Repository(&quot;alphaHibernate&quot;) public class AlphaDaoHibernateImpl implements AlphaDao { @Override public String select() { return &quot;Hibernate&quot;; } } @Test public void testApplicationContext() { System.out.println(applicationContext); AlphaDao alphaDao = applicationContext.getBean(AlphaDao.class); System.out.println(alphaDao.select()); alphaDao = applicationContext.getBean(&quot;alphaHibernate&quot;, AlphaDao.class); System.out.println(alphaDao.select()); } 容器管理bean的方法 除了自动构建bean外，还可以初始化bean,以及销毁bean，其中初始化函数是在对象构造函数调用之后，销毁函数是在对象销毁之前，具体如下所示： @Service public class AlphaService { public AlphaService() { System.out.println(&quot;实例化AlphaService&quot;); } @PostConstruct public void init() { System.out.println(&quot;初始化AlphaService&quot;); } @PreDestroy public void destroy() { System.out.println(&quot;销毁AlphaService&quot;); } } 并且默认情况，容器内的bean只会被实例一次（单例模式），如果需要每次调用bean都要实例化，则在对应bean加上注解@Scope(“prototype”) 容器中装配第三方的bean 配置类+注解（把所有的配置类都放在config包下） 如何装配一个外部、bean：使用@Configuration + @Bean， 代码如下所示： @Configuration //表明这是一个配置类 public class AlphaConfig { @Bean //这是一个需要装配的bean，bean的名称是“simpleDateFormat” public SimpleDateFormat simpleDateFormat() { return new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); } } 作用：把时间格式统一规定，如果需要输出时间，则调用这个bean即可。 @Test public void testBeanConfig() { SimpleDateFormat simpleDateFormat = applicationContext.getBean(SimpleDateFormat.class); System.out.println(simpleDateFormat.format(new Date())); } 更简单使用容器的方式 依赖注入（Dependency Injection) 直接声明一个bean类型，然后给他加上注解就可以使用，如果是依赖接口 @Autowired @Qualifier(&quot;alphaHibernate&quot;) private AlphaDao alphaDao; @Autowired private AlphaService alphaService; @Autowired private SimpleDateFormat simpleDateFormat; @Test public void testDI() { System.out.println(alphaDao); System.out.println(alphaService); System.out.println(simpleDateFormat); } 不用我们自己实例化，如果是依赖接口，还能降低耦合度。 综合演示依赖注入 controller调用service，service调用dao，所以在controller中注入service,在service中注入dao。即可实现依赖注入。具体代码如下： 在AlphaController中注入AlphaService public class AlphaController { @Autowired private AlphaService alphaService; @RequestMapping(&quot;/hello&quot;) @ResponseBody public String sayHello() { return &quot;Hello, Spring Boot.&quot;; } @RequestMapping(&quot;/data&quot;) @ResponseBody public String getData() { return alphaService.find(); } } 在AlphaService注入AlphaDao public class AlphaService { @Autowired private AlphaDao alphaDao; public AlphaService() { System.out.println(&quot;实例化AlphaService&quot;); } @PostConstruct public void init() { System.out.println(&quot;初始化AlphaService&quot;); } @PreDestroy public void destroy() { System.out.println(&quot;销毁AlphaService&quot;); } public String find() { return alphaDao.select(); } } Spring MVC入门 HTTP的文档：在这里可以查到相关信息。 右键网页—&gt;检查—&gt;network—&gt;刷新网页：可以发现浏览器与服务器之间有多次信息交流，第一次是请求http，获得了一个html，之后浏览器会根据这个html文件所缺失的信息继续请求内容。 三层架构 服务器的三层结构：表现层/业务层/数据层 MVC的三层结构（在表现层）：控制层（controller）+模型层（Model）+视图层（View） 核心组件：DispatherServlet（前端控制器/一个类）调度MVC三个层 上图表示Spring MVC是如何处理服务器发来的请求的。 模板引擎 作用：生成动态HTML 需要：模板文件+model数据 特点：自然模板，以HTML文件为模板（便于交流） 语法：常用表达式/判断循环/模板布局 手册看这里 举例 如何查看项目的常用配置 查看这里可以找到相应的配置类，配置文件通过给配置类赋值，来改变相应配置。 使用HttpServletRequest和HttpServletResponse来获得服务器请求，以及向服务器传输数据 代码： @RequestMapping(&quot;/http&quot;) public void http(HttpServletRequest request, HttpServletResponse response) { //输出请求信息（在服务器控制台） System.out.println(request.getMethod()); System.out.println(request.getServletPath()); Enumeration&lt;String&gt; enumeration = request.getHeaderNames(); while (enumeration.hasMoreElements()) { String name = enumeration.nextElement(); String value = request.getHeader(name); System.out.println(name + &quot; : &quot; + value); } //通过向response写数据，从而向服务器输出 response.setContentType(&quot;text/html;charset=utf-8&quot;); try (PrintWriter writer = response.getWriter();) { writer.write(&quot;&lt;h1&gt;ZT的牛客网&lt;h1&gt;&quot;); } catch (IOException e) { e.printStackTrace(); } } Spring还提供了更简单的处理方式：直接用注解，返回Responsebody下面函数的返回值 如何获得浏览器传来的参数 @Requestmapping()可以指定请求的方法（默认get），以及路径 在传入参数中添加注解，可以设置浏览器传来参数的名称，默认是否必须，默认值（处理传入参数很容易） @RequestMapping(path = &quot;/students&quot;, method = RequestMethod.GET) @ResponseBody public String getStudents( @RequestParam(name = &quot;current&quot;, required = false, defaultValue = &quot;1&quot;) int current, @RequestParam(name = &quot;limit&quot;, required = false, defaultValue = &quot;10&quot;) int limit) { System.out.println(current); System.out.println(limit); return &quot;Some Students&quot;; } 参数也可以是路径的一部分，添加注解即可，如下所示 @RequestMapping(path = &quot;/student/{id}&quot;, method = RequestMethod.GET) @ResponseBody public String getStudent(@PathVariable(&quot;id&quot;) int id) { return &quot;a student : &quot; + id; } Post post是指网页向服务器发送数据，在static中创建一个静态网页,设置了action后,点击submit,即可向对应path的函数传参 为什么不用get传数据呢?因为get请求会使用url传输参数,长度有限 静态网页如下 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;增加学生&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form method=&quot;post&quot; action=&quot;/community/alpha/student&quot;&gt; &lt;p&gt; 姓名：&lt;input type=&quot;text&quot; name=&quot;name&quot;&gt; &lt;/p&gt; &lt;p&gt; 年龄：&lt;input type=&quot;text&quot; name=&quot;age&quot;&gt; &lt;/p&gt; &lt;p&gt; &lt;input type=&quot;submit&quot; name=&quot;保存&quot;&gt; &lt;/p&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 响应函数如下(可以加注解): //post请求 @RequestMapping(path = &quot;/student&quot;, method = RequestMethod.POST) @ResponseBody public String saveStudent(String name, int age) { System.out.println(name); System.out.println(age); return &quot;success&quot;; } 如何响应数据(response) 返回网页方法一 //响应html数据 @RequestMapping(path = &quot;/teacher&quot;, method = RequestMethod.GET) public ModelAndView gerTeacher() { ModelAndView modelAndView = new ModelAndView(); modelAndView.addObject(&quot;name&quot;, &quot;张铁&quot;); modelAndView.addObject(&quot;age&quot;, &quot;24&quot;); modelAndView.setViewName(&quot;/demo/view&quot;); return modelAndView; } 设置普通html为模板,以及填充传入参数的方法:(注意thymeleaf(th)的语法) &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot; xmlns:th=&quot;http://thymeleaf.org&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Teacher&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p th:text=&quot;${name}&quot;&gt;&lt;/p&gt; &lt;p th:text=&quot;${age}&quot;&gt;&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 返回网页方法二 model和view分开,view以字符串形式返回 //查询学校 @RequestMapping(path = &quot;/school&quot;, method = RequestMethod.GET) public String getSchool(Model model) { model.addAttribute(&quot;name&quot;, &quot;HUST&quot;); model.addAttribute(&quot;age&quot;, 100); return &quot;/demo/view&quot;; } 响应json数据 在异步请求中(没有刷新页面,但是悄悄地访问了服务器一次)(所以这次服务器返回结果不是html) json数据:把java对象返回给浏览器时,由于浏览器是JS对象,所以需要使用json,起到现阶对象. Json字符串:跨语言地常用工具 @RequestMapping(path = &quot;/emp&quot;, method = RequestMethod.GET) @ResponseBody public Map&lt;String, Object&gt; getEmp() { Map&lt;String, Object&gt; emp = new HashMap&lt;&gt;(); emp.put(&quot;name&quot;, &quot;zhangtie&quot;); emp.put(&quot;age&quot;, 23); emp.put(&quot;salary&quot;, 20000); return emp; } 返回结果如下 {&quot;name&quot;:&quot;zhangtie&quot;,&quot;salary&quot;:20000,&quot;age&quot;:23} 也可以返回集合,json字符串也能表示 @RequestMapping(path = &quot;/emps&quot;, method = RequestMethod.GET) @ResponseBody public List&lt;Map&lt;String, Object&gt;&gt; getEmps() { Map&lt;String, Object&gt; emp = new HashMap&lt;&gt;(); List&lt;Map&lt;String, Object&gt;&gt; list = new ArrayList&lt;&gt;(); emp.put(&quot;name&quot;, &quot;zhangtie&quot;); emp.put(&quot;age&quot;, 23); emp.put(&quot;salary&quot;, 20000); list.add(emp); emp = new HashMap&lt;&gt;(); emp.put(&quot;name&quot;, &quot;lisi&quot;); emp.put(&quot;age&quot;, &quot;22&quot;); list.add(emp); emp = new HashMap&lt;&gt;(); emp.put(&quot;name&quot;, &quot;wangwu&quot;); emp.put(&quot;age&quot;, &quot;23&quot;); list.add(emp); return list; } 返回结果如下: [{&quot;name&quot;:&quot;zhangtie&quot;,&quot;salary&quot;:20000,&quot;age&quot;:23},{&quot;name&quot;:&quot;lisi&quot;,&quot;age&quot;:&quot;22&quot;},{&quot;name&quot;:&quot;wangwu&quot;,&quot;age&quot;:&quot;23&quot;}] MyBatis入门 安装MySQL 初始化MySQL，就算有环境变量，也要cd到bin目录下 按照以下步骤初始化 mysqld --initialized --console mysqld install net start mysql MyBatis 学习手册分别为:这里和这里 核心组件 SqlSessionFactory/SqlSession/XML配置文件:Spring已经整合帮我们初始化了. Mapper:DAO接口 Mapper映射器:对应sql和实体类映射 举例 对user表进行CRUD(增删改查) 导入jar包,(mybatis,mysql) 在application.properties中配置mysql 在jar包entity中定义查询sql返回类型(为User) 在DAO中声明接口（UserMapper） 在resourses中的mapper中定义配置文件(映射文件),使得UserMapper中定义的接口函数与sql操作一一对应 如何便于debug： 在日志中打印出具体执行的sql，在设置中添加如下代码 #logger logging.level.com.nowcoder.community=debug 开发社区首页 先开发DAO再开发Service再开发Controller 功能拆解： 按照：DAO—&gt;Service—&gt;Controller的顺序开发 查询讨论帖数据 和之前举例方法一样，先定义返回类型：DiscussPost，在DAO中声明接口：DiscussPostMapper，最后建立映射：discusspost_mapper.xml。 代码就不列举了。。 开发业务层 简单的使用数据层的bean即可。 开发控制层 需要使用模板引擎生成动态页面，显示十条数据 @Controller public class HomeController { @Autowired private DiscussPostService discussPostService; @Autowired private UserService userService; @RequestMapping(path = &quot;/index&quot;, method = RequestMethod.GET) public String getIndexPage(Model model) { List&lt;DiscussPost&gt; list = discussPostService.findDiscussPosts(0, 0, 10); List&lt;Map&lt;String, Object&gt;&gt; discussPosts = new ArrayList&lt;&gt;(); for (DiscussPost post : list) { Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;post&quot;, post); User user = userService.findUserById(post.getUserId()); map.put(&quot;user&quot;, user); discussPosts.add(map); } model.addAttribute(&quot;discussPosts&quot;, discussPosts); return &quot;/index&quot;; } } 分页 客户需要传送分页数据（哪一页），服务端返回所需数据 分页组件 把分页需要的条件都封装在Page类中，代码如下： package com.nowcoder.community.entity; //封装分页相关信息 public class Page { //当前页码 private int current = 1; //显示上限 private int limit = 10; //数据总数(用于计算总页数） private int rows; //查询路径(复用分页链接） private String path; public int getCurrent() { return current; } public void setCurrent(int current) { if (current &gt;= 1) this.current = current; } public int getLimit() { return limit; } public void setLimit(int limit) { if (limit &gt;= 1 &amp;&amp; limit &lt;= 100) this.limit = limit; } public int getRows() { return rows; } public void setRows(int rows) { if (rows &gt;= 0) this.rows = rows; } public String getPath() { return path; } public void setPath(String path) { this.path = path; } //获取当前页的起始行 public int getOffSet() { return (current - 1) * limit; } //获得总页数 public int getTotal() { if (rows % limit == 0) return rows / limit; return rows / limit + 1; } //获取起始页面 public int getFrom() { int from = current - 2; return from &lt; 1 ? 1 : from; } //获取终止页面 public int getTo() { int to = current + 2; int total = this.getTotal(); return to &gt; total ? total : to; } } 实现分页：主要使处理动态的html模板 代码略，注意如果html模板写错很难调试。。。 项目调式技巧 响应状态码的含义 可以在html手册查阅，常见状态码如下 200 请求成功 302 重定向：返回建议，使浏览器重新请求建议里的路径，从而返回新的网页。 所以302一般返回的是下一个请求的建议（路径）。（功能跳转） 404 访问的功能不存在（地址写错？表单写错？） 500 服务器接收到了请求，但是服务器处理请求时发生了错误。 服务端断点调试技巧 客户端断点调试技巧 设置日志 怎么利用logback日志工具，来查询程序错误信息。文档在这里 有各种日志输出的级别，日志越详细越消耗性能。 如何把日志打印到文件 可以直接在application里面设置（简单设置），也可以在logback官网上下载.xml配置文件。 logback-spring.xml文件必须放在resource下面，且名字不能变，spring会自动识别。 Git 如何在IDEA集成git 下载git插件，然后指定git/bin下面的git.exe路径，即可继承git，下面会出现version control按钮，点击绿勾可以commit。" />
<link rel="canonical" href="https://github.com/tietietietie/tietietietie.github.io/chapter1.html" />
<meta property="og:url" content="https://github.com/tietietietie/tietietietie.github.io/chapter1.html" />
<meta property="og:site_name" content="tie’s blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-04-12T07:46:00+08:00" />
<script type="application/ld+json">
{"url":"https://github.com/tietietietie/tietietietie.github.io/chapter1.html","headline":"社区论坛：项目搭建，学习Spring，开发论坛首页","dateModified":"2020-04-12T07:46:00+08:00","datePublished":"2020-04-12T07:46:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://github.com/tietietietie/tietietietie.github.io/chapter1.html"},"author":{"@type":"Person","name":"tie"},"description":"初识Spring Boot 项目介绍 功能介绍 某课网讨论区开发，包括发帖，私信，用户注册，网站流量统计，点赞，关注等功能。 技术介绍 Java web的主流框架：Spring（事实上的行业标准）（学习重点） 一般的项目需求，都能在Spring中找到解决方案。 Spring Boot：可以简化Spring框架。 Spring MVC：处理请求 MyBatis：数据库(用Spring整合) SSM:Spring+Spring MVC+MyBatis.(常用功能都可以实现) Redis:No-server数据库,内存中数据库,性能好,提高服务性能. Kafka:消息队列(进行消息发布) Elasticsearch:流行的搜索引擎 上三者都能提高性能,都可以用Spring整合. Spring Security, Spring Actuator:安全和系统状态统计. 工具介绍 Maven:项目构建 集成开发工具:IntelliJ IDEA 数据库:MySQL+Redis 服务器:Tomcat 版本控制:Git 开发环境搭建 注意事项: java –version:&gt;= 8.0 路径名全部为英文且不许有空格. Maven 作用:构建项目+管理jar包 Maven仓库: 本地仓库:存放构件的位置,~/.m2/repository 远程仓库:中央仓库,镜像仓库(访问比较快),私服仓库(公司自己用的仓库) 本地仓库和远程仓库的联系:现在本地查找,在从远程查找所需要的包. 下载: binary:不提供源码,zip供Windows使用 初始化一个Maven项目，使用如下命令行： mvn archetype:generate -DgroupId=com.mycompany.app -DartifactId=my-app -DarchetypeArtifactId=maven-archetype-quickstart -DarchetypeVersion=1.4 -DinteractiveMode=false Dgruopid：为公司名，通常是域名的倒序。 Dartifactid：当前项目的id Darchetype…：项目模板 Darchetype..：项目版本 还可以设置是否交互，选择否（因为交互模式需要每次确认是/否) 遇到的问题 在setting.xml中设置了镜像仓库地址，但是报错不能访问，后改正直接访问中央仓库。 卡在Generating project in Batch mode这一步，参考这里解决。 阅读Maven手册，5分钟创建Maven 编译：mvn compile：编译项目，生成在target文件夹里面的class中 mvn clean：将生成的target文件夹删除。 mvn test：在target中包含了test文件夹，test包含了compile。 IntelliJ IDEA 在IDEA中连接Maven 因为使用mvn来构建编译项目 找不到build tool里面的maven选项，因为没有安装maven插件。 修改maven工作路径 遇到的问题 创建新Maven项目时，无法导入Maven文件，查看log，发现如下错误： 解决办法：因为Maven版本太新，IDEA版本不支持，下载Maven 3.6.1 IDEA如何清除缓存/项目： 删除缓存：可以现在Maven中搜索“cache….”可以删除缓存 删除项目：现在IDEA中移除项目，然后在对应的文件夹删除，注意清空回收站才算完全清除 编译项目 IDEA右侧有Maven快捷命令，可以点击即可。 还可以直接点:build–&gt;build project 也可以直接在对应的.java文件右键，点击run（右键找不到run选项） 快捷健 快速查找：按两次shift 快速找到接口需要实现的方法：ctrl+I Spring Boot 帮助优化Maven管理jar包，因为maven中的包搜索相对麻烦。 Maven搜索包 www.mvnrepository.com下载，然后复制对应的语句到pom文件的dependencies位置，Maven会自动下载。 Spring Initializer 使用Spring Initializer,可以把某个功能的包一次性下载下来。在start.spring.io中设置相关名称，及添加所需工具包即可。 我选择了Thymeleaf,Spring web,和Spring boot devTools三个依赖（AOP依赖没有找到） 得到一个文件压缩包，解压缩到某一地址，然后用IDEA打开即可。 遇到的问题 无法下载插件 因为连接的是国外镜像，无法下载速度慢，需要设置为国内阿里云的镜像，但是会出现连接不上的问题，此时需要在settings–&gt;Maven–&gt;importing–&gt;VM importer options处添加如下代码： -Dmaven.wagon.http.ssl.insecure=true -Dmaven.wagon.http.ssl.allowall=true 没法显示外部库 没有解决。。 启动程序 Jar包里内置了tomcat，启动可以运行tomcat服务器，默认端口在8080。 特点（核心价值） 起步依赖：starter,帮我们自动添加很多依赖（dependencies） 自动配置：减少很多配置 端点监控：对服务器进行监控。 示例 如何response浏览器发出的请求，在controller下编写对应代码，如下： 在浏览器输入：localhost:8080/alpha/hello，即可返回sayHello()函数的返回值。 修改服务器端口 server.port = 15213 server.servlet.context-path = /community 在resources的application.properties文件 会发现并不能生效，因为在target文件中也会存在着配置文件，修改那里的配置文件才会生效。 此时在浏览器输入：localhost:15213/community/alpha/hello可访问对应文件（or class) Spring入门 多套框架（Spring全家桶），包括： Spring+Spring Boot+Spring Cloud(将项目拆分为若干个子项目/微服务）+Spring Cloud Data Flow（多种客服端集成数据） 文档手册：Spring.io Spring Framework 包括 Spring core ：IoC Spring Data Access Web Servlet Integration 详细内容点这里 Spring IoC 控制反转（与常见的对象关系不同） 依赖注入 IoC容器：一个工厂，管理各种Bean和配置文件（需要提供两种数据，bean对象以及配置文件）（对象之间不会直接产生关联，降低耦合度） More:Bean的详细解释见这里 遇到的问题 不显示external libraries 搜索文件：projectView.xml，修改其中的“showLibraryContents”为true。 ctrl+鼠标右键不能进入函数源码 原因：热键冲突 解决办法：在settings–&gt;keymap–&gt;main view –&gt; navigation中找到declaration，发现其快捷键其实是ctrl+alt+鼠标右键。 访问目标函数时，需要进行登录 原因：Spring Security在起作用 解决办法：在pom文件中注释掉Security的dependency即可。参考这里 More：IDEA注释快捷键：ctrl+shift+/ 怎样才能被容器扫描 容器会自动创建(项目启动时），但是哪些Bean会被扫描呢？在mian函数的子包的所有类，都可能被扫描（取决于注解） 在main函数中，我们传入SpringApplication的其实是一个配置文件： import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; @SpringBootApplication //这个注解标识的类，其实是一个配置文件，项目启动的时候帮我们配置 public class CommunityApplication { public static void main(String[] args) { SpringApplication.run(CommunityApplication.class, args); } } 其中，SpringBootApplication下存放着配置文件，可以放入IoC容器的Bean，哪些函数（Bean)会被放入IoC文件呢，前面有四种注解的函数，会被扫描： @Controller(处理请求) @Service（提供服务/业务） @Repository(处理数据库) @Conponent(通用) 演示IoC 在test中演示，如何获得容器，代码如下： @SpringBootTest @ContextConfiguration(classes = CommunityApplication.class) //用正式项目的配置类来配置test public class CommunityApplicationTests implements ApplicationContextAware //必须要这个接口{ private ApplicationContext applicationContext; //这个其实就是容器 //需要重载这个方法 @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException { this.applicationContext = applicationContext; } @Test public void testApplicationContext() { System.out.println(applicationContext); } } ApplicationContextAware接口可以帮助我们实现容器的传递，在实现了serApplicationContext方法后，我们便可以通过其参数applicationcontext访问容器的 将容器的内容打印出来 使用容器降低耦合度（生成bean） 举例：在项目中实现了AlphaDao接口，并且实现了一个类叫做AlphaDaoHibernateImpl，通过注解@repository，它可以被容器扫描并管理，项目中的其他函数调用时，都是基于容器getBean方法，某一天，需要将此接口的技术升级，实现类变成AlphaDaoMyBatisImpl，此时只需要在这个类加上@Primary，即可实现此接口的升级（面向接口）,因为此时向容器中寻找AlphaBao类，默认会给你AlphaDaoMyBatisImpl。 @Repository @Primary public class AlphaDaoMyBatisImpl implements AlphaDao { @Override public String select() { return &quot;MyBatis&quot;; } } @Test public void testApplicationContext() { System.out.println(applicationContext); AlphaDao alphaDao = applicationContext.getBean(AlphaDao.class); System.out.println(alphaDao.select()); } 如果想要访问特定的bean，则可以通过名字，强制返回指定bean @Repository(&quot;alphaHibernate&quot;) public class AlphaDaoHibernateImpl implements AlphaDao { @Override public String select() { return &quot;Hibernate&quot;; } } @Test public void testApplicationContext() { System.out.println(applicationContext); AlphaDao alphaDao = applicationContext.getBean(AlphaDao.class); System.out.println(alphaDao.select()); alphaDao = applicationContext.getBean(&quot;alphaHibernate&quot;, AlphaDao.class); System.out.println(alphaDao.select()); } 容器管理bean的方法 除了自动构建bean外，还可以初始化bean,以及销毁bean，其中初始化函数是在对象构造函数调用之后，销毁函数是在对象销毁之前，具体如下所示： @Service public class AlphaService { public AlphaService() { System.out.println(&quot;实例化AlphaService&quot;); } @PostConstruct public void init() { System.out.println(&quot;初始化AlphaService&quot;); } @PreDestroy public void destroy() { System.out.println(&quot;销毁AlphaService&quot;); } } 并且默认情况，容器内的bean只会被实例一次（单例模式），如果需要每次调用bean都要实例化，则在对应bean加上注解@Scope(“prototype”) 容器中装配第三方的bean 配置类+注解（把所有的配置类都放在config包下） 如何装配一个外部、bean：使用@Configuration + @Bean， 代码如下所示： @Configuration //表明这是一个配置类 public class AlphaConfig { @Bean //这是一个需要装配的bean，bean的名称是“simpleDateFormat” public SimpleDateFormat simpleDateFormat() { return new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); } } 作用：把时间格式统一规定，如果需要输出时间，则调用这个bean即可。 @Test public void testBeanConfig() { SimpleDateFormat simpleDateFormat = applicationContext.getBean(SimpleDateFormat.class); System.out.println(simpleDateFormat.format(new Date())); } 更简单使用容器的方式 依赖注入（Dependency Injection) 直接声明一个bean类型，然后给他加上注解就可以使用，如果是依赖接口 @Autowired @Qualifier(&quot;alphaHibernate&quot;) private AlphaDao alphaDao; @Autowired private AlphaService alphaService; @Autowired private SimpleDateFormat simpleDateFormat; @Test public void testDI() { System.out.println(alphaDao); System.out.println(alphaService); System.out.println(simpleDateFormat); } 不用我们自己实例化，如果是依赖接口，还能降低耦合度。 综合演示依赖注入 controller调用service，service调用dao，所以在controller中注入service,在service中注入dao。即可实现依赖注入。具体代码如下： 在AlphaController中注入AlphaService public class AlphaController { @Autowired private AlphaService alphaService; @RequestMapping(&quot;/hello&quot;) @ResponseBody public String sayHello() { return &quot;Hello, Spring Boot.&quot;; } @RequestMapping(&quot;/data&quot;) @ResponseBody public String getData() { return alphaService.find(); } } 在AlphaService注入AlphaDao public class AlphaService { @Autowired private AlphaDao alphaDao; public AlphaService() { System.out.println(&quot;实例化AlphaService&quot;); } @PostConstruct public void init() { System.out.println(&quot;初始化AlphaService&quot;); } @PreDestroy public void destroy() { System.out.println(&quot;销毁AlphaService&quot;); } public String find() { return alphaDao.select(); } } Spring MVC入门 HTTP的文档：在这里可以查到相关信息。 右键网页—&gt;检查—&gt;network—&gt;刷新网页：可以发现浏览器与服务器之间有多次信息交流，第一次是请求http，获得了一个html，之后浏览器会根据这个html文件所缺失的信息继续请求内容。 三层架构 服务器的三层结构：表现层/业务层/数据层 MVC的三层结构（在表现层）：控制层（controller）+模型层（Model）+视图层（View） 核心组件：DispatherServlet（前端控制器/一个类）调度MVC三个层 上图表示Spring MVC是如何处理服务器发来的请求的。 模板引擎 作用：生成动态HTML 需要：模板文件+model数据 特点：自然模板，以HTML文件为模板（便于交流） 语法：常用表达式/判断循环/模板布局 手册看这里 举例 如何查看项目的常用配置 查看这里可以找到相应的配置类，配置文件通过给配置类赋值，来改变相应配置。 使用HttpServletRequest和HttpServletResponse来获得服务器请求，以及向服务器传输数据 代码： @RequestMapping(&quot;/http&quot;) public void http(HttpServletRequest request, HttpServletResponse response) { //输出请求信息（在服务器控制台） System.out.println(request.getMethod()); System.out.println(request.getServletPath()); Enumeration&lt;String&gt; enumeration = request.getHeaderNames(); while (enumeration.hasMoreElements()) { String name = enumeration.nextElement(); String value = request.getHeader(name); System.out.println(name + &quot; : &quot; + value); } //通过向response写数据，从而向服务器输出 response.setContentType(&quot;text/html;charset=utf-8&quot;); try (PrintWriter writer = response.getWriter();) { writer.write(&quot;&lt;h1&gt;ZT的牛客网&lt;h1&gt;&quot;); } catch (IOException e) { e.printStackTrace(); } } Spring还提供了更简单的处理方式：直接用注解，返回Responsebody下面函数的返回值 如何获得浏览器传来的参数 @Requestmapping()可以指定请求的方法（默认get），以及路径 在传入参数中添加注解，可以设置浏览器传来参数的名称，默认是否必须，默认值（处理传入参数很容易） @RequestMapping(path = &quot;/students&quot;, method = RequestMethod.GET) @ResponseBody public String getStudents( @RequestParam(name = &quot;current&quot;, required = false, defaultValue = &quot;1&quot;) int current, @RequestParam(name = &quot;limit&quot;, required = false, defaultValue = &quot;10&quot;) int limit) { System.out.println(current); System.out.println(limit); return &quot;Some Students&quot;; } 参数也可以是路径的一部分，添加注解即可，如下所示 @RequestMapping(path = &quot;/student/{id}&quot;, method = RequestMethod.GET) @ResponseBody public String getStudent(@PathVariable(&quot;id&quot;) int id) { return &quot;a student : &quot; + id; } Post post是指网页向服务器发送数据，在static中创建一个静态网页,设置了action后,点击submit,即可向对应path的函数传参 为什么不用get传数据呢?因为get请求会使用url传输参数,长度有限 静态网页如下 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;增加学生&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form method=&quot;post&quot; action=&quot;/community/alpha/student&quot;&gt; &lt;p&gt; 姓名：&lt;input type=&quot;text&quot; name=&quot;name&quot;&gt; &lt;/p&gt; &lt;p&gt; 年龄：&lt;input type=&quot;text&quot; name=&quot;age&quot;&gt; &lt;/p&gt; &lt;p&gt; &lt;input type=&quot;submit&quot; name=&quot;保存&quot;&gt; &lt;/p&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 响应函数如下(可以加注解): //post请求 @RequestMapping(path = &quot;/student&quot;, method = RequestMethod.POST) @ResponseBody public String saveStudent(String name, int age) { System.out.println(name); System.out.println(age); return &quot;success&quot;; } 如何响应数据(response) 返回网页方法一 //响应html数据 @RequestMapping(path = &quot;/teacher&quot;, method = RequestMethod.GET) public ModelAndView gerTeacher() { ModelAndView modelAndView = new ModelAndView(); modelAndView.addObject(&quot;name&quot;, &quot;张铁&quot;); modelAndView.addObject(&quot;age&quot;, &quot;24&quot;); modelAndView.setViewName(&quot;/demo/view&quot;); return modelAndView; } 设置普通html为模板,以及填充传入参数的方法:(注意thymeleaf(th)的语法) &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot; xmlns:th=&quot;http://thymeleaf.org&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Teacher&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p th:text=&quot;${name}&quot;&gt;&lt;/p&gt; &lt;p th:text=&quot;${age}&quot;&gt;&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 返回网页方法二 model和view分开,view以字符串形式返回 //查询学校 @RequestMapping(path = &quot;/school&quot;, method = RequestMethod.GET) public String getSchool(Model model) { model.addAttribute(&quot;name&quot;, &quot;HUST&quot;); model.addAttribute(&quot;age&quot;, 100); return &quot;/demo/view&quot;; } 响应json数据 在异步请求中(没有刷新页面,但是悄悄地访问了服务器一次)(所以这次服务器返回结果不是html) json数据:把java对象返回给浏览器时,由于浏览器是JS对象,所以需要使用json,起到现阶对象. Json字符串:跨语言地常用工具 @RequestMapping(path = &quot;/emp&quot;, method = RequestMethod.GET) @ResponseBody public Map&lt;String, Object&gt; getEmp() { Map&lt;String, Object&gt; emp = new HashMap&lt;&gt;(); emp.put(&quot;name&quot;, &quot;zhangtie&quot;); emp.put(&quot;age&quot;, 23); emp.put(&quot;salary&quot;, 20000); return emp; } 返回结果如下 {&quot;name&quot;:&quot;zhangtie&quot;,&quot;salary&quot;:20000,&quot;age&quot;:23} 也可以返回集合,json字符串也能表示 @RequestMapping(path = &quot;/emps&quot;, method = RequestMethod.GET) @ResponseBody public List&lt;Map&lt;String, Object&gt;&gt; getEmps() { Map&lt;String, Object&gt; emp = new HashMap&lt;&gt;(); List&lt;Map&lt;String, Object&gt;&gt; list = new ArrayList&lt;&gt;(); emp.put(&quot;name&quot;, &quot;zhangtie&quot;); emp.put(&quot;age&quot;, 23); emp.put(&quot;salary&quot;, 20000); list.add(emp); emp = new HashMap&lt;&gt;(); emp.put(&quot;name&quot;, &quot;lisi&quot;); emp.put(&quot;age&quot;, &quot;22&quot;); list.add(emp); emp = new HashMap&lt;&gt;(); emp.put(&quot;name&quot;, &quot;wangwu&quot;); emp.put(&quot;age&quot;, &quot;23&quot;); list.add(emp); return list; } 返回结果如下: [{&quot;name&quot;:&quot;zhangtie&quot;,&quot;salary&quot;:20000,&quot;age&quot;:23},{&quot;name&quot;:&quot;lisi&quot;,&quot;age&quot;:&quot;22&quot;},{&quot;name&quot;:&quot;wangwu&quot;,&quot;age&quot;:&quot;23&quot;}] MyBatis入门 安装MySQL 初始化MySQL，就算有环境变量，也要cd到bin目录下 按照以下步骤初始化 mysqld --initialized --console mysqld install net start mysql MyBatis 学习手册分别为:这里和这里 核心组件 SqlSessionFactory/SqlSession/XML配置文件:Spring已经整合帮我们初始化了. Mapper:DAO接口 Mapper映射器:对应sql和实体类映射 举例 对user表进行CRUD(增删改查) 导入jar包,(mybatis,mysql) 在application.properties中配置mysql 在jar包entity中定义查询sql返回类型(为User) 在DAO中声明接口（UserMapper） 在resourses中的mapper中定义配置文件(映射文件),使得UserMapper中定义的接口函数与sql操作一一对应 如何便于debug： 在日志中打印出具体执行的sql，在设置中添加如下代码 #logger logging.level.com.nowcoder.community=debug 开发社区首页 先开发DAO再开发Service再开发Controller 功能拆解： 按照：DAO—&gt;Service—&gt;Controller的顺序开发 查询讨论帖数据 和之前举例方法一样，先定义返回类型：DiscussPost，在DAO中声明接口：DiscussPostMapper，最后建立映射：discusspost_mapper.xml。 代码就不列举了。。 开发业务层 简单的使用数据层的bean即可。 开发控制层 需要使用模板引擎生成动态页面，显示十条数据 @Controller public class HomeController { @Autowired private DiscussPostService discussPostService; @Autowired private UserService userService; @RequestMapping(path = &quot;/index&quot;, method = RequestMethod.GET) public String getIndexPage(Model model) { List&lt;DiscussPost&gt; list = discussPostService.findDiscussPosts(0, 0, 10); List&lt;Map&lt;String, Object&gt;&gt; discussPosts = new ArrayList&lt;&gt;(); for (DiscussPost post : list) { Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;post&quot;, post); User user = userService.findUserById(post.getUserId()); map.put(&quot;user&quot;, user); discussPosts.add(map); } model.addAttribute(&quot;discussPosts&quot;, discussPosts); return &quot;/index&quot;; } } 分页 客户需要传送分页数据（哪一页），服务端返回所需数据 分页组件 把分页需要的条件都封装在Page类中，代码如下： package com.nowcoder.community.entity; //封装分页相关信息 public class Page { //当前页码 private int current = 1; //显示上限 private int limit = 10; //数据总数(用于计算总页数） private int rows; //查询路径(复用分页链接） private String path; public int getCurrent() { return current; } public void setCurrent(int current) { if (current &gt;= 1) this.current = current; } public int getLimit() { return limit; } public void setLimit(int limit) { if (limit &gt;= 1 &amp;&amp; limit &lt;= 100) this.limit = limit; } public int getRows() { return rows; } public void setRows(int rows) { if (rows &gt;= 0) this.rows = rows; } public String getPath() { return path; } public void setPath(String path) { this.path = path; } //获取当前页的起始行 public int getOffSet() { return (current - 1) * limit; } //获得总页数 public int getTotal() { if (rows % limit == 0) return rows / limit; return rows / limit + 1; } //获取起始页面 public int getFrom() { int from = current - 2; return from &lt; 1 ? 1 : from; } //获取终止页面 public int getTo() { int to = current + 2; int total = this.getTotal(); return to &gt; total ? total : to; } } 实现分页：主要使处理动态的html模板 代码略，注意如果html模板写错很难调试。。。 项目调式技巧 响应状态码的含义 可以在html手册查阅，常见状态码如下 200 请求成功 302 重定向：返回建议，使浏览器重新请求建议里的路径，从而返回新的网页。 所以302一般返回的是下一个请求的建议（路径）。（功能跳转） 404 访问的功能不存在（地址写错？表单写错？） 500 服务器接收到了请求，但是服务器处理请求时发生了错误。 服务端断点调试技巧 客户端断点调试技巧 设置日志 怎么利用logback日志工具，来查询程序错误信息。文档在这里 有各种日志输出的级别，日志越详细越消耗性能。 如何把日志打印到文件 可以直接在application里面设置（简单设置），也可以在logback官网上下载.xml配置文件。 logback-spring.xml文件必须放在resource下面，且名字不能变，spring会自动识别。 Git 如何在IDEA集成git 下载git插件，然后指定git/bin下面的git.exe路径，即可继承git，下面会出现version control按钮，点击绿勾可以commit。","@type":"BlogPosting","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

  <link type="application/atom+xml" rel="alternate" href="https://github.com/tietietietie/tietietietie.github.io/feed.xml" title="tie's blog" />

  <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
  <link rel="stylesheet" href="/assets/css/main.css" />
</head><body a="auto">
    <main class="page-content" aria-label="Content">
      <div class="w">
        <a href="/">..</a>

<article>
  <p class="post-meta">
    <time datetime="2020-04-12 07:46:00 +0800">2020-04-12</time>
  </p>
  
  <h1>社区论坛：项目搭建，学习Spring，开发论坛首页</h1>

  <h1 id="初识spring-boot">初识Spring Boot</h1>

<h2 id="项目介绍">项目介绍</h2>

<h3 id="功能介绍">功能介绍</h3>

<p>某课网讨论区开发，包括发帖，私信，用户注册，网站流量统计，点赞，关注等功能。</p>

<h3 id="技术介绍">技术介绍</h3>

<p>Java web的主流框架：Spring（事实上的行业标准）（学习重点）</p>

<p>一般的项目需求，都能在Spring中找到解决方案。</p>

<p>Spring Boot：可以简化Spring框架。</p>

<p>Spring MVC：处理请求</p>

<p>MyBatis：数据库(用Spring整合)</p>

<p>SSM:Spring+Spring MVC+MyBatis.(常用功能都可以实现)</p>

<p>Redis:No-server数据库,内存中数据库,性能好,提高服务性能.</p>

<p>Kafka:消息队列(进行消息发布)</p>

<p>Elasticsearch:流行的搜索引擎</p>

<p>上三者都能提高性能,都可以用Spring整合.</p>

<p>Spring Security, Spring Actuator:安全和系统状态统计.</p>

<h3 id="工具介绍">工具介绍</h3>

<p>Maven:项目构建</p>

<p>集成开发工具:IntelliJ IDEA</p>

<p>数据库:MySQL+Redis</p>

<p>服务器:Tomcat</p>

<p>版本控制:Git</p>

<h2 id="开发环境搭建">开发环境搭建</h2>

<p>注意事项:</p>

<ol>
  <li>java –version:&gt;= 8.0</li>
  <li>路径名全部为英文且不许有空格.</li>
</ol>

<h3 id="maven">Maven</h3>

<p>作用:构建项目+<strong>管理jar包</strong></p>

<p>Maven仓库:</p>

<ul>
  <li>本地仓库:存放构件的位置,~/.m2/repository</li>
  <li>远程仓库:中央仓库,镜像仓库(访问比较快),私服仓库(公司自己用的仓库)</li>
  <li>本地仓库和远程仓库的联系:现在本地查找,在从远程查找所需要的包.</li>
</ul>

<p>下载:</p>

<p>binary:不提供源码,zip供Windows使用</p>

<p>初始化一个Maven项目，使用如下命令行：</p>

<blockquote>
  <p>mvn archetype:generate -DgroupId=com.mycompany.app -DartifactId=my-app -DarchetypeArtifactId=maven-archetype-quickstart -DarchetypeVersion=1.4 -DinteractiveMode=false</p>
</blockquote>

<p>Dgruopid：为公司名，通常是域名的倒序。</p>

<p>Dartifactid：当前项目的id</p>

<p>Darchetype…：项目模板</p>

<p>Darchetype..：项目版本</p>

<p>还可以设置是否交互，选择否（因为交互模式需要每次确认是/否)</p>

<p><strong>遇到的问题</strong></p>

<ol>
  <li>在setting.xml中设置了镜像仓库地址，但是报错不能访问，后改正直接访问中央仓库。</li>
  <li>卡在Generating project in Batch mode这一步，参考<a href="https://www.cnblogs.com/wardensky/p/4513372.html">这里</a>解决。</li>
  <li>阅读Maven手册，<a href="https://maven.apache.org/guides/getting-started/maven-in-five-minutes.html">5分钟创建Maven</a></li>
</ol>

<p>编译：mvn compile：编译项目，生成在target文件夹里面的class中</p>

<p>mvn clean：将生成的target文件夹删除。</p>

<p>mvn test：在target中包含了test文件夹，test包含了compile。</p>

<h3 id="intellij-idea">IntelliJ IDEA</h3>

<h4 id="在idea中连接maven">在IDEA中连接Maven</h4>

<p>因为使用mvn来构建编译项目</p>

<ol>
  <li>找不到build tool里面的maven选项，因为没有安装maven插件。</li>
  <li>修改maven工作路径</li>
</ol>

<p><a href="https://imgchr.com/i/yh5qMT"><img src="https://s3.ax1x.com/2021/02/19/yh5qMT.png" alt="yh5qMT.png" /></a></p>

<h4 id="遇到的问题">遇到的问题</h4>

<ul>
  <li>创建新Maven项目时，无法导入Maven文件，查看log，发现如下错误：</li>
</ul>

<p><a href="https://imgchr.com/i/yh5HzV"><img src="https://s3.ax1x.com/2021/02/19/yh5HzV.png" alt="yh5HzV.png" /></a></p>

<p>解决办法：因为Maven版本太新，IDEA版本不支持，下载Maven 3.6.1</p>

<ul>
  <li>IDEA如何清除缓存/项目：</li>
</ul>

<p>删除缓存：可以现在Maven中搜索“cache….”可以删除缓存</p>

<p>删除项目：现在IDEA中移除项目，然后在对应的文件夹删除，注意<strong>清空回收站</strong>才算完全清除</p>

<h4 id="编译项目">编译项目</h4>

<p>IDEA右侧有Maven快捷命令，可以点击即可。</p>

<p><a href="https://imgchr.com/i/yh5oin"><img src="https://s3.ax1x.com/2021/02/19/yh5oin.png" alt="yh5oin.png" /></a></p>

<p>还可以直接点:build–&gt;build project</p>

<p>也可以直接在对应的.java文件右键，点击run（右键找不到run选项）</p>

<h4 id="快捷健">快捷健</h4>

<ul>
  <li>快速查找：按两次shift</li>
  <li>快速找到接口需要实现的方法：ctrl+I</li>
</ul>

<h3 id="spring-boot">Spring Boot</h3>

<p>帮助优化Maven管理jar包，因为maven中的包搜索相对麻烦。</p>

<h4 id="maven搜索包">Maven搜索包</h4>

<p>www.mvnrepository.com下载，然后复制对应的语句到pom文件的dependencies位置，Maven会自动下载。</p>

<h4 id="spring-initializer">Spring Initializer</h4>

<p>使用Spring Initializer,可以把某个功能的包一次性下载下来。在start.spring.io中设置相关名称，及添加所需工具包即可。</p>

<p>我选择了Thymeleaf,Spring web,和Spring boot devTools三个依赖（AOP依赖没有找到）</p>

<p>得到一个文件压缩包，解压缩到某一地址，然后用IDEA打开即可。</p>

<h4 id="遇到的问题-1">遇到的问题</h4>

<ul>
  <li>无法下载插件</li>
</ul>

<p>因为连接的是国外镜像，无法下载速度慢，需要设置为国内阿里云的镜像，但是会出现连接不上的问题，此时需要在settings–&gt;Maven–&gt;importing–&gt;VM importer options处添加如下代码：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>-Dmaven.wagon.http.ssl.insecure=true -Dmaven.wagon.http.ssl.allowall=true
</code></pre></div></div>

<ul>
  <li>没法显示外部库</li>
</ul>

<p>没有解决。。</p>

<h4 id="启动程序">启动程序</h4>

<p>Jar包里内置了tomcat，启动可以运行tomcat服务器，默认端口在8080。</p>

<h4 id="特点核心价值">特点（核心价值）</h4>

<ol>
  <li>起步依赖：starter,帮我们自动添加很多依赖（dependencies）</li>
  <li>自动配置：减少很多配置</li>
  <li>端点监控：对服务器进行监控。</li>
</ol>

<h4 id="示例">示例</h4>

<p>如何response浏览器发出的请求，在controller下编写对应代码，如下：</p>

<p><a href="https://imgchr.com/i/yh55Is"><img src="https://s3.ax1x.com/2021/02/19/yh55Is.png" alt="yh55Is.png" /></a></p>

<p>在浏览器输入：localhost:8080/alpha/hello，即可返回sayHello()函数的返回值。</p>

<h4 id="修改服务器端口">修改服务器端口</h4>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>server.port = 15213
server.servlet.context-path = /community
</code></pre></div></div>

<p>在resources的application.properties文件</p>

<p>会发现并不能生效，因为在target文件中也会存在着配置文件，修改那里的配置文件才会生效。</p>

<p>此时在浏览器输入：localhost:15213/community/alpha/hello可访问对应文件（or class)</p>

<h2 id="spring入门">Spring入门</h2>

<p>多套框架（Spring全家桶），包括：</p>

<p>Spring+Spring Boot+Spring Cloud(将项目拆分为若干个子项目/微服务）+Spring Cloud Data Flow（多种客服端集成数据）</p>

<p>文档手册：Spring.io</p>

<h3 id="spring-framework">Spring Framework</h3>

<p>包括</p>

<ul>
  <li>Spring core ：IoC</li>
  <li>Spring Data Access</li>
  <li>Web Servlet</li>
  <li>Integration</li>
</ul>

<p>详细内容点<a href="https://spring.io/projects/spring-framework#overview">这里</a></p>

<h4 id="spring-ioc">Spring IoC</h4>

<ul>
  <li>控制反转（与常见的<a href="https://blog.csdn.net/jiahao1186/article/details/82634723">对象关系</a>不同）</li>
  <li>依赖注入</li>
  <li>IoC容器：一个工厂，管理各种Bean和配置文件（需要提供两种数据，bean对象以及配置文件）（对象之间不会<strong>直接产生关联，降低耦合度</strong>）</li>
</ul>

<p>More:Bean的详细解释见<a href="https://www.awaimai.com/2596.html">这里</a></p>

<p><strong>遇到的问题</strong></p>

<ul>
  <li>不显示external libraries</li>
</ul>

<p>搜索文件：projectView.xml，修改其中的“showLibraryContents”为true。</p>

<ul>
  <li>ctrl+鼠标右键不能进入函数源码</li>
</ul>

<p>原因：热键冲突</p>

<p>解决办法：在settings–&gt;keymap–&gt;main view –&gt; navigation中找到declaration，发现其快捷键其实是ctrl+alt+鼠标右键。</p>

<ul>
  <li>访问目标函数时，需要进行登录</li>
</ul>

<p>原因：Spring Security在起作用</p>

<p>解决办法：在pom文件中注释掉Security的dependency即可。参考<a href="https://blog.csdn.net/qq_36079461/article/details/96759099">这里</a></p>

<p>More：IDEA注释快捷键：ctrl+shift+/</p>

<h4 id="怎样才能被容器扫描">怎样才能被容器扫描</h4>

<p><strong>容器会自动创建</strong>(项目启动时），但是哪些Bean会被扫描呢？在mian函数的子包的所有类，都可能被扫描（取决于注解）</p>

<p>在main函数中，我们传入SpringApplication的其实是一个配置文件：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">org.springframework.boot.SpringApplication</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.boot.autoconfigure.SpringBootApplication</span><span class="o">;</span>

<span class="nd">@SpringBootApplication</span> <span class="c1">//这个注解标识的类，其实是一个配置文件，项目启动的时候帮我们配置</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CommunityApplication</span> <span class="o">{</span>

	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
		<span class="nc">SpringApplication</span><span class="o">.</span><span class="na">run</span><span class="o">(</span><span class="nc">CommunityApplication</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">args</span><span class="o">);</span>
	<span class="o">}</span>

<span class="o">}</span>
</code></pre></div></div>

<p>其中，SpringBootApplication下存放着配置文件，可以放入IoC容器的Bean，哪些函数（Bean)会被放入IoC文件呢，前面有四种注解的函数，会被扫描：</p>

<ul>
  <li>@Controller(处理请求)</li>
  <li>@Service（提供服务/业务）</li>
  <li>@Repository(处理数据库)</li>
  <li>@Conponent(通用)</li>
</ul>

<h4 id="演示ioc">演示IoC</h4>

<p>在test中演示，如何获得容器，代码如下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@SpringBootTest</span>
<span class="nd">@ContextConfiguration</span><span class="o">(</span><span class="n">classes</span> <span class="o">=</span> <span class="nc">CommunityApplication</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>  <span class="c1">//用正式项目的配置类来配置test</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CommunityApplicationTests</span> <span class="kd">implements</span> <span class="nc">ApplicationContextAware</span> <span class="c1">//必须要这个接口{</span>
    <span class="kd">private</span> <span class="nc">ApplicationContext</span> <span class="n">applicationContext</span><span class="o">;</span> <span class="c1">//这个其实就是容器</span>

	<span class="c1">//需要重载这个方法</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setApplicationContext</span><span class="o">(</span><span class="nc">ApplicationContext</span> <span class="n">applicationContext</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">BeansException</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">applicationContext</span> <span class="o">=</span> <span class="n">applicationContext</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Test</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">testApplicationContext</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">applicationContext</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<ul>
  <li>ApplicationContextAware接口可以帮助我们实现<strong>容器的传递</strong>，在实现了serApplicationContext方法后，我们便可以通过其参数applicationcontext访问容器的</li>
  <li>将容器的内容打印出来</li>
</ul>

<h4 id="使用容器降低耦合度生成bean">使用容器降低耦合度（生成bean）</h4>

<p>举例：在项目中实现了AlphaDao接口，并且实现了一个类叫做AlphaDaoHibernateImpl，通过注解@repository，它可以被容器扫描并管理，项目中的其他函数调用时，都是基于容器getBean方法，某一天，需要将此接口的技术升级，实现类变成AlphaDaoMyBatisImpl，此时只需要在这个类加上@Primary，即可实现此接口的升级（面向接口）,因为此时向容器中寻找AlphaBao类，默认会给你AlphaDaoMyBatisImpl。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Repository</span>
<span class="nd">@Primary</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AlphaDaoMyBatisImpl</span> <span class="kd">implements</span> <span class="nc">AlphaDao</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">select</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="s">"MyBatis"</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Test</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">testApplicationContext</span><span class="o">()</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">applicationContext</span><span class="o">);</span>
    <span class="nc">AlphaDao</span> <span class="n">alphaDao</span> <span class="o">=</span> <span class="n">applicationContext</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="nc">AlphaDao</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">alphaDao</span><span class="o">.</span><span class="na">select</span><span class="o">());</span>
<span class="o">}</span>
</code></pre></div></div>

<p>如果想要访问特定的bean，则可以通过名字，强制返回指定bean</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Repository</span><span class="o">(</span><span class="s">"alphaHibernate"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AlphaDaoHibernateImpl</span> <span class="kd">implements</span> <span class="nc">AlphaDao</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">select</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="s">"Hibernate"</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Test</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">testApplicationContext</span><span class="o">()</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">applicationContext</span><span class="o">);</span>
    <span class="nc">AlphaDao</span> <span class="n">alphaDao</span> <span class="o">=</span> <span class="n">applicationContext</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="nc">AlphaDao</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">alphaDao</span><span class="o">.</span><span class="na">select</span><span class="o">());</span>
    <span class="n">alphaDao</span> <span class="o">=</span> <span class="n">applicationContext</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="s">"alphaHibernate"</span><span class="o">,</span> <span class="nc">AlphaDao</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">alphaDao</span><span class="o">.</span><span class="na">select</span><span class="o">());</span>
<span class="o">}</span>
</code></pre></div></div>

<h4 id="容器管理bean的方法">容器管理bean的方法</h4>

<p>除了自动构建bean外，还可以初始化bean,以及销毁bean，其中初始化函数是在对象构造函数调用之后，销毁函数是在对象销毁之前，具体如下所示：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Service</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AlphaService</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nf">AlphaService</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"实例化AlphaService"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@PostConstruct</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">init</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"初始化AlphaService"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@PreDestroy</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">destroy</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"销毁AlphaService"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>并且默认情况，容器内的bean只会被实例一次（单例模式），如果需要每次调用bean都要实例化，则在对应bean加上注解@Scope(“prototype”)</p>

<h4 id="容器中装配第三方的bean">容器中装配第三方的bean</h4>

<p>配置类+注解（把所有的配置类都放在config包下）</p>

<p>如何装配一个外部、bean：使用@Configuration + @Bean， 代码如下所示：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Configuration</span>  <span class="c1">//表明这是一个配置类</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AlphaConfig</span> <span class="o">{</span>
    <span class="nd">@Bean</span>  <span class="c1">//这是一个需要装配的bean，bean的名称是“simpleDateFormat”</span>
    <span class="kd">public</span> <span class="nc">SimpleDateFormat</span> <span class="nf">simpleDateFormat</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">SimpleDateFormat</span><span class="o">(</span><span class="s">"yyyy-MM-dd HH:mm:ss"</span><span class="o">);</span>
    <span class="o">}</span>

<span class="o">}</span>
</code></pre></div></div>

<p>作用：把时间格式统一规定，如果需要输出时间，则调用这个bean即可。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Test</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">testBeanConfig</span><span class="o">()</span> <span class="o">{</span>
    <span class="nc">SimpleDateFormat</span> <span class="n">simpleDateFormat</span> <span class="o">=</span>
        <span class="n">applicationContext</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="nc">SimpleDateFormat</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">simpleDateFormat</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="k">new</span> <span class="nc">Date</span><span class="o">()));</span>
<span class="o">}</span>
</code></pre></div></div>

<h4 id="更简单使用容器的方式">更简单使用容器的方式</h4>

<p>依赖注入（Dependency Injection)</p>

<p>直接声明一个bean类型，然后给他加上注解就可以使用，如果是依赖接口</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Autowired</span>
<span class="nd">@Qualifier</span><span class="o">(</span><span class="s">"alphaHibernate"</span><span class="o">)</span>
<span class="kd">private</span> <span class="nc">AlphaDao</span> <span class="n">alphaDao</span><span class="o">;</span>
<span class="nd">@Autowired</span>
<span class="kd">private</span> <span class="nc">AlphaService</span> <span class="n">alphaService</span><span class="o">;</span>
<span class="nd">@Autowired</span>
<span class="kd">private</span> <span class="nc">SimpleDateFormat</span> <span class="n">simpleDateFormat</span><span class="o">;</span>

<span class="nd">@Test</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">testDI</span><span class="o">()</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">alphaDao</span><span class="o">);</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">alphaService</span><span class="o">);</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">simpleDateFormat</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>不用我们自己实例化，如果是依赖接口，还能降低耦合度。</p>

<h4 id="综合演示依赖注入">综合演示依赖注入</h4>

<p>controller调用service，service调用dao，所以在controller中注入service,在service中注入dao。即可实现依赖注入。具体代码如下：</p>

<p>在AlphaController中注入AlphaService</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">AlphaController</span> <span class="o">{</span>

    <span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="nc">AlphaService</span> <span class="n">alphaService</span><span class="o">;</span>

    <span class="nd">@RequestMapping</span><span class="o">(</span><span class="s">"/hello"</span><span class="o">)</span>
    <span class="nd">@ResponseBody</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">sayHello</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="s">"Hello, Spring Boot."</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@RequestMapping</span><span class="o">(</span><span class="s">"/data"</span><span class="o">)</span>
    <span class="nd">@ResponseBody</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getData</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">alphaService</span><span class="o">.</span><span class="na">find</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>在AlphaService注入AlphaDao</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">AlphaService</span> <span class="o">{</span>

    <span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="nc">AlphaDao</span> <span class="n">alphaDao</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">AlphaService</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"实例化AlphaService"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@PostConstruct</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">init</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"初始化AlphaService"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@PreDestroy</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">destroy</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"销毁AlphaService"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">find</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">alphaDao</span><span class="o">.</span><span class="na">select</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="spring-mvc入门">Spring MVC入门</h2>

<p>HTTP的文档：在<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP">这里</a>可以查到相关信息。</p>

<p>右键网页—&gt;检查—&gt;network—&gt;刷新网页：可以发现浏览器与服务器之间有多次信息交流，第一次是请求http，获得了一个html，之后浏览器会根据这个html文件所缺失的信息继续请求内容。</p>

<h3 id="三层架构">三层架构</h3>

<p>服务器的三层结构：表现层/业务层/数据层</p>

<p>MVC的三层结构（在表现层）：控制层（controller）+模型层（Model）+视图层（View）</p>

<p>核心组件：DispatherServlet（前端控制器/一个类）调度MVC三个层</p>

<p><a href="https://imgchr.com/i/yh5OLF"><img src="https://s3.ax1x.com/2021/02/19/yh5OLF.png" alt="yh5OLF.png" /></a></p>

<p>上图表示Spring MVC是如何处理服务器发来的请求的。</p>

<h3 id="模板引擎">模板引擎</h3>

<p>作用：生成动态HTML</p>

<p>需要：模板文件+model数据</p>

<p>特点：自然模板，以HTML文件为模板（便于交流）</p>

<p>语法：常用表达式/判断循环/模板布局</p>

<p>手册看<a href="https://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html">这里</a></p>

<h3 id="举例">举例</h3>

<ul>
  <li>如何查看项目的常用配置</li>
</ul>

<p>查看<a href="https://docs.spring.io/spring-boot/docs/2.2.6.RELEASE/reference/htmlsingle/#common-application-properties">这里</a>可以找到相应的配置类，配置文件通过给配置类赋值，来改变相应配置。</p>

<ul>
  <li>使用HttpServletRequest和HttpServletResponse来获得服务器请求，以及向服务器传输数据</li>
</ul>

<p>代码：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@RequestMapping</span><span class="o">(</span><span class="s">"/http"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">http</span><span class="o">(</span><span class="nc">HttpServletRequest</span> <span class="n">request</span><span class="o">,</span> <span class="nc">HttpServletResponse</span> <span class="n">response</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">//输出请求信息（在服务器控制台）</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">request</span><span class="o">.</span><span class="na">getMethod</span><span class="o">());</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">request</span><span class="o">.</span><span class="na">getServletPath</span><span class="o">());</span>
    <span class="nc">Enumeration</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">enumeration</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="na">getHeaderNames</span><span class="o">();</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">enumeration</span><span class="o">.</span><span class="na">hasMoreElements</span><span class="o">())</span> <span class="o">{</span>
        <span class="nc">String</span> <span class="n">name</span> <span class="o">=</span> <span class="n">enumeration</span><span class="o">.</span><span class="na">nextElement</span><span class="o">();</span>
        <span class="nc">String</span> <span class="n">value</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="na">getHeader</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">name</span> <span class="o">+</span> <span class="s">" : "</span> <span class="o">+</span> <span class="n">value</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">//通过向response写数据，从而向服务器输出</span>
    <span class="n">response</span><span class="o">.</span><span class="na">setContentType</span><span class="o">(</span><span class="s">"text/html;charset=utf-8"</span><span class="o">);</span>
    <span class="k">try</span> <span class="o">(</span><span class="nc">PrintWriter</span> <span class="n">writer</span> <span class="o">=</span> <span class="n">response</span><span class="o">.</span><span class="na">getWriter</span><span class="o">();)</span> <span class="o">{</span>
        <span class="n">writer</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="s">"&lt;h1&gt;ZT的牛客网&lt;h1&gt;"</span><span class="o">);</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Spring还提供了更简单的处理方式：直接用注解，返回Responsebody下面函数的返回值</p>

<h3 id="如何获得浏览器传来的参数">如何获得浏览器传来的参数</h3>

<ul>
  <li>@Requestmapping()可以指定请求的方法（默认get），以及路径</li>
  <li>在传入参数中添加注解，可以设置浏览器传来参数的名称，默认是否必须，默认值（处理传入参数很容易）</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="nd">@RequestMapping</span><span class="o">(</span><span class="n">path</span> <span class="o">=</span> <span class="s">"/students"</span><span class="o">,</span> <span class="n">method</span> <span class="o">=</span> <span class="nc">RequestMethod</span><span class="o">.</span><span class="na">GET</span><span class="o">)</span>
    <span class="nd">@ResponseBody</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getStudents</span><span class="o">(</span>
            <span class="nd">@RequestParam</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"current"</span><span class="o">,</span> <span class="n">required</span> <span class="o">=</span> <span class="kc">false</span><span class="o">,</span> <span class="n">defaultValue</span> <span class="o">=</span> <span class="s">"1"</span><span class="o">)</span> <span class="kt">int</span> <span class="n">current</span><span class="o">,</span>
            <span class="nd">@RequestParam</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"limit"</span><span class="o">,</span> <span class="n">required</span> <span class="o">=</span> <span class="kc">false</span><span class="o">,</span> <span class="n">defaultValue</span> <span class="o">=</span> <span class="s">"10"</span><span class="o">)</span> <span class="kt">int</span> <span class="n">limit</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">current</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">limit</span><span class="o">);</span>
        <span class="k">return</span> <span class="s">"Some Students"</span><span class="o">;</span>
    <span class="o">}</span>
</code></pre></div></div>

<p>参数也可以是路径的一部分，添加注解即可，如下所示</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@RequestMapping</span><span class="o">(</span><span class="n">path</span> <span class="o">=</span> <span class="s">"/student/{id}"</span><span class="o">,</span> <span class="n">method</span> <span class="o">=</span> <span class="nc">RequestMethod</span><span class="o">.</span><span class="na">GET</span><span class="o">)</span>
<span class="nd">@ResponseBody</span>
<span class="kd">public</span> <span class="nc">String</span> <span class="nf">getStudent</span><span class="o">(</span><span class="nd">@PathVariable</span><span class="o">(</span><span class="s">"id"</span><span class="o">)</span> <span class="kt">int</span> <span class="n">id</span><span class="o">)</span> <span class="o">{</span>
<span class="k">return</span> <span class="s">"a student : "</span> <span class="o">+</span> <span class="n">id</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="post">Post</h3>

<p>post是指网页向服务器发送数据，在static中创建一个静态网页,设置了action后,点击submit,即可向对应path的函数传参</p>

<p>为什么不用get传数据呢?因为get请求会使用url传输参数,长度有限</p>

<p>静态网页如下</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;!DOCTYPE html&gt;</span>
<span class="nt">&lt;html</span> <span class="na">lang=</span><span class="s">"en"</span><span class="nt">&gt;</span>
<span class="nt">&lt;head&gt;</span>
    <span class="nt">&lt;meta</span> <span class="na">charset=</span><span class="s">"UTF-8"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;title&gt;</span>增加学生<span class="nt">&lt;/title&gt;</span>
<span class="nt">&lt;/head&gt;</span>
<span class="nt">&lt;body&gt;</span>

<span class="nt">&lt;form</span> <span class="na">method=</span><span class="s">"post"</span> <span class="na">action=</span><span class="s">"/community/alpha/student"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;p&gt;</span>
        姓名：<span class="nt">&lt;input</span> <span class="na">type=</span><span class="s">"text"</span> <span class="na">name=</span><span class="s">"name"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;/p&gt;</span>
    <span class="nt">&lt;p&gt;</span>
        年龄：<span class="nt">&lt;input</span> <span class="na">type=</span><span class="s">"text"</span> <span class="na">name=</span><span class="s">"age"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;/p&gt;</span>
    <span class="nt">&lt;p&gt;</span>
        <span class="nt">&lt;input</span> <span class="na">type=</span><span class="s">"submit"</span> <span class="na">name=</span><span class="s">"保存"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;/p&gt;</span>
<span class="nt">&lt;/form&gt;</span>

<span class="nt">&lt;/body&gt;</span>
<span class="nt">&lt;/html&gt;</span>
</code></pre></div></div>

<p>响应函数如下(可以加注解):</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//post请求</span>
<span class="nd">@RequestMapping</span><span class="o">(</span><span class="n">path</span> <span class="o">=</span> <span class="s">"/student"</span><span class="o">,</span> <span class="n">method</span> <span class="o">=</span> <span class="nc">RequestMethod</span><span class="o">.</span><span class="na">POST</span><span class="o">)</span>
<span class="nd">@ResponseBody</span>
<span class="kd">public</span> <span class="nc">String</span> <span class="nf">saveStudent</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">,</span> <span class="kt">int</span> <span class="n">age</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">age</span><span class="o">);</span>
    <span class="k">return</span> <span class="s">"success"</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="如何响应数据response">如何响应数据(response)</h3>

<h4 id="返回网页方法一">返回网页方法一</h4>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//响应html数据</span>
<span class="nd">@RequestMapping</span><span class="o">(</span><span class="n">path</span> <span class="o">=</span> <span class="s">"/teacher"</span><span class="o">,</span> <span class="n">method</span> <span class="o">=</span> <span class="nc">RequestMethod</span><span class="o">.</span><span class="na">GET</span><span class="o">)</span>
<span class="kd">public</span> <span class="nc">ModelAndView</span> <span class="nf">gerTeacher</span><span class="o">()</span> <span class="o">{</span>
    <span class="nc">ModelAndView</span> <span class="n">modelAndView</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ModelAndView</span><span class="o">();</span>
    <span class="n">modelAndView</span><span class="o">.</span><span class="na">addObject</span><span class="o">(</span><span class="s">"name"</span><span class="o">,</span> <span class="s">"张铁"</span><span class="o">);</span>
    <span class="n">modelAndView</span><span class="o">.</span><span class="na">addObject</span><span class="o">(</span><span class="s">"age"</span><span class="o">,</span> <span class="s">"24"</span><span class="o">);</span>
    <span class="n">modelAndView</span><span class="o">.</span><span class="na">setViewName</span><span class="o">(</span><span class="s">"/demo/view"</span><span class="o">);</span>
    <span class="k">return</span> <span class="n">modelAndView</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>设置普通html为模板,以及填充传入参数的方法:(注意thymeleaf(th)的语法)</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;!DOCTYPE html&gt;</span>
<span class="nt">&lt;html</span> <span class="na">lang=</span><span class="s">"en"</span> <span class="na">xmlns:th=</span><span class="s">"http://thymeleaf.org"</span><span class="nt">&gt;</span>
<span class="nt">&lt;head&gt;</span>
    <span class="nt">&lt;meta</span> <span class="na">charset=</span><span class="s">"UTF-8"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;title&gt;</span>Teacher<span class="nt">&lt;/title&gt;</span>
<span class="nt">&lt;/head&gt;</span>
<span class="nt">&lt;body&gt;</span>
<span class="nt">&lt;p</span> <span class="na">th:text=</span><span class="s">"${name}"</span><span class="nt">&gt;&lt;/p&gt;</span>
<span class="nt">&lt;p</span> <span class="na">th:text=</span><span class="s">"${age}"</span><span class="nt">&gt;&lt;/p&gt;</span>
<span class="nt">&lt;/body&gt;</span>
<span class="nt">&lt;/html&gt;</span>
</code></pre></div></div>

<h4 id="返回网页方法二">返回网页方法二</h4>

<p>model和view分开,view以字符串形式返回</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//查询学校</span>
<span class="nd">@RequestMapping</span><span class="o">(</span><span class="n">path</span> <span class="o">=</span> <span class="s">"/school"</span><span class="o">,</span> <span class="n">method</span> <span class="o">=</span> <span class="nc">RequestMethod</span><span class="o">.</span><span class="na">GET</span><span class="o">)</span>
<span class="kd">public</span> <span class="nc">String</span> <span class="nf">getSchool</span><span class="o">(</span><span class="nc">Model</span> <span class="n">model</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">model</span><span class="o">.</span><span class="na">addAttribute</span><span class="o">(</span><span class="s">"name"</span><span class="o">,</span> <span class="s">"HUST"</span><span class="o">);</span>
    <span class="n">model</span><span class="o">.</span><span class="na">addAttribute</span><span class="o">(</span><span class="s">"age"</span><span class="o">,</span> <span class="mi">100</span><span class="o">);</span>
    <span class="k">return</span> <span class="s">"/demo/view"</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<h4 id="响应json数据">响应json数据</h4>

<p>在异步请求中(没有刷新页面,但是悄悄地访问了服务器一次)(所以这次服务器返回结果不是html)</p>

<p>json数据:把java对象返回给浏览器时,由于浏览器是JS对象,所以需要使用json,起到现阶对象.</p>

<p>Json字符串:跨语言地常用工具</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@RequestMapping</span><span class="o">(</span><span class="n">path</span> <span class="o">=</span> <span class="s">"/emp"</span><span class="o">,</span> <span class="n">method</span> <span class="o">=</span> <span class="nc">RequestMethod</span><span class="o">.</span><span class="na">GET</span><span class="o">)</span>
<span class="nd">@ResponseBody</span>
<span class="kd">public</span> <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Object</span><span class="o">&gt;</span> <span class="nf">getEmp</span><span class="o">()</span> <span class="o">{</span>
    <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Object</span><span class="o">&gt;</span> <span class="n">emp</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
    <span class="n">emp</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"name"</span><span class="o">,</span> <span class="s">"zhangtie"</span><span class="o">);</span>
    <span class="n">emp</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"age"</span><span class="o">,</span> <span class="mi">23</span><span class="o">);</span>
    <span class="n">emp</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"salary"</span><span class="o">,</span> <span class="mi">20000</span><span class="o">);</span>
    <span class="k">return</span> <span class="n">emp</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>返回结果如下</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{"name":"zhangtie","salary":20000,"age":23}
</code></pre></div></div>

<p>也可以返回集合,json字符串也能表示</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@RequestMapping</span><span class="o">(</span><span class="n">path</span> <span class="o">=</span> <span class="s">"/emps"</span><span class="o">,</span> <span class="n">method</span> <span class="o">=</span> <span class="nc">RequestMethod</span><span class="o">.</span><span class="na">GET</span><span class="o">)</span>
<span class="nd">@ResponseBody</span>
<span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Object</span><span class="o">&gt;&gt;</span> <span class="nf">getEmps</span><span class="o">()</span> <span class="o">{</span>
    <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Object</span><span class="o">&gt;</span> <span class="n">emp</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Object</span><span class="o">&gt;&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
    <span class="n">emp</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"name"</span><span class="o">,</span> <span class="s">"zhangtie"</span><span class="o">);</span>
    <span class="n">emp</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"age"</span><span class="o">,</span> <span class="mi">23</span><span class="o">);</span>
    <span class="n">emp</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"salary"</span><span class="o">,</span> <span class="mi">20000</span><span class="o">);</span>
    <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">emp</span><span class="o">);</span>
    <span class="n">emp</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
    <span class="n">emp</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"name"</span><span class="o">,</span> <span class="s">"lisi"</span><span class="o">);</span>
    <span class="n">emp</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"age"</span><span class="o">,</span> <span class="s">"22"</span><span class="o">);</span>
    <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">emp</span><span class="o">);</span>
    <span class="n">emp</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
    <span class="n">emp</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"name"</span><span class="o">,</span> <span class="s">"wangwu"</span><span class="o">);</span>
    <span class="n">emp</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"age"</span><span class="o">,</span> <span class="s">"23"</span><span class="o">);</span>
    <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">emp</span><span class="o">);</span>
    <span class="k">return</span> <span class="n">list</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>返回结果如下:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[{"name":"zhangtie","salary":20000,"age":23},{"name":"lisi","age":"22"},{"name":"wangwu","age":"23"}]
</code></pre></div></div>

<h2 id="mybatis入门">MyBatis入门</h2>

<h3 id="安装mysql">安装MySQL</h3>

<p>初始化MySQL，就算有环境变量，也要cd到bin目录下</p>

<p>按照以下步骤初始化</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mysqld --initialized --console
mysqld install
net start mysql
</code></pre></div></div>

<h3 id="mybatis">MyBatis</h3>

<p>学习手册分别为:<a href="https://mybatis.org/mybatis-3/zh/index.html">这里</a>和<a href="http://mybatis.org/spring/zh/index.html">这里</a></p>

<ul>
  <li>核心组件</li>
</ul>

<p>SqlSessionFactory/SqlSession/XML配置文件:Spring已经整合帮我们初始化了.</p>

<p>Mapper:DAO接口</p>

<p>Mapper映射器:对应sql和实体类映射</p>

<h4 id="举例-1">举例</h4>

<p>对user表进行CRUD(增删改查)</p>

<p>导入jar包,(mybatis,mysql)</p>

<p>在application.properties中配置mysql</p>

<ul>
  <li>在jar包entity中定义查询sql返回类型(为User)</li>
  <li>在DAO中声明接口（UserMapper）</li>
  <li>在resourses中的mapper中定义配置文件(映射文件),使得UserMapper中定义的接口函数与sql操作一一对应</li>
</ul>

<p>如何便于debug：</p>

<p>在日志中打印出具体执行的sql，在设置中添加如下代码</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#logger
logging.level.com.nowcoder.community=debug
</code></pre></div></div>

<h2 id="开发社区首页">开发社区首页</h2>

<ul>
  <li>先开发DAO再开发Service再开发Controller</li>
  <li>功能拆解：</li>
</ul>

<p>按照：DAO—&gt;Service—&gt;Controller的顺序开发</p>

<h3 id="查询讨论帖数据">查询讨论帖数据</h3>

<p>和之前举例方法一样，先定义返回类型：DiscussPost，在DAO中声明接口：DiscussPostMapper，最后建立映射：discusspost_mapper.xml。</p>

<p>代码就不列举了。。</p>

<h3 id="开发业务层">开发业务层</h3>

<p>简单的使用数据层的bean即可。</p>

<h3 id="开发控制层">开发控制层</h3>

<p>需要使用模板引擎生成动态页面，显示十条数据</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Controller</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">HomeController</span> <span class="o">{</span>
    <span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="nc">DiscussPostService</span> <span class="n">discussPostService</span><span class="o">;</span>
    <span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="nc">UserService</span> <span class="n">userService</span><span class="o">;</span>

    <span class="nd">@RequestMapping</span><span class="o">(</span><span class="n">path</span> <span class="o">=</span> <span class="s">"/index"</span><span class="o">,</span> <span class="n">method</span> <span class="o">=</span> <span class="nc">RequestMethod</span><span class="o">.</span><span class="na">GET</span><span class="o">)</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getIndexPage</span><span class="o">(</span><span class="nc">Model</span> <span class="n">model</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">DiscussPost</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="n">discussPostService</span><span class="o">.</span><span class="na">findDiscussPosts</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">10</span><span class="o">);</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Object</span><span class="o">&gt;&gt;</span> <span class="n">discussPosts</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">DiscussPost</span> <span class="n">post</span> <span class="o">:</span> <span class="n">list</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Object</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
            <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"post"</span><span class="o">,</span> <span class="n">post</span><span class="o">);</span>
            <span class="nc">User</span> <span class="n">user</span> <span class="o">=</span> <span class="n">userService</span><span class="o">.</span><span class="na">findUserById</span><span class="o">(</span><span class="n">post</span><span class="o">.</span><span class="na">getUserId</span><span class="o">());</span>
            <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"user"</span><span class="o">,</span> <span class="n">user</span><span class="o">);</span>
            <span class="n">discussPosts</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">map</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="n">model</span><span class="o">.</span><span class="na">addAttribute</span><span class="o">(</span><span class="s">"discussPosts"</span><span class="o">,</span> <span class="n">discussPosts</span><span class="o">);</span>
        <span class="k">return</span> <span class="s">"/index"</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h4 id="分页">分页</h4>

<p>客户需要传送分页数据（哪一页），服务端返回所需数据</p>

<ul>
  <li>分页组件</li>
</ul>

<p>把分页需要的条件都封装在Page类中，代码如下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.nowcoder.community.entity</span><span class="o">;</span>

<span class="c1">//封装分页相关信息</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Page</span> <span class="o">{</span>
    <span class="c1">//当前页码</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">current</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
    <span class="c1">//显示上限</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">limit</span> <span class="o">=</span> <span class="mi">10</span><span class="o">;</span>
    <span class="c1">//数据总数(用于计算总页数）</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">rows</span><span class="o">;</span>
    <span class="c1">//查询路径(复用分页链接）</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">path</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getCurrent</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">current</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setCurrent</span><span class="o">(</span><span class="kt">int</span> <span class="n">current</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">current</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="o">)</span>
            <span class="k">this</span><span class="o">.</span><span class="na">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getLimit</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">limit</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setLimit</span><span class="o">(</span><span class="kt">int</span> <span class="n">limit</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">limit</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">limit</span> <span class="o">&lt;=</span> <span class="mi">100</span><span class="o">)</span>
            <span class="k">this</span><span class="o">.</span><span class="na">limit</span> <span class="o">=</span> <span class="n">limit</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getRows</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">rows</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setRows</span><span class="o">(</span><span class="kt">int</span> <span class="n">rows</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">rows</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">)</span>
            <span class="k">this</span><span class="o">.</span><span class="na">rows</span> <span class="o">=</span> <span class="n">rows</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getPath</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">path</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setPath</span><span class="o">(</span><span class="nc">String</span> <span class="n">path</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">path</span> <span class="o">=</span> <span class="n">path</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">//获取当前页的起始行</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getOffSet</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="o">(</span><span class="n">current</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">*</span> <span class="n">limit</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">//获得总页数</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getTotal</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">rows</span> <span class="o">%</span> <span class="n">limit</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
            <span class="k">return</span> <span class="n">rows</span> <span class="o">/</span> <span class="n">limit</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">rows</span> <span class="o">/</span> <span class="n">limit</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">//获取起始页面</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getFrom</span><span class="o">()</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">from</span> <span class="o">=</span> <span class="n">current</span> <span class="o">-</span> <span class="mi">2</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">from</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="n">from</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">//获取终止页面</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getTo</span><span class="o">()</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">to</span> <span class="o">=</span> <span class="n">current</span> <span class="o">+</span> <span class="mi">2</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">total</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">getTotal</span><span class="o">();</span>
        <span class="k">return</span> <span class="n">to</span> <span class="o">&gt;</span> <span class="n">total</span> <span class="o">?</span> <span class="n">total</span> <span class="o">:</span> <span class="n">to</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<ul>
  <li>实现分页：主要使处理动态的html模板</li>
</ul>

<p>代码略，注意如果html模板写错很难调试。。。</p>

<h2 id="项目调式技巧">项目调式技巧</h2>

<h3 id="响应状态码的含义">响应状态码的含义</h3>

<p>可以在html手册查阅，常见状态码如下</p>

<ul>
  <li>200</li>
</ul>

<p>请求成功</p>

<ul>
  <li>302</li>
</ul>

<p>重定向：返回建议，使浏览器重新请求建议里的路径，从而返回新的网页。</p>

<p>所以302一般返回的是下一个请求的建议（路径）。（功能跳转）</p>

<ul>
  <li>404</li>
</ul>

<p>访问的功能不存在（地址写错？表单写错？）</p>

<ul>
  <li>500</li>
</ul>

<p>服务器接收到了请求，但是服务器处理请求时发生了错误。</p>

<h3 id="服务端断点调试技巧">服务端断点调试技巧</h3>

<h3 id="客户端断点调试技巧">客户端断点调试技巧</h3>

<h3 id="设置日志">设置日志</h3>

<p>怎么利用logback日志工具，来查询程序错误信息。文档在<a href="http://logback.qos.ch/manual/index.html">这里</a></p>

<p>有各种日志输出的级别，日志越详细越消耗性能。</p>

<p><a href="https://imgchr.com/i/yh57R0"><img src="https://s3.ax1x.com/2021/02/19/yh57R0.png" alt="yh57R0.png" /></a></p>

<ul>
  <li>如何把日志打印到文件</li>
</ul>

<p>可以直接在application里面设置（简单设置），也可以在logback官网上下载.xml配置文件。</p>

<p>logback-spring.xml文件必须放在resource下面，且名字不能变，spring会自动识别。</p>

<h2 id="git">Git</h2>

<h3 id="如何在idea集成git">如何在IDEA集成git</h3>

<p>下载git插件，然后指定git/bin下面的git.exe路径，即可继承git，下面会出现version control按钮，点击绿勾可以commit。</p>

</article>
      </div>
    </main>

    
  </body>
</html>