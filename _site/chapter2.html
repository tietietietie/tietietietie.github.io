<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <title>社区论坛：登录模块</title>

  <!-- Begin Jekyll SEO tag v2.6.1 -->
<meta name="generator" content="Jekyll v3.8.7" />
<meta property="og:title" content="社区论坛：登录模块" />
<meta name="author" content="tie" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="第二章：开发社区的登录模块 发送邮件 目的：服务器向用户发送邮件 邮箱设置 申请了一个新浪邮箱，设置STMP服务开启。 安装Spring mail的jar包 配置邮箱 #MailProperties spring.mail.host=smtp.sina.com spring.mail.port=465 spring.mail.username=nowcoderzt@sina.com spring.mail.password=0dba281fa3487473 spring.mail.protocol=smtps spring.mail.properties.mail.smtp.ssl.enable=true 创建一个MailSender类 @Component public class MailClient { private static final Logger logger = LoggerFactory.getLogger(MailClient.class); @Autowired private JavaMailSender mailSender; @Value(&quot;${spring.mail.username}&quot;) private String from; public void sendMail(String to, String subject, String context) { try { MimeMessage message = mailSender.createMimeMessage(); MimeMessageHelper helper = new MimeMessageHelper(message); helper.setFrom(from); helper.setTo(to); helper.setSubject(subject); helper.setText(context, true); mailSender.send(helper.getMimeMessage()); } catch (MessagingException e) { logger.error(&quot;发送邮件失败&quot; + e.getMessage()); } } } 测试邮件发送成功 Spring Email 模板引擎 发送的是Html格式的邮件 在测试类中，需要我们主动调用模板引擎，注入相应bean即可，代码如下： @Test public void testHtmlMail() { Context context = new Context(); context.setVariable(&quot;username&quot;, &quot;sunday&quot;); String content = templateEngine.process(&quot;/mail/demo&quot;, context); System.out.println(content); mailClient.sendMail(&quot;zhangtiezhangtie@outlook.com&quot;, &quot;HTML&quot;, content); } 其中，需要指定模板文件的地址，及模板所需要的参数，模板引擎会自动生成网页（一个字符串content），把这个字符串使用mailClient发送即可。 开发注册功能 web项目：按照请求拆解功能，比如注册功能： 1，打开注册网页 2，把注册的信息发送给服务器（点注册） 3，把激活邮件发送给邮箱 4，利用激活链接打开网页 每一次请求都是先开发数据访问层，在开发业务层，最后开发视图层（三层架构），但是每一次请求不一定要用到这三层 打开注册页面 使用thymeleaf实现一段标签的复用 把index的顶部标签复用给register.html，部分代码如下： //在Index的header部分添加th代码 &lt;div class=&quot;nk-container&quot;&gt; &lt;!-- 头部 --&gt; &lt;header class=&quot;bg-dark sticky-top&quot; th:fragment=&quot;header&quot;&gt; //在register部分添加如下th代码 &lt;div class=&quot;nk-container&quot;&gt; &lt;!-- 头部 --&gt; &lt;header class=&quot;bg-dark sticky-top&quot; th:replace=&quot;index::header&quot;&gt; 注意th的变量需要用@{}括起来，不然会报错 提交注册数据 首先导入“判断字符串/集合空值”的包 把我们网站的链接做成可配置的。在properties中设置网站域名（本机） 写两个工具，可以生成随机字符串，以及加密工具。 写一个service类，帮助我们把传来的用户数据存到数据库里面，具体包括：用户查重，加密密码，发送用户激活码，代码如下： public class UserService { @Autowired private UserMapper userMapper; @Autowired private MailClient mailClient; @Autowired private TemplateEngine templateEngine; @Value(&quot;${community.path.domain}&quot;) private String domain; @Value(&quot;${server.servlet.context-path}&quot;) private String contextPath; public User findUserById(int id) { return userMapper.selectById(id); } public Map&lt;String, Object&gt; register(User user) { Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); //空值处理 if (user == null) { throw new IllegalArgumentException(&quot;参数不能为空，谢谢&quot;); } if (StringUtils.isBlank(user.getUsername())) { map.put(&quot;usernameMsg&quot;, &quot;账号不能为空&quot;); return map; } if (StringUtils.isBlank(user.getPassword())) { map.put(&quot;passwordMsg&quot;, &quot;密码不能为空&quot;); return map; } if (StringUtils.isBlank(user.getEmail())) { map.put(&quot;emailMsg&quot;, &quot;邮箱不能为空&quot;); return map; } //验证账号 User findUser = userMapper.selectByName(user.getUsername()); if (findUser != null) { map.put(&quot;usernameMsg&quot;, &quot;该账号已存在&quot;); return map; } //验证邮箱 findUser = userMapper.selectByEmail(user.getEmail()); if (findUser != null) { map.put(&quot;emailMsg&quot;, &quot;该邮箱已存在&quot;); return map; } //注册用户 user.setSalt(CommunityUtil.generateUUID().substring(0, 5)); user.setPassword(CommunityUtil.md5(user.getPassword() + user.getSalt())); user.setType(0); user.setStatus(0); user.setActivationCode(CommunityUtil.generateUUID()); user.setHeaderUrl(String.format(&quot;http://images.nowcoder.com/head/%dt.png&quot;, new Random().nextInt(1000))); user.setCreatTime(new Date()); userMapper.insertUser(user); //发送激活邮件 Context context = new Context(); context.setVariable(&quot;email&quot;, user.getEmail()); //http://localhost:15213/communityactivation/101/code String url = domain + contextPath + &quot;/activation&quot; + user.getId() + &quot;/&quot; + user.getActivationCode(); context.setVariable(&quot;url&quot;, url); String content = templateEngine.process(&quot;/mail/activation&quot;, context); mailClient.sendMail(user.getEmail(), &quot;激活账号&quot;, content); } } 写一个controller类，来进行前后端交互 注册工程后，页面跳转到首页（第三方页面：operate-result.html，显示页面在多少秒后跳转（转到首页）） 在修改html时，需要给表单中的每一个获得的变量（账号名/邮箱等），指定参数名，和user中的参数名一一对应，这样spring mvc可以自动的创建user 回到错误页面，需要把这些错误信息还在register中显示，使用th:value = “@{//判断user是否为null}” 终于收到了激活邮箱。。 激活账号 有多种情况： 成功激活（第一次） 重复激活 无效的激活链接 会话管理 定义 http是无状态且有会话的。 无状态：请求之间是没有联系的（无差别对待）（用户没有办法进行连续的交互）（服务器无法记住浏览器的状态） 如何解决业务之间的联系：使用cookies来解决无状态，形成整体。 所以有会话是指：使得服务器和浏览器之间能有连续的交互。使得服务器能够记住浏览器。 cookies：由服务器发送给浏览器（在响应头），表明其身份，浏览器保存到本地，下次浏览器携带着cookies再次访问服务器时（在请求头），服务器能够认识这个浏览器。所以cookies是一个特殊的数据.(很小的数据，只有一对key:value)（能够得到浏览器的一些特征数据） 演示cookies 为访问此路径的浏览器生成cookie并放在response中，代码如下： //cookies演示 @RequestMapping(path = &quot;cookie/set&quot;, method = RequestMethod.GET) @ResponseBody public String setCookie(HttpServletResponse response) { //创建cookie Cookie cookie = new Cookie(&quot;code&quot;, CommunityUtil.generateUUID()); //设置cookie的生效范围（只有在哪些路径有效） cookie.setPath(&quot;/community/alpha&quot;); //设置cookie的生存时间（因为默认是存在内存里的，关掉浏览器就没了）(单位是秒） cookie.setMaxAge(60 * 10); response.addCookie(cookie); return &quot;set cookie&quot;; } 如何使用浏览器发来的cookie，如下： @RequestMapping(path = &quot;cookie/get&quot;, method = RequestMethod.GET) @ResponseBody public String getCookie(@CookieValue(&quot;code&quot;) String code) { System.out.println(code); return &quot;get cookie&quot;; } 优点：弥补http的无状态 缺点： 不安全，因为不知道浏览器所在系统的安全性 对流量/性能有影响 演示Session 另一种解决办法：session 用于在服务端的存储在客服端信息，优点是安全，缺点是造成了服务器的压力。 与cookie是有关系的 1，浏览器访问服务器，服务器创建一个对应的session对象，session依赖于cookie，自动创建了sessionID放在cookie中，发送给服务器 2，浏览器把存的cookie的sessionID，在下次请求中发送给服务器，从而服务器可以通过这个sessionID，找到与此浏览器对应的session对象 演示如何创建session，传入数据 //session示例 @RequestMapping(path = &quot;session/set&quot;, method = RequestMethod.GET) @ResponseBody public String setSession(HttpSession session) { //SpringMVC会自动地注入，只需要声明即可 session.setAttribute(&quot;id&quot;, 1); session.setAttribute(&quot;name&quot;, &quot;test&quot;); return &quot;set session&quot;; } 服务端获得对应地seesion参数值以及sessionID @RequestMapping(path = &quot;session/get&quot;, method = RequestMethod.GET) @ResponseBody public String getSession(HttpSession session) { System.out.println(session.getId()); System.out.println(session.getAttribute(&quot;name&quot;)); return &quot;get session&quot;; } 所以session也能解决会话问题。 Q&amp;A 在分布式部署中，为什么不使用session呢？ 因为服务器是分布式部署的（承载大流量），浏览器访问的是服务器代替nginx，nginx按照负载均衡的原则分配请求。在多次请求的过程中，可能会有多台服务器处理同一个浏览器的请求，但session只保存在一台服务器中。 解决策略： 粘性session：浏览器只访问一个服务器。（负载不均衡） 同步session：每个服务器存的session都相同（性能降低，增大服务器的耦合性） 共享session：单独有一台服务器来存储session，当服务器需要使用session时，往这台服务器申请（这台服务器威胁到了整个集群） 常用解决方案：一般数据都使用cookie而不是session，必要重要的数据存到数据库（集群）（非关系型数据库redis）里。 生成验证码 使用现成工具：kaptcha，在服务端内存中画出验证码，发送给浏览器。 导入kaptcha的jar包 编写Kaptcha的配置类 生成随机字符，生成图片 配置Kaptcha如下： @Configuration public class KaptchaConfig { @Bean public Producer kaptchaProducer() { Properties properties = new Properties(); properties.setProperty(&quot;kaptcha.image.width&quot;, &quot;100&quot;); properties.setProperty(&quot;kaptcha.image.height&quot;, &quot;40&quot;); properties.setProperty(&quot;kaptcha.textproducer.font.size&quot;, &quot;32&quot;); properties.setProperty(&quot;kaptcha.textproducer.font.color&quot;, &quot;0,0,0&quot;); properties.setProperty(&quot;kaptcha.textproducer.char.string&quot;, &quot;1234567890qwertyuiopsdfghklzxcnvbm&quot;); properties.setProperty(&quot;kaptcha.textproducer.char.length&quot;, &quot;4&quot;); properties.setProperty(&quot;kaptcha.noise,impl&quot;, &quot;com.google.code.kaptcha.impl.NoNoise&quot;); DefaultKaptcha kaptcha = new DefaultKaptcha(); Config config = new Config(properties); kaptcha.setConfig(config); return kaptcha; } 生成验证码，如下： @RequestMapping(path = &quot;/kaptcha&quot;, method = RequestMethod.GET) public void getKaptcha(HttpServletResponse response, HttpSession session) { //生成验证码 String text = kaptchaProducer.createText(); BufferedImage image = kaptchaProducer.createImage(text); //保存验证码到session session.setAttribute(&quot;kaptcha&quot;, text); //将图片输出到浏览器 response.setContentType(&quot;image/png&quot;); try { OutputStream os = response.getOutputStream(); ImageIO.write(image, &quot;png&quot;, os); } catch (IOException e) { logger.error(&quot;响应验证码失败&quot; + e.getMessage()); } login.html修改如下： &lt;div class=&quot;col-sm-4&quot;&gt; &lt;img th:src=&quot;@{/kaptcha}&quot; id=&quot;kaptcha&quot; style=&quot;width:100px;height:40px;&quot; class=&quot;mr-2&quot;/&gt; &lt;a href=&quot;javascript:refresh_kaptcha();&quot; class=&quot;font-size-12 align-bottom&quot;&gt;刷新验证码&lt;/a&gt; &lt;/div&gt; function refresh_kaptcha(){ var path = &quot;/community/kaptcha?p=&quot; + Math.random(); $(&quot;#kaptcha&quot;).attr(&quot;src&quot;,path); } 开发登录/退出功能 包含有如下业务： 登录 验证账号，密码，验证码 登录成功，生成登录凭证，发送给客户端 登录失败，跳转到登录页 退出 将登录凭证修改为失效 跳转至网站首页 登录凭证：一个key，包含有敏感数据，存在数据库（后面会存在redies），数据结构如下： 实现数据层 可以用注解来实现LoginTicketMapper接口（与之前在Mapper中写配置文件不同） 好处：方便，坏处：难以阅读，不够整洁 实现业务层 包括对用户名/密码的判断，已经验证是否存在该user，如果存在，需要返回一个唯一的ticket。 public Map&lt;String, Object&gt; login(String username, String password, int expiredSeconds) { Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); //空值判断 if (StringUtils.isBlank(username)) { map.put(&quot;usernameMsg&quot;, &quot;账号不能为空&quot;); return map; } if (StringUtils.isBlank(password)) { map.put(&quot;passwordMsg&quot;, &quot;密码不能为空&quot;); return map; } //验证账号 User user = userMapper.selectByName(username); if (user == null) { map.put(&quot;usernameMsg&quot;, &quot;账号不存在&quot;); return map; } if (user.getStatus() == 0) { map.put(&quot;usernameMsg&quot;, &quot;账号还没有激活&quot;); return map; } //验证密码 password = CommunityUtil.md5(password + user.getSalt()); if (!password.equals(user.getPassword())) { map.put(&quot;passwordMsg&quot;, &quot;密码错误&quot;); return map; } //生成登录凭证 LoginTicket loginTicket = new LoginTicket(); loginTicket.setUserId(user.getId()); loginTicket.setTicket(CommunityUtil.generateUUID()); loginTicket.setStatus(0); loginTicket.setExpired(new Date(System.currentTimeMillis() + expiredSeconds * 1000)); loginTicketMapper.insertLoginTicket(loginTicket); map.put(&quot;ticket&quot;, loginTicket.getTicket()); return map; } 实现处理层 注意进行post请求后，当服务器返回错误的username给login页面时，需要获得该错误的username，显示在网页上, 如何获得该username呢？可以直接在request中取值（因为username是在request中的），使用param.username，可在request中取值。 @RequestMapping(path = &quot;/login&quot;, method = RequestMethod.POST) public String login(String username, String password, String code, boolean rememberMe, Model model, HttpSession session, HttpServletResponse response) { //检查验证码 String kaptcha = (String) session.getAttribute(&quot;kaptcha&quot;); if (StringUtils.isBlank(kaptcha) || StringUtils.isBlank(code) || !kaptcha.equalsIgnoreCase(code)) { model.addAttribute(&quot;codeMsg&quot;, &quot;验证码错误&quot;); return &quot;/site/login&quot;; } //检查账号密码 int expiredSeconds = rememberMe ? REMEMBER_EXPIRED_SECONDS : DEFALUT_EXPIRED_SECONDS; Map&lt;String, Object&gt; map = userService.login(username, password, expiredSeconds); if (map.containsKey(&quot;ticket&quot;)) { Cookie cookie = new Cookie(&quot;ticket&quot;, (String) map.get(&quot;ticket&quot;)); cookie.setPath(contextPath); cookie.setMaxAge(expiredSeconds); response.addCookie(cookie); return &quot;redirect:/index&quot;; } else { model.addAttribute(&quot;usernameMsg&quot;, map.get(&quot;usernameMsg&quot;)); model.addAttribute(&quot;passwordMsg&quot;, map.get(&quot;passwordMsg&quot;)); return &quot;/site/login&quot;; } } @RequestMapping(path = &quot;/logout&quot;, method = RequestMethod.GET) public String logout(@CookieValue(&quot;ticket&quot;) String ticket) { userService.logout(ticket); //默认get请求 return &quot;redirect:/login&quot;; } 注意在index.html中把退出登录按钮的链接配置好。 显示登录信息 根据登录与否，显示登录信息 登录信息在头部，每一个页面都需要显示信息 拦截器：拦截请求，然后在请求中添加代码，能以很低的耦合度，解决通用问题。 拦截器示例 实现拦截器的接口 配置拦截器：指定拦截哪些请求 拦截器与controller没有直接关系，耦合度很低。 @Component public class Alphainteceptor implements HandlerInterceptor { private static final Logger logger = LoggerFactory.getLogger(Alphainteceptor.class); //在controller之前执行 //返回false，表示controller不往下执行 @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) { logger.debug(&quot;preHandler: &quot; + handler.toString()); return true; } //调用完controller之后执行 @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) { logger.debug(&quot;postHander:&quot; + handler.toString()); } //在模板引擎执行完之后执行 @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) { logger.debug(&quot;afterCompletion : &quot; + handler.toString()); } } 实现了拦截器的类之后，还需要对这个拦截器进行进行配置，代码如下： @Configuration public class WebMvcConfig implements WebMvcConfigurer { @Autowired private Alphainteceptor alphainteceptor; @Override public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(alphainteceptor) .excludePathPatterns(&quot;/**/*.css&quot;, &quot;/**/*.js&quot;, &quot;/**/*.png&quot;, &quot;/**/*.jpg&quot;, &quot;/**/*.jpeg&quot;) .addPathPatterns(&quot;/register&quot;, &quot;/login&quot;); } } 拦截器应用 包括以下步骤： 在请求之前先查到登录用户 在本次请求中持有用户数据 在模板视图上显示用户数据 在请求结束时清理用户数据 浏览器存着ticket放在cookie中，每次访问服务器，都会把这个ticket发送给服务器，从而得到当前用户是谁（login_ticket），得到user后，把它放在model中，最终html中则显示了用户信息。 把user信息放在ThreadLocal中，这样在整个请求过程中，user都一直存在，并能被访问。 实现拦截器： @Component public class LoginTicketiterceptor implements HandlerInterceptor { @Autowired private UserService userService; @Autowired private HostHolder hostHolder; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) { //从cookie中获取ticket String ticket = CookieUtil.getValue(request, &quot;ticket&quot;); if (ticket != null) { LoginTicket loginTicket = userService.findLoginTicket(ticket); if (loginTicket != null &amp;&amp; loginTicket.getStatus() == 0 &amp;&amp; loginTicket.getExpired().after(new Date())) { User user = userService.findUserById(loginTicket.getUserId()); //在本此请求中持有用户，考虑多线程并发，多线程隔离 hostHolder.setUser(user); } } return true; } @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) { User user = hostHolder.getUser(); if (user != null &amp;&amp; modelAndView != null) { modelAndView.addObject(&quot;loginUser&quot;, user); } } @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) { hostHolder.clear(); } } 实现HostHolder //持有用户信息，用于代替session对象，协程隔离 @Component public class HostHolder { private ThreadLocal&lt;User&gt; users = new ThreadLocal&lt;&gt;(); public void setUser(User user) { users.set(user); } public User getUser() { return users.get(); } public void clear() { users.remove(); } } 配置拦截器 @Configuration public class WebMvcConfig implements WebMvcConfigurer { @Autowired private Alphainteceptor alphainteceptor; @Autowired private LoginTicketiterceptor loginTicketiterceptor; @Override public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(alphainteceptor) .excludePathPatterns(&quot;/**/*.css&quot;, &quot;/**/*.js&quot;, &quot;/**/*.png&quot;, &quot;/**/*.jpg&quot;, &quot;/**/*.jpeg&quot;) .addPathPatterns(&quot;/register&quot;, &quot;/login&quot;); registry.addInterceptor(loginTicketiterceptor) .excludePathPatterns(&quot;/**/*.css&quot;, &quot;/**/*.js&quot;, &quot;/**/*.png&quot;, &quot;/**/*.jpg&quot;, &quot;/**/*.jpeg&quot;); } } 账号设置 开发步骤： 访问账号设置页面 上传头像（存在服务器上） 获取图像（页面能够在服务器上获取头像） 访问账号设置页面 新建UserController，并处理/user/setting的get方法，返回账号设置页面模板。 修改Index中的header，将对应账号设置按钮，设置相应路径，实现跳转。 上传文件 在service层中，需要修改用户头像的url 在controller层中，直接处理传来的文件（利用Spring MVC中的MultipartFile）。 服务层代码如下： public int updataHeader(int userId, String headerUrl) { return userMapper.updateHeader(userId, headerUrl); } 控制层代码如下： @RequestMapping(path = &quot;/upload&quot;, method = RequestMethod.POST) public String uploadHeader(MultipartFile headerImage, Model model) { if (headerImage == null) { model.addAttribute(&quot;error&quot;, &quot;您没有选择图片&quot;); return &quot;/site/setting&quot;; } //不能按照原始文件存储，所以需要生成一个随机名字，但是后缀不能变。 String fileName = headerImage.getOriginalFilename(); String suffix = fileName.substring(fileName.lastIndexOf(&quot;.&quot;)); if (StringUtils.isBlank(suffix)) { model.addAttribute(&quot;error&quot;, &quot;文件格式不正确&quot;); return &quot;/site/setting&quot;; } //生成随机文件名 fileName = CommunityUtil.generateUUID() + suffix; //确定文件路径 File dest = new File(uploadPath + &quot;/&quot; + fileName); try { headerImage.transferTo(dest); } catch (IOException e) { logger.error(&quot;上传文件失败&quot; + e.getMessage()); throw new RuntimeException(&quot;上传文件失败，服务器发生异常&quot;, e); } //更新当前头像途径（外部路径，非本地路径） //http://localhost:15213/community/user/header/***.png User user = hostHolder.getUser(); String headerUrl = domain + contextPath + &quot;/user/header/&quot; + fileName; userService.updataHeader(user.getId(), headerUrl); return &quot;redirect:/index&quot;; } @RequestMapping(path = &quot;/header/{filename}&quot;, method = RequestMethod.GET) public void getHeader(@PathVariable(&quot;filename&quot;) String filename, HttpServletResponse response) { //寻找服务器存放的路径 filename = uploadPath + &quot;/&quot; + filename; //解析文件后缀 String suffix = filename.substring(filename.lastIndexOf(&quot;.&quot;)); response.setContentType(&quot;image/jpg&quot;); try ( OutputStream os = response.getOutputStream(); FileInputStream fis = new FileInputStream(filename); ) { byte[] buffer = new byte[1024]; int b = 0; while (b != -1) { b = fis.read(buffer); os.write(buffer, 0, b); } } catch (IOException e) { logger.error(&quot;读取头像失败&quot; + e.getMessage()); } } 检查登录状态 用户可以通过路径访问http://localhost:15213/community/user/setting，这个链接仅仅是隐藏是不够安全的，服务端需要判断用户是否登录，来允许是否访问。 可以使用拦截器进行配置，也可以直接在方法上加注解。 自定义注解 使用元注解来定义我们自己的注解：@Target,@Retention,@Document,@Inherited 如何读取注解：Method.getDeclaredAnnotations(),Method.getAnnotation(Class annotationClass) 通过加注解来拦截指定路径 @Component public class LoginRequiredinteceptor implements HandlerInterceptor { private static final Logger logger = LoggerFactory.getLogger(LoginRequiredinteceptor.class); @Autowired private HostHolder hostHolder; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) { if (handler instanceof HandlerMethod) { HandlerMethod handlerMethod = (HandlerMethod) handler; Method method = handlerMethod.getMethod(); LoginRequired loginRequired = method.getAnnotation(LoginRequired.class); if (loginRequired != null &amp;&amp; hostHolder.getUser() == null) { try { response.sendRedirect(request.getContextPath() + &quot;/login&quot;); } catch (IOException e) { logger.error(&quot;重定向登录页面失败&quot; + e.getMessage()); } return false; } } return true; } } 在一些需要登录的请求前，加上loginrequired注解，就可以对未登录的请求，强制重定向到登录页面。" />
<meta property="og:description" content="第二章：开发社区的登录模块 发送邮件 目的：服务器向用户发送邮件 邮箱设置 申请了一个新浪邮箱，设置STMP服务开启。 安装Spring mail的jar包 配置邮箱 #MailProperties spring.mail.host=smtp.sina.com spring.mail.port=465 spring.mail.username=nowcoderzt@sina.com spring.mail.password=0dba281fa3487473 spring.mail.protocol=smtps spring.mail.properties.mail.smtp.ssl.enable=true 创建一个MailSender类 @Component public class MailClient { private static final Logger logger = LoggerFactory.getLogger(MailClient.class); @Autowired private JavaMailSender mailSender; @Value(&quot;${spring.mail.username}&quot;) private String from; public void sendMail(String to, String subject, String context) { try { MimeMessage message = mailSender.createMimeMessage(); MimeMessageHelper helper = new MimeMessageHelper(message); helper.setFrom(from); helper.setTo(to); helper.setSubject(subject); helper.setText(context, true); mailSender.send(helper.getMimeMessage()); } catch (MessagingException e) { logger.error(&quot;发送邮件失败&quot; + e.getMessage()); } } } 测试邮件发送成功 Spring Email 模板引擎 发送的是Html格式的邮件 在测试类中，需要我们主动调用模板引擎，注入相应bean即可，代码如下： @Test public void testHtmlMail() { Context context = new Context(); context.setVariable(&quot;username&quot;, &quot;sunday&quot;); String content = templateEngine.process(&quot;/mail/demo&quot;, context); System.out.println(content); mailClient.sendMail(&quot;zhangtiezhangtie@outlook.com&quot;, &quot;HTML&quot;, content); } 其中，需要指定模板文件的地址，及模板所需要的参数，模板引擎会自动生成网页（一个字符串content），把这个字符串使用mailClient发送即可。 开发注册功能 web项目：按照请求拆解功能，比如注册功能： 1，打开注册网页 2，把注册的信息发送给服务器（点注册） 3，把激活邮件发送给邮箱 4，利用激活链接打开网页 每一次请求都是先开发数据访问层，在开发业务层，最后开发视图层（三层架构），但是每一次请求不一定要用到这三层 打开注册页面 使用thymeleaf实现一段标签的复用 把index的顶部标签复用给register.html，部分代码如下： //在Index的header部分添加th代码 &lt;div class=&quot;nk-container&quot;&gt; &lt;!-- 头部 --&gt; &lt;header class=&quot;bg-dark sticky-top&quot; th:fragment=&quot;header&quot;&gt; //在register部分添加如下th代码 &lt;div class=&quot;nk-container&quot;&gt; &lt;!-- 头部 --&gt; &lt;header class=&quot;bg-dark sticky-top&quot; th:replace=&quot;index::header&quot;&gt; 注意th的变量需要用@{}括起来，不然会报错 提交注册数据 首先导入“判断字符串/集合空值”的包 把我们网站的链接做成可配置的。在properties中设置网站域名（本机） 写两个工具，可以生成随机字符串，以及加密工具。 写一个service类，帮助我们把传来的用户数据存到数据库里面，具体包括：用户查重，加密密码，发送用户激活码，代码如下： public class UserService { @Autowired private UserMapper userMapper; @Autowired private MailClient mailClient; @Autowired private TemplateEngine templateEngine; @Value(&quot;${community.path.domain}&quot;) private String domain; @Value(&quot;${server.servlet.context-path}&quot;) private String contextPath; public User findUserById(int id) { return userMapper.selectById(id); } public Map&lt;String, Object&gt; register(User user) { Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); //空值处理 if (user == null) { throw new IllegalArgumentException(&quot;参数不能为空，谢谢&quot;); } if (StringUtils.isBlank(user.getUsername())) { map.put(&quot;usernameMsg&quot;, &quot;账号不能为空&quot;); return map; } if (StringUtils.isBlank(user.getPassword())) { map.put(&quot;passwordMsg&quot;, &quot;密码不能为空&quot;); return map; } if (StringUtils.isBlank(user.getEmail())) { map.put(&quot;emailMsg&quot;, &quot;邮箱不能为空&quot;); return map; } //验证账号 User findUser = userMapper.selectByName(user.getUsername()); if (findUser != null) { map.put(&quot;usernameMsg&quot;, &quot;该账号已存在&quot;); return map; } //验证邮箱 findUser = userMapper.selectByEmail(user.getEmail()); if (findUser != null) { map.put(&quot;emailMsg&quot;, &quot;该邮箱已存在&quot;); return map; } //注册用户 user.setSalt(CommunityUtil.generateUUID().substring(0, 5)); user.setPassword(CommunityUtil.md5(user.getPassword() + user.getSalt())); user.setType(0); user.setStatus(0); user.setActivationCode(CommunityUtil.generateUUID()); user.setHeaderUrl(String.format(&quot;http://images.nowcoder.com/head/%dt.png&quot;, new Random().nextInt(1000))); user.setCreatTime(new Date()); userMapper.insertUser(user); //发送激活邮件 Context context = new Context(); context.setVariable(&quot;email&quot;, user.getEmail()); //http://localhost:15213/communityactivation/101/code String url = domain + contextPath + &quot;/activation&quot; + user.getId() + &quot;/&quot; + user.getActivationCode(); context.setVariable(&quot;url&quot;, url); String content = templateEngine.process(&quot;/mail/activation&quot;, context); mailClient.sendMail(user.getEmail(), &quot;激活账号&quot;, content); } } 写一个controller类，来进行前后端交互 注册工程后，页面跳转到首页（第三方页面：operate-result.html，显示页面在多少秒后跳转（转到首页）） 在修改html时，需要给表单中的每一个获得的变量（账号名/邮箱等），指定参数名，和user中的参数名一一对应，这样spring mvc可以自动的创建user 回到错误页面，需要把这些错误信息还在register中显示，使用th:value = “@{//判断user是否为null}” 终于收到了激活邮箱。。 激活账号 有多种情况： 成功激活（第一次） 重复激活 无效的激活链接 会话管理 定义 http是无状态且有会话的。 无状态：请求之间是没有联系的（无差别对待）（用户没有办法进行连续的交互）（服务器无法记住浏览器的状态） 如何解决业务之间的联系：使用cookies来解决无状态，形成整体。 所以有会话是指：使得服务器和浏览器之间能有连续的交互。使得服务器能够记住浏览器。 cookies：由服务器发送给浏览器（在响应头），表明其身份，浏览器保存到本地，下次浏览器携带着cookies再次访问服务器时（在请求头），服务器能够认识这个浏览器。所以cookies是一个特殊的数据.(很小的数据，只有一对key:value)（能够得到浏览器的一些特征数据） 演示cookies 为访问此路径的浏览器生成cookie并放在response中，代码如下： //cookies演示 @RequestMapping(path = &quot;cookie/set&quot;, method = RequestMethod.GET) @ResponseBody public String setCookie(HttpServletResponse response) { //创建cookie Cookie cookie = new Cookie(&quot;code&quot;, CommunityUtil.generateUUID()); //设置cookie的生效范围（只有在哪些路径有效） cookie.setPath(&quot;/community/alpha&quot;); //设置cookie的生存时间（因为默认是存在内存里的，关掉浏览器就没了）(单位是秒） cookie.setMaxAge(60 * 10); response.addCookie(cookie); return &quot;set cookie&quot;; } 如何使用浏览器发来的cookie，如下： @RequestMapping(path = &quot;cookie/get&quot;, method = RequestMethod.GET) @ResponseBody public String getCookie(@CookieValue(&quot;code&quot;) String code) { System.out.println(code); return &quot;get cookie&quot;; } 优点：弥补http的无状态 缺点： 不安全，因为不知道浏览器所在系统的安全性 对流量/性能有影响 演示Session 另一种解决办法：session 用于在服务端的存储在客服端信息，优点是安全，缺点是造成了服务器的压力。 与cookie是有关系的 1，浏览器访问服务器，服务器创建一个对应的session对象，session依赖于cookie，自动创建了sessionID放在cookie中，发送给服务器 2，浏览器把存的cookie的sessionID，在下次请求中发送给服务器，从而服务器可以通过这个sessionID，找到与此浏览器对应的session对象 演示如何创建session，传入数据 //session示例 @RequestMapping(path = &quot;session/set&quot;, method = RequestMethod.GET) @ResponseBody public String setSession(HttpSession session) { //SpringMVC会自动地注入，只需要声明即可 session.setAttribute(&quot;id&quot;, 1); session.setAttribute(&quot;name&quot;, &quot;test&quot;); return &quot;set session&quot;; } 服务端获得对应地seesion参数值以及sessionID @RequestMapping(path = &quot;session/get&quot;, method = RequestMethod.GET) @ResponseBody public String getSession(HttpSession session) { System.out.println(session.getId()); System.out.println(session.getAttribute(&quot;name&quot;)); return &quot;get session&quot;; } 所以session也能解决会话问题。 Q&amp;A 在分布式部署中，为什么不使用session呢？ 因为服务器是分布式部署的（承载大流量），浏览器访问的是服务器代替nginx，nginx按照负载均衡的原则分配请求。在多次请求的过程中，可能会有多台服务器处理同一个浏览器的请求，但session只保存在一台服务器中。 解决策略： 粘性session：浏览器只访问一个服务器。（负载不均衡） 同步session：每个服务器存的session都相同（性能降低，增大服务器的耦合性） 共享session：单独有一台服务器来存储session，当服务器需要使用session时，往这台服务器申请（这台服务器威胁到了整个集群） 常用解决方案：一般数据都使用cookie而不是session，必要重要的数据存到数据库（集群）（非关系型数据库redis）里。 生成验证码 使用现成工具：kaptcha，在服务端内存中画出验证码，发送给浏览器。 导入kaptcha的jar包 编写Kaptcha的配置类 生成随机字符，生成图片 配置Kaptcha如下： @Configuration public class KaptchaConfig { @Bean public Producer kaptchaProducer() { Properties properties = new Properties(); properties.setProperty(&quot;kaptcha.image.width&quot;, &quot;100&quot;); properties.setProperty(&quot;kaptcha.image.height&quot;, &quot;40&quot;); properties.setProperty(&quot;kaptcha.textproducer.font.size&quot;, &quot;32&quot;); properties.setProperty(&quot;kaptcha.textproducer.font.color&quot;, &quot;0,0,0&quot;); properties.setProperty(&quot;kaptcha.textproducer.char.string&quot;, &quot;1234567890qwertyuiopsdfghklzxcnvbm&quot;); properties.setProperty(&quot;kaptcha.textproducer.char.length&quot;, &quot;4&quot;); properties.setProperty(&quot;kaptcha.noise,impl&quot;, &quot;com.google.code.kaptcha.impl.NoNoise&quot;); DefaultKaptcha kaptcha = new DefaultKaptcha(); Config config = new Config(properties); kaptcha.setConfig(config); return kaptcha; } 生成验证码，如下： @RequestMapping(path = &quot;/kaptcha&quot;, method = RequestMethod.GET) public void getKaptcha(HttpServletResponse response, HttpSession session) { //生成验证码 String text = kaptchaProducer.createText(); BufferedImage image = kaptchaProducer.createImage(text); //保存验证码到session session.setAttribute(&quot;kaptcha&quot;, text); //将图片输出到浏览器 response.setContentType(&quot;image/png&quot;); try { OutputStream os = response.getOutputStream(); ImageIO.write(image, &quot;png&quot;, os); } catch (IOException e) { logger.error(&quot;响应验证码失败&quot; + e.getMessage()); } login.html修改如下： &lt;div class=&quot;col-sm-4&quot;&gt; &lt;img th:src=&quot;@{/kaptcha}&quot; id=&quot;kaptcha&quot; style=&quot;width:100px;height:40px;&quot; class=&quot;mr-2&quot;/&gt; &lt;a href=&quot;javascript:refresh_kaptcha();&quot; class=&quot;font-size-12 align-bottom&quot;&gt;刷新验证码&lt;/a&gt; &lt;/div&gt; function refresh_kaptcha(){ var path = &quot;/community/kaptcha?p=&quot; + Math.random(); $(&quot;#kaptcha&quot;).attr(&quot;src&quot;,path); } 开发登录/退出功能 包含有如下业务： 登录 验证账号，密码，验证码 登录成功，生成登录凭证，发送给客户端 登录失败，跳转到登录页 退出 将登录凭证修改为失效 跳转至网站首页 登录凭证：一个key，包含有敏感数据，存在数据库（后面会存在redies），数据结构如下： 实现数据层 可以用注解来实现LoginTicketMapper接口（与之前在Mapper中写配置文件不同） 好处：方便，坏处：难以阅读，不够整洁 实现业务层 包括对用户名/密码的判断，已经验证是否存在该user，如果存在，需要返回一个唯一的ticket。 public Map&lt;String, Object&gt; login(String username, String password, int expiredSeconds) { Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); //空值判断 if (StringUtils.isBlank(username)) { map.put(&quot;usernameMsg&quot;, &quot;账号不能为空&quot;); return map; } if (StringUtils.isBlank(password)) { map.put(&quot;passwordMsg&quot;, &quot;密码不能为空&quot;); return map; } //验证账号 User user = userMapper.selectByName(username); if (user == null) { map.put(&quot;usernameMsg&quot;, &quot;账号不存在&quot;); return map; } if (user.getStatus() == 0) { map.put(&quot;usernameMsg&quot;, &quot;账号还没有激活&quot;); return map; } //验证密码 password = CommunityUtil.md5(password + user.getSalt()); if (!password.equals(user.getPassword())) { map.put(&quot;passwordMsg&quot;, &quot;密码错误&quot;); return map; } //生成登录凭证 LoginTicket loginTicket = new LoginTicket(); loginTicket.setUserId(user.getId()); loginTicket.setTicket(CommunityUtil.generateUUID()); loginTicket.setStatus(0); loginTicket.setExpired(new Date(System.currentTimeMillis() + expiredSeconds * 1000)); loginTicketMapper.insertLoginTicket(loginTicket); map.put(&quot;ticket&quot;, loginTicket.getTicket()); return map; } 实现处理层 注意进行post请求后，当服务器返回错误的username给login页面时，需要获得该错误的username，显示在网页上, 如何获得该username呢？可以直接在request中取值（因为username是在request中的），使用param.username，可在request中取值。 @RequestMapping(path = &quot;/login&quot;, method = RequestMethod.POST) public String login(String username, String password, String code, boolean rememberMe, Model model, HttpSession session, HttpServletResponse response) { //检查验证码 String kaptcha = (String) session.getAttribute(&quot;kaptcha&quot;); if (StringUtils.isBlank(kaptcha) || StringUtils.isBlank(code) || !kaptcha.equalsIgnoreCase(code)) { model.addAttribute(&quot;codeMsg&quot;, &quot;验证码错误&quot;); return &quot;/site/login&quot;; } //检查账号密码 int expiredSeconds = rememberMe ? REMEMBER_EXPIRED_SECONDS : DEFALUT_EXPIRED_SECONDS; Map&lt;String, Object&gt; map = userService.login(username, password, expiredSeconds); if (map.containsKey(&quot;ticket&quot;)) { Cookie cookie = new Cookie(&quot;ticket&quot;, (String) map.get(&quot;ticket&quot;)); cookie.setPath(contextPath); cookie.setMaxAge(expiredSeconds); response.addCookie(cookie); return &quot;redirect:/index&quot;; } else { model.addAttribute(&quot;usernameMsg&quot;, map.get(&quot;usernameMsg&quot;)); model.addAttribute(&quot;passwordMsg&quot;, map.get(&quot;passwordMsg&quot;)); return &quot;/site/login&quot;; } } @RequestMapping(path = &quot;/logout&quot;, method = RequestMethod.GET) public String logout(@CookieValue(&quot;ticket&quot;) String ticket) { userService.logout(ticket); //默认get请求 return &quot;redirect:/login&quot;; } 注意在index.html中把退出登录按钮的链接配置好。 显示登录信息 根据登录与否，显示登录信息 登录信息在头部，每一个页面都需要显示信息 拦截器：拦截请求，然后在请求中添加代码，能以很低的耦合度，解决通用问题。 拦截器示例 实现拦截器的接口 配置拦截器：指定拦截哪些请求 拦截器与controller没有直接关系，耦合度很低。 @Component public class Alphainteceptor implements HandlerInterceptor { private static final Logger logger = LoggerFactory.getLogger(Alphainteceptor.class); //在controller之前执行 //返回false，表示controller不往下执行 @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) { logger.debug(&quot;preHandler: &quot; + handler.toString()); return true; } //调用完controller之后执行 @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) { logger.debug(&quot;postHander:&quot; + handler.toString()); } //在模板引擎执行完之后执行 @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) { logger.debug(&quot;afterCompletion : &quot; + handler.toString()); } } 实现了拦截器的类之后，还需要对这个拦截器进行进行配置，代码如下： @Configuration public class WebMvcConfig implements WebMvcConfigurer { @Autowired private Alphainteceptor alphainteceptor; @Override public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(alphainteceptor) .excludePathPatterns(&quot;/**/*.css&quot;, &quot;/**/*.js&quot;, &quot;/**/*.png&quot;, &quot;/**/*.jpg&quot;, &quot;/**/*.jpeg&quot;) .addPathPatterns(&quot;/register&quot;, &quot;/login&quot;); } } 拦截器应用 包括以下步骤： 在请求之前先查到登录用户 在本次请求中持有用户数据 在模板视图上显示用户数据 在请求结束时清理用户数据 浏览器存着ticket放在cookie中，每次访问服务器，都会把这个ticket发送给服务器，从而得到当前用户是谁（login_ticket），得到user后，把它放在model中，最终html中则显示了用户信息。 把user信息放在ThreadLocal中，这样在整个请求过程中，user都一直存在，并能被访问。 实现拦截器： @Component public class LoginTicketiterceptor implements HandlerInterceptor { @Autowired private UserService userService; @Autowired private HostHolder hostHolder; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) { //从cookie中获取ticket String ticket = CookieUtil.getValue(request, &quot;ticket&quot;); if (ticket != null) { LoginTicket loginTicket = userService.findLoginTicket(ticket); if (loginTicket != null &amp;&amp; loginTicket.getStatus() == 0 &amp;&amp; loginTicket.getExpired().after(new Date())) { User user = userService.findUserById(loginTicket.getUserId()); //在本此请求中持有用户，考虑多线程并发，多线程隔离 hostHolder.setUser(user); } } return true; } @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) { User user = hostHolder.getUser(); if (user != null &amp;&amp; modelAndView != null) { modelAndView.addObject(&quot;loginUser&quot;, user); } } @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) { hostHolder.clear(); } } 实现HostHolder //持有用户信息，用于代替session对象，协程隔离 @Component public class HostHolder { private ThreadLocal&lt;User&gt; users = new ThreadLocal&lt;&gt;(); public void setUser(User user) { users.set(user); } public User getUser() { return users.get(); } public void clear() { users.remove(); } } 配置拦截器 @Configuration public class WebMvcConfig implements WebMvcConfigurer { @Autowired private Alphainteceptor alphainteceptor; @Autowired private LoginTicketiterceptor loginTicketiterceptor; @Override public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(alphainteceptor) .excludePathPatterns(&quot;/**/*.css&quot;, &quot;/**/*.js&quot;, &quot;/**/*.png&quot;, &quot;/**/*.jpg&quot;, &quot;/**/*.jpeg&quot;) .addPathPatterns(&quot;/register&quot;, &quot;/login&quot;); registry.addInterceptor(loginTicketiterceptor) .excludePathPatterns(&quot;/**/*.css&quot;, &quot;/**/*.js&quot;, &quot;/**/*.png&quot;, &quot;/**/*.jpg&quot;, &quot;/**/*.jpeg&quot;); } } 账号设置 开发步骤： 访问账号设置页面 上传头像（存在服务器上） 获取图像（页面能够在服务器上获取头像） 访问账号设置页面 新建UserController，并处理/user/setting的get方法，返回账号设置页面模板。 修改Index中的header，将对应账号设置按钮，设置相应路径，实现跳转。 上传文件 在service层中，需要修改用户头像的url 在controller层中，直接处理传来的文件（利用Spring MVC中的MultipartFile）。 服务层代码如下： public int updataHeader(int userId, String headerUrl) { return userMapper.updateHeader(userId, headerUrl); } 控制层代码如下： @RequestMapping(path = &quot;/upload&quot;, method = RequestMethod.POST) public String uploadHeader(MultipartFile headerImage, Model model) { if (headerImage == null) { model.addAttribute(&quot;error&quot;, &quot;您没有选择图片&quot;); return &quot;/site/setting&quot;; } //不能按照原始文件存储，所以需要生成一个随机名字，但是后缀不能变。 String fileName = headerImage.getOriginalFilename(); String suffix = fileName.substring(fileName.lastIndexOf(&quot;.&quot;)); if (StringUtils.isBlank(suffix)) { model.addAttribute(&quot;error&quot;, &quot;文件格式不正确&quot;); return &quot;/site/setting&quot;; } //生成随机文件名 fileName = CommunityUtil.generateUUID() + suffix; //确定文件路径 File dest = new File(uploadPath + &quot;/&quot; + fileName); try { headerImage.transferTo(dest); } catch (IOException e) { logger.error(&quot;上传文件失败&quot; + e.getMessage()); throw new RuntimeException(&quot;上传文件失败，服务器发生异常&quot;, e); } //更新当前头像途径（外部路径，非本地路径） //http://localhost:15213/community/user/header/***.png User user = hostHolder.getUser(); String headerUrl = domain + contextPath + &quot;/user/header/&quot; + fileName; userService.updataHeader(user.getId(), headerUrl); return &quot;redirect:/index&quot;; } @RequestMapping(path = &quot;/header/{filename}&quot;, method = RequestMethod.GET) public void getHeader(@PathVariable(&quot;filename&quot;) String filename, HttpServletResponse response) { //寻找服务器存放的路径 filename = uploadPath + &quot;/&quot; + filename; //解析文件后缀 String suffix = filename.substring(filename.lastIndexOf(&quot;.&quot;)); response.setContentType(&quot;image/jpg&quot;); try ( OutputStream os = response.getOutputStream(); FileInputStream fis = new FileInputStream(filename); ) { byte[] buffer = new byte[1024]; int b = 0; while (b != -1) { b = fis.read(buffer); os.write(buffer, 0, b); } } catch (IOException e) { logger.error(&quot;读取头像失败&quot; + e.getMessage()); } } 检查登录状态 用户可以通过路径访问http://localhost:15213/community/user/setting，这个链接仅仅是隐藏是不够安全的，服务端需要判断用户是否登录，来允许是否访问。 可以使用拦截器进行配置，也可以直接在方法上加注解。 自定义注解 使用元注解来定义我们自己的注解：@Target,@Retention,@Document,@Inherited 如何读取注解：Method.getDeclaredAnnotations(),Method.getAnnotation(Class annotationClass) 通过加注解来拦截指定路径 @Component public class LoginRequiredinteceptor implements HandlerInterceptor { private static final Logger logger = LoggerFactory.getLogger(LoginRequiredinteceptor.class); @Autowired private HostHolder hostHolder; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) { if (handler instanceof HandlerMethod) { HandlerMethod handlerMethod = (HandlerMethod) handler; Method method = handlerMethod.getMethod(); LoginRequired loginRequired = method.getAnnotation(LoginRequired.class); if (loginRequired != null &amp;&amp; hostHolder.getUser() == null) { try { response.sendRedirect(request.getContextPath() + &quot;/login&quot;); } catch (IOException e) { logger.error(&quot;重定向登录页面失败&quot; + e.getMessage()); } return false; } } return true; } } 在一些需要登录的请求前，加上loginrequired注解，就可以对未登录的请求，强制重定向到登录页面。" />
<link rel="canonical" href="https://github.com/tietietietie/tietietietie.github.io/chapter2.html" />
<meta property="og:url" content="https://github.com/tietietietie/tietietietie.github.io/chapter2.html" />
<meta property="og:site_name" content="tie’s blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-05-03T09:46:00+08:00" />
<script type="application/ld+json">
{"url":"https://github.com/tietietietie/tietietietie.github.io/chapter2.html","headline":"社区论坛：登录模块","dateModified":"2020-05-03T09:46:00+08:00","datePublished":"2020-05-03T09:46:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://github.com/tietietietie/tietietietie.github.io/chapter2.html"},"author":{"@type":"Person","name":"tie"},"description":"第二章：开发社区的登录模块 发送邮件 目的：服务器向用户发送邮件 邮箱设置 申请了一个新浪邮箱，设置STMP服务开启。 安装Spring mail的jar包 配置邮箱 #MailProperties spring.mail.host=smtp.sina.com spring.mail.port=465 spring.mail.username=nowcoderzt@sina.com spring.mail.password=0dba281fa3487473 spring.mail.protocol=smtps spring.mail.properties.mail.smtp.ssl.enable=true 创建一个MailSender类 @Component public class MailClient { private static final Logger logger = LoggerFactory.getLogger(MailClient.class); @Autowired private JavaMailSender mailSender; @Value(&quot;${spring.mail.username}&quot;) private String from; public void sendMail(String to, String subject, String context) { try { MimeMessage message = mailSender.createMimeMessage(); MimeMessageHelper helper = new MimeMessageHelper(message); helper.setFrom(from); helper.setTo(to); helper.setSubject(subject); helper.setText(context, true); mailSender.send(helper.getMimeMessage()); } catch (MessagingException e) { logger.error(&quot;发送邮件失败&quot; + e.getMessage()); } } } 测试邮件发送成功 Spring Email 模板引擎 发送的是Html格式的邮件 在测试类中，需要我们主动调用模板引擎，注入相应bean即可，代码如下： @Test public void testHtmlMail() { Context context = new Context(); context.setVariable(&quot;username&quot;, &quot;sunday&quot;); String content = templateEngine.process(&quot;/mail/demo&quot;, context); System.out.println(content); mailClient.sendMail(&quot;zhangtiezhangtie@outlook.com&quot;, &quot;HTML&quot;, content); } 其中，需要指定模板文件的地址，及模板所需要的参数，模板引擎会自动生成网页（一个字符串content），把这个字符串使用mailClient发送即可。 开发注册功能 web项目：按照请求拆解功能，比如注册功能： 1，打开注册网页 2，把注册的信息发送给服务器（点注册） 3，把激活邮件发送给邮箱 4，利用激活链接打开网页 每一次请求都是先开发数据访问层，在开发业务层，最后开发视图层（三层架构），但是每一次请求不一定要用到这三层 打开注册页面 使用thymeleaf实现一段标签的复用 把index的顶部标签复用给register.html，部分代码如下： //在Index的header部分添加th代码 &lt;div class=&quot;nk-container&quot;&gt; &lt;!-- 头部 --&gt; &lt;header class=&quot;bg-dark sticky-top&quot; th:fragment=&quot;header&quot;&gt; //在register部分添加如下th代码 &lt;div class=&quot;nk-container&quot;&gt; &lt;!-- 头部 --&gt; &lt;header class=&quot;bg-dark sticky-top&quot; th:replace=&quot;index::header&quot;&gt; 注意th的变量需要用@{}括起来，不然会报错 提交注册数据 首先导入“判断字符串/集合空值”的包 把我们网站的链接做成可配置的。在properties中设置网站域名（本机） 写两个工具，可以生成随机字符串，以及加密工具。 写一个service类，帮助我们把传来的用户数据存到数据库里面，具体包括：用户查重，加密密码，发送用户激活码，代码如下： public class UserService { @Autowired private UserMapper userMapper; @Autowired private MailClient mailClient; @Autowired private TemplateEngine templateEngine; @Value(&quot;${community.path.domain}&quot;) private String domain; @Value(&quot;${server.servlet.context-path}&quot;) private String contextPath; public User findUserById(int id) { return userMapper.selectById(id); } public Map&lt;String, Object&gt; register(User user) { Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); //空值处理 if (user == null) { throw new IllegalArgumentException(&quot;参数不能为空，谢谢&quot;); } if (StringUtils.isBlank(user.getUsername())) { map.put(&quot;usernameMsg&quot;, &quot;账号不能为空&quot;); return map; } if (StringUtils.isBlank(user.getPassword())) { map.put(&quot;passwordMsg&quot;, &quot;密码不能为空&quot;); return map; } if (StringUtils.isBlank(user.getEmail())) { map.put(&quot;emailMsg&quot;, &quot;邮箱不能为空&quot;); return map; } //验证账号 User findUser = userMapper.selectByName(user.getUsername()); if (findUser != null) { map.put(&quot;usernameMsg&quot;, &quot;该账号已存在&quot;); return map; } //验证邮箱 findUser = userMapper.selectByEmail(user.getEmail()); if (findUser != null) { map.put(&quot;emailMsg&quot;, &quot;该邮箱已存在&quot;); return map; } //注册用户 user.setSalt(CommunityUtil.generateUUID().substring(0, 5)); user.setPassword(CommunityUtil.md5(user.getPassword() + user.getSalt())); user.setType(0); user.setStatus(0); user.setActivationCode(CommunityUtil.generateUUID()); user.setHeaderUrl(String.format(&quot;http://images.nowcoder.com/head/%dt.png&quot;, new Random().nextInt(1000))); user.setCreatTime(new Date()); userMapper.insertUser(user); //发送激活邮件 Context context = new Context(); context.setVariable(&quot;email&quot;, user.getEmail()); //http://localhost:15213/communityactivation/101/code String url = domain + contextPath + &quot;/activation&quot; + user.getId() + &quot;/&quot; + user.getActivationCode(); context.setVariable(&quot;url&quot;, url); String content = templateEngine.process(&quot;/mail/activation&quot;, context); mailClient.sendMail(user.getEmail(), &quot;激活账号&quot;, content); } } 写一个controller类，来进行前后端交互 注册工程后，页面跳转到首页（第三方页面：operate-result.html，显示页面在多少秒后跳转（转到首页）） 在修改html时，需要给表单中的每一个获得的变量（账号名/邮箱等），指定参数名，和user中的参数名一一对应，这样spring mvc可以自动的创建user 回到错误页面，需要把这些错误信息还在register中显示，使用th:value = “@{//判断user是否为null}” 终于收到了激活邮箱。。 激活账号 有多种情况： 成功激活（第一次） 重复激活 无效的激活链接 会话管理 定义 http是无状态且有会话的。 无状态：请求之间是没有联系的（无差别对待）（用户没有办法进行连续的交互）（服务器无法记住浏览器的状态） 如何解决业务之间的联系：使用cookies来解决无状态，形成整体。 所以有会话是指：使得服务器和浏览器之间能有连续的交互。使得服务器能够记住浏览器。 cookies：由服务器发送给浏览器（在响应头），表明其身份，浏览器保存到本地，下次浏览器携带着cookies再次访问服务器时（在请求头），服务器能够认识这个浏览器。所以cookies是一个特殊的数据.(很小的数据，只有一对key:value)（能够得到浏览器的一些特征数据） 演示cookies 为访问此路径的浏览器生成cookie并放在response中，代码如下： //cookies演示 @RequestMapping(path = &quot;cookie/set&quot;, method = RequestMethod.GET) @ResponseBody public String setCookie(HttpServletResponse response) { //创建cookie Cookie cookie = new Cookie(&quot;code&quot;, CommunityUtil.generateUUID()); //设置cookie的生效范围（只有在哪些路径有效） cookie.setPath(&quot;/community/alpha&quot;); //设置cookie的生存时间（因为默认是存在内存里的，关掉浏览器就没了）(单位是秒） cookie.setMaxAge(60 * 10); response.addCookie(cookie); return &quot;set cookie&quot;; } 如何使用浏览器发来的cookie，如下： @RequestMapping(path = &quot;cookie/get&quot;, method = RequestMethod.GET) @ResponseBody public String getCookie(@CookieValue(&quot;code&quot;) String code) { System.out.println(code); return &quot;get cookie&quot;; } 优点：弥补http的无状态 缺点： 不安全，因为不知道浏览器所在系统的安全性 对流量/性能有影响 演示Session 另一种解决办法：session 用于在服务端的存储在客服端信息，优点是安全，缺点是造成了服务器的压力。 与cookie是有关系的 1，浏览器访问服务器，服务器创建一个对应的session对象，session依赖于cookie，自动创建了sessionID放在cookie中，发送给服务器 2，浏览器把存的cookie的sessionID，在下次请求中发送给服务器，从而服务器可以通过这个sessionID，找到与此浏览器对应的session对象 演示如何创建session，传入数据 //session示例 @RequestMapping(path = &quot;session/set&quot;, method = RequestMethod.GET) @ResponseBody public String setSession(HttpSession session) { //SpringMVC会自动地注入，只需要声明即可 session.setAttribute(&quot;id&quot;, 1); session.setAttribute(&quot;name&quot;, &quot;test&quot;); return &quot;set session&quot;; } 服务端获得对应地seesion参数值以及sessionID @RequestMapping(path = &quot;session/get&quot;, method = RequestMethod.GET) @ResponseBody public String getSession(HttpSession session) { System.out.println(session.getId()); System.out.println(session.getAttribute(&quot;name&quot;)); return &quot;get session&quot;; } 所以session也能解决会话问题。 Q&amp;A 在分布式部署中，为什么不使用session呢？ 因为服务器是分布式部署的（承载大流量），浏览器访问的是服务器代替nginx，nginx按照负载均衡的原则分配请求。在多次请求的过程中，可能会有多台服务器处理同一个浏览器的请求，但session只保存在一台服务器中。 解决策略： 粘性session：浏览器只访问一个服务器。（负载不均衡） 同步session：每个服务器存的session都相同（性能降低，增大服务器的耦合性） 共享session：单独有一台服务器来存储session，当服务器需要使用session时，往这台服务器申请（这台服务器威胁到了整个集群） 常用解决方案：一般数据都使用cookie而不是session，必要重要的数据存到数据库（集群）（非关系型数据库redis）里。 生成验证码 使用现成工具：kaptcha，在服务端内存中画出验证码，发送给浏览器。 导入kaptcha的jar包 编写Kaptcha的配置类 生成随机字符，生成图片 配置Kaptcha如下： @Configuration public class KaptchaConfig { @Bean public Producer kaptchaProducer() { Properties properties = new Properties(); properties.setProperty(&quot;kaptcha.image.width&quot;, &quot;100&quot;); properties.setProperty(&quot;kaptcha.image.height&quot;, &quot;40&quot;); properties.setProperty(&quot;kaptcha.textproducer.font.size&quot;, &quot;32&quot;); properties.setProperty(&quot;kaptcha.textproducer.font.color&quot;, &quot;0,0,0&quot;); properties.setProperty(&quot;kaptcha.textproducer.char.string&quot;, &quot;1234567890qwertyuiopsdfghklzxcnvbm&quot;); properties.setProperty(&quot;kaptcha.textproducer.char.length&quot;, &quot;4&quot;); properties.setProperty(&quot;kaptcha.noise,impl&quot;, &quot;com.google.code.kaptcha.impl.NoNoise&quot;); DefaultKaptcha kaptcha = new DefaultKaptcha(); Config config = new Config(properties); kaptcha.setConfig(config); return kaptcha; } 生成验证码，如下： @RequestMapping(path = &quot;/kaptcha&quot;, method = RequestMethod.GET) public void getKaptcha(HttpServletResponse response, HttpSession session) { //生成验证码 String text = kaptchaProducer.createText(); BufferedImage image = kaptchaProducer.createImage(text); //保存验证码到session session.setAttribute(&quot;kaptcha&quot;, text); //将图片输出到浏览器 response.setContentType(&quot;image/png&quot;); try { OutputStream os = response.getOutputStream(); ImageIO.write(image, &quot;png&quot;, os); } catch (IOException e) { logger.error(&quot;响应验证码失败&quot; + e.getMessage()); } login.html修改如下： &lt;div class=&quot;col-sm-4&quot;&gt; &lt;img th:src=&quot;@{/kaptcha}&quot; id=&quot;kaptcha&quot; style=&quot;width:100px;height:40px;&quot; class=&quot;mr-2&quot;/&gt; &lt;a href=&quot;javascript:refresh_kaptcha();&quot; class=&quot;font-size-12 align-bottom&quot;&gt;刷新验证码&lt;/a&gt; &lt;/div&gt; function refresh_kaptcha(){ var path = &quot;/community/kaptcha?p=&quot; + Math.random(); $(&quot;#kaptcha&quot;).attr(&quot;src&quot;,path); } 开发登录/退出功能 包含有如下业务： 登录 验证账号，密码，验证码 登录成功，生成登录凭证，发送给客户端 登录失败，跳转到登录页 退出 将登录凭证修改为失效 跳转至网站首页 登录凭证：一个key，包含有敏感数据，存在数据库（后面会存在redies），数据结构如下： 实现数据层 可以用注解来实现LoginTicketMapper接口（与之前在Mapper中写配置文件不同） 好处：方便，坏处：难以阅读，不够整洁 实现业务层 包括对用户名/密码的判断，已经验证是否存在该user，如果存在，需要返回一个唯一的ticket。 public Map&lt;String, Object&gt; login(String username, String password, int expiredSeconds) { Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); //空值判断 if (StringUtils.isBlank(username)) { map.put(&quot;usernameMsg&quot;, &quot;账号不能为空&quot;); return map; } if (StringUtils.isBlank(password)) { map.put(&quot;passwordMsg&quot;, &quot;密码不能为空&quot;); return map; } //验证账号 User user = userMapper.selectByName(username); if (user == null) { map.put(&quot;usernameMsg&quot;, &quot;账号不存在&quot;); return map; } if (user.getStatus() == 0) { map.put(&quot;usernameMsg&quot;, &quot;账号还没有激活&quot;); return map; } //验证密码 password = CommunityUtil.md5(password + user.getSalt()); if (!password.equals(user.getPassword())) { map.put(&quot;passwordMsg&quot;, &quot;密码错误&quot;); return map; } //生成登录凭证 LoginTicket loginTicket = new LoginTicket(); loginTicket.setUserId(user.getId()); loginTicket.setTicket(CommunityUtil.generateUUID()); loginTicket.setStatus(0); loginTicket.setExpired(new Date(System.currentTimeMillis() + expiredSeconds * 1000)); loginTicketMapper.insertLoginTicket(loginTicket); map.put(&quot;ticket&quot;, loginTicket.getTicket()); return map; } 实现处理层 注意进行post请求后，当服务器返回错误的username给login页面时，需要获得该错误的username，显示在网页上, 如何获得该username呢？可以直接在request中取值（因为username是在request中的），使用param.username，可在request中取值。 @RequestMapping(path = &quot;/login&quot;, method = RequestMethod.POST) public String login(String username, String password, String code, boolean rememberMe, Model model, HttpSession session, HttpServletResponse response) { //检查验证码 String kaptcha = (String) session.getAttribute(&quot;kaptcha&quot;); if (StringUtils.isBlank(kaptcha) || StringUtils.isBlank(code) || !kaptcha.equalsIgnoreCase(code)) { model.addAttribute(&quot;codeMsg&quot;, &quot;验证码错误&quot;); return &quot;/site/login&quot;; } //检查账号密码 int expiredSeconds = rememberMe ? REMEMBER_EXPIRED_SECONDS : DEFALUT_EXPIRED_SECONDS; Map&lt;String, Object&gt; map = userService.login(username, password, expiredSeconds); if (map.containsKey(&quot;ticket&quot;)) { Cookie cookie = new Cookie(&quot;ticket&quot;, (String) map.get(&quot;ticket&quot;)); cookie.setPath(contextPath); cookie.setMaxAge(expiredSeconds); response.addCookie(cookie); return &quot;redirect:/index&quot;; } else { model.addAttribute(&quot;usernameMsg&quot;, map.get(&quot;usernameMsg&quot;)); model.addAttribute(&quot;passwordMsg&quot;, map.get(&quot;passwordMsg&quot;)); return &quot;/site/login&quot;; } } @RequestMapping(path = &quot;/logout&quot;, method = RequestMethod.GET) public String logout(@CookieValue(&quot;ticket&quot;) String ticket) { userService.logout(ticket); //默认get请求 return &quot;redirect:/login&quot;; } 注意在index.html中把退出登录按钮的链接配置好。 显示登录信息 根据登录与否，显示登录信息 登录信息在头部，每一个页面都需要显示信息 拦截器：拦截请求，然后在请求中添加代码，能以很低的耦合度，解决通用问题。 拦截器示例 实现拦截器的接口 配置拦截器：指定拦截哪些请求 拦截器与controller没有直接关系，耦合度很低。 @Component public class Alphainteceptor implements HandlerInterceptor { private static final Logger logger = LoggerFactory.getLogger(Alphainteceptor.class); //在controller之前执行 //返回false，表示controller不往下执行 @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) { logger.debug(&quot;preHandler: &quot; + handler.toString()); return true; } //调用完controller之后执行 @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) { logger.debug(&quot;postHander:&quot; + handler.toString()); } //在模板引擎执行完之后执行 @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) { logger.debug(&quot;afterCompletion : &quot; + handler.toString()); } } 实现了拦截器的类之后，还需要对这个拦截器进行进行配置，代码如下： @Configuration public class WebMvcConfig implements WebMvcConfigurer { @Autowired private Alphainteceptor alphainteceptor; @Override public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(alphainteceptor) .excludePathPatterns(&quot;/**/*.css&quot;, &quot;/**/*.js&quot;, &quot;/**/*.png&quot;, &quot;/**/*.jpg&quot;, &quot;/**/*.jpeg&quot;) .addPathPatterns(&quot;/register&quot;, &quot;/login&quot;); } } 拦截器应用 包括以下步骤： 在请求之前先查到登录用户 在本次请求中持有用户数据 在模板视图上显示用户数据 在请求结束时清理用户数据 浏览器存着ticket放在cookie中，每次访问服务器，都会把这个ticket发送给服务器，从而得到当前用户是谁（login_ticket），得到user后，把它放在model中，最终html中则显示了用户信息。 把user信息放在ThreadLocal中，这样在整个请求过程中，user都一直存在，并能被访问。 实现拦截器： @Component public class LoginTicketiterceptor implements HandlerInterceptor { @Autowired private UserService userService; @Autowired private HostHolder hostHolder; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) { //从cookie中获取ticket String ticket = CookieUtil.getValue(request, &quot;ticket&quot;); if (ticket != null) { LoginTicket loginTicket = userService.findLoginTicket(ticket); if (loginTicket != null &amp;&amp; loginTicket.getStatus() == 0 &amp;&amp; loginTicket.getExpired().after(new Date())) { User user = userService.findUserById(loginTicket.getUserId()); //在本此请求中持有用户，考虑多线程并发，多线程隔离 hostHolder.setUser(user); } } return true; } @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) { User user = hostHolder.getUser(); if (user != null &amp;&amp; modelAndView != null) { modelAndView.addObject(&quot;loginUser&quot;, user); } } @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) { hostHolder.clear(); } } 实现HostHolder //持有用户信息，用于代替session对象，协程隔离 @Component public class HostHolder { private ThreadLocal&lt;User&gt; users = new ThreadLocal&lt;&gt;(); public void setUser(User user) { users.set(user); } public User getUser() { return users.get(); } public void clear() { users.remove(); } } 配置拦截器 @Configuration public class WebMvcConfig implements WebMvcConfigurer { @Autowired private Alphainteceptor alphainteceptor; @Autowired private LoginTicketiterceptor loginTicketiterceptor; @Override public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(alphainteceptor) .excludePathPatterns(&quot;/**/*.css&quot;, &quot;/**/*.js&quot;, &quot;/**/*.png&quot;, &quot;/**/*.jpg&quot;, &quot;/**/*.jpeg&quot;) .addPathPatterns(&quot;/register&quot;, &quot;/login&quot;); registry.addInterceptor(loginTicketiterceptor) .excludePathPatterns(&quot;/**/*.css&quot;, &quot;/**/*.js&quot;, &quot;/**/*.png&quot;, &quot;/**/*.jpg&quot;, &quot;/**/*.jpeg&quot;); } } 账号设置 开发步骤： 访问账号设置页面 上传头像（存在服务器上） 获取图像（页面能够在服务器上获取头像） 访问账号设置页面 新建UserController，并处理/user/setting的get方法，返回账号设置页面模板。 修改Index中的header，将对应账号设置按钮，设置相应路径，实现跳转。 上传文件 在service层中，需要修改用户头像的url 在controller层中，直接处理传来的文件（利用Spring MVC中的MultipartFile）。 服务层代码如下： public int updataHeader(int userId, String headerUrl) { return userMapper.updateHeader(userId, headerUrl); } 控制层代码如下： @RequestMapping(path = &quot;/upload&quot;, method = RequestMethod.POST) public String uploadHeader(MultipartFile headerImage, Model model) { if (headerImage == null) { model.addAttribute(&quot;error&quot;, &quot;您没有选择图片&quot;); return &quot;/site/setting&quot;; } //不能按照原始文件存储，所以需要生成一个随机名字，但是后缀不能变。 String fileName = headerImage.getOriginalFilename(); String suffix = fileName.substring(fileName.lastIndexOf(&quot;.&quot;)); if (StringUtils.isBlank(suffix)) { model.addAttribute(&quot;error&quot;, &quot;文件格式不正确&quot;); return &quot;/site/setting&quot;; } //生成随机文件名 fileName = CommunityUtil.generateUUID() + suffix; //确定文件路径 File dest = new File(uploadPath + &quot;/&quot; + fileName); try { headerImage.transferTo(dest); } catch (IOException e) { logger.error(&quot;上传文件失败&quot; + e.getMessage()); throw new RuntimeException(&quot;上传文件失败，服务器发生异常&quot;, e); } //更新当前头像途径（外部路径，非本地路径） //http://localhost:15213/community/user/header/***.png User user = hostHolder.getUser(); String headerUrl = domain + contextPath + &quot;/user/header/&quot; + fileName; userService.updataHeader(user.getId(), headerUrl); return &quot;redirect:/index&quot;; } @RequestMapping(path = &quot;/header/{filename}&quot;, method = RequestMethod.GET) public void getHeader(@PathVariable(&quot;filename&quot;) String filename, HttpServletResponse response) { //寻找服务器存放的路径 filename = uploadPath + &quot;/&quot; + filename; //解析文件后缀 String suffix = filename.substring(filename.lastIndexOf(&quot;.&quot;)); response.setContentType(&quot;image/jpg&quot;); try ( OutputStream os = response.getOutputStream(); FileInputStream fis = new FileInputStream(filename); ) { byte[] buffer = new byte[1024]; int b = 0; while (b != -1) { b = fis.read(buffer); os.write(buffer, 0, b); } } catch (IOException e) { logger.error(&quot;读取头像失败&quot; + e.getMessage()); } } 检查登录状态 用户可以通过路径访问http://localhost:15213/community/user/setting，这个链接仅仅是隐藏是不够安全的，服务端需要判断用户是否登录，来允许是否访问。 可以使用拦截器进行配置，也可以直接在方法上加注解。 自定义注解 使用元注解来定义我们自己的注解：@Target,@Retention,@Document,@Inherited 如何读取注解：Method.getDeclaredAnnotations(),Method.getAnnotation(Class annotationClass) 通过加注解来拦截指定路径 @Component public class LoginRequiredinteceptor implements HandlerInterceptor { private static final Logger logger = LoggerFactory.getLogger(LoginRequiredinteceptor.class); @Autowired private HostHolder hostHolder; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) { if (handler instanceof HandlerMethod) { HandlerMethod handlerMethod = (HandlerMethod) handler; Method method = handlerMethod.getMethod(); LoginRequired loginRequired = method.getAnnotation(LoginRequired.class); if (loginRequired != null &amp;&amp; hostHolder.getUser() == null) { try { response.sendRedirect(request.getContextPath() + &quot;/login&quot;); } catch (IOException e) { logger.error(&quot;重定向登录页面失败&quot; + e.getMessage()); } return false; } } return true; } } 在一些需要登录的请求前，加上loginrequired注解，就可以对未登录的请求，强制重定向到登录页面。","@type":"BlogPosting","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

  <link type="application/atom+xml" rel="alternate" href="https://github.com/tietietietie/tietietietie.github.io/feed.xml" title="tie's blog" />

  <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
  <link rel="stylesheet" href="/assets/css/main.css" />
</head><body a="auto">
    <main class="page-content" aria-label="Content">
      <div class="w">
        <a href="/">..</a>

<article>
  <p class="post-meta">
    <time datetime="2020-05-03 09:46:00 +0800">2020-05-03</time>
  </p>
  
  <h1>社区论坛：登录模块</h1>

  <h1 id="第二章开发社区的登录模块">第二章：开发社区的登录模块</h1>

<h2 id="发送邮件">发送邮件</h2>

<p>目的：服务器向用户发送邮件</p>

<h3 id="邮箱设置">邮箱设置</h3>

<ul>
  <li>申请了一个新浪邮箱，设置STMP服务开启。</li>
  <li>安装Spring mail的jar包</li>
  <li>配置邮箱</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#MailProperties
spring.mail.host=smtp.sina.com
spring.mail.port=465
spring.mail.username=nowcoderzt@sina.com
spring.mail.password=0dba281fa3487473
spring.mail.protocol=smtps
spring.mail.properties.mail.smtp.ssl.enable=true
</code></pre></div></div>

<ul>
  <li>创建一个MailSender类</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Component</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MailClient</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">Logger</span> <span class="n">logger</span> <span class="o">=</span> <span class="nc">LoggerFactory</span><span class="o">.</span><span class="na">getLogger</span><span class="o">(</span><span class="nc">MailClient</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>

    <span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="nc">JavaMailSender</span> <span class="n">mailSender</span><span class="o">;</span>

    <span class="nd">@Value</span><span class="o">(</span><span class="s">"${spring.mail.username}"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">from</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">sendMail</span><span class="o">(</span><span class="nc">String</span> <span class="n">to</span><span class="o">,</span> <span class="nc">String</span> <span class="n">subject</span><span class="o">,</span> <span class="nc">String</span> <span class="n">context</span><span class="o">)</span> <span class="o">{</span>

        <span class="k">try</span> <span class="o">{</span>
            <span class="nc">MimeMessage</span> <span class="n">message</span> <span class="o">=</span> <span class="n">mailSender</span><span class="o">.</span><span class="na">createMimeMessage</span><span class="o">();</span>
            <span class="nc">MimeMessageHelper</span> <span class="n">helper</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MimeMessageHelper</span><span class="o">(</span><span class="n">message</span><span class="o">);</span>
            <span class="n">helper</span><span class="o">.</span><span class="na">setFrom</span><span class="o">(</span><span class="n">from</span><span class="o">);</span>
            <span class="n">helper</span><span class="o">.</span><span class="na">setTo</span><span class="o">(</span><span class="n">to</span><span class="o">);</span>
            <span class="n">helper</span><span class="o">.</span><span class="na">setSubject</span><span class="o">(</span><span class="n">subject</span><span class="o">);</span>
            <span class="n">helper</span><span class="o">.</span><span class="na">setText</span><span class="o">(</span><span class="n">context</span><span class="o">,</span> <span class="kc">true</span><span class="o">);</span>
            <span class="n">mailSender</span><span class="o">.</span><span class="na">send</span><span class="o">(</span><span class="n">helper</span><span class="o">.</span><span class="na">getMimeMessage</span><span class="o">());</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">MessagingException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">logger</span><span class="o">.</span><span class="na">error</span><span class="o">(</span><span class="s">"发送邮件失败"</span> <span class="o">+</span> <span class="n">e</span><span class="o">.</span><span class="na">getMessage</span><span class="o">());</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>测试邮件发送成功</p>

<h3 id="spring-email">Spring Email</h3>

<h3 id="模板引擎">模板引擎</h3>

<p>发送的是Html格式的邮件</p>

<p>在测试类中，需要我们主动调用模板引擎，注入相应bean即可，代码如下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="nd">@Test</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">testHtmlMail</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">Context</span> <span class="n">context</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Context</span><span class="o">();</span>
        <span class="n">context</span><span class="o">.</span><span class="na">setVariable</span><span class="o">(</span><span class="s">"username"</span><span class="o">,</span> <span class="s">"sunday"</span><span class="o">);</span>
        <span class="nc">String</span> <span class="n">content</span> <span class="o">=</span> <span class="n">templateEngine</span><span class="o">.</span><span class="na">process</span><span class="o">(</span><span class="s">"/mail/demo"</span><span class="o">,</span> <span class="n">context</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">content</span><span class="o">);</span>
        <span class="n">mailClient</span><span class="o">.</span><span class="na">sendMail</span><span class="o">(</span><span class="s">"zhangtiezhangtie@outlook.com"</span><span class="o">,</span> <span class="s">"HTML"</span><span class="o">,</span> <span class="n">content</span><span class="o">);</span>
    <span class="o">}</span>
</code></pre></div></div>

<p>其中，需要指定模板文件的地址，及模板所需要的参数，模板引擎会自动生成网页（一个字符串content），把这个字符串使用mailClient发送即可。</p>

<h2 id="开发注册功能">开发注册功能</h2>

<p>web项目：按照请求拆解功能，比如注册功能：</p>

<p>1，打开注册网页</p>

<p>2，把注册的信息发送给服务器（点注册）</p>

<p>3，把激活邮件发送给邮箱</p>

<p>4，利用激活链接打开网页</p>

<p>每一次请求都是先开发数据访问层，在开发业务层，最后开发视图层（三层架构），但是每一次请求不一定要用到这三层</p>

<h3 id="打开注册页面">打开注册页面</h3>

<ul>
  <li>使用thymeleaf实现一段标签的复用</li>
</ul>

<p>把index的顶部标签复用给register.html，部分代码如下：</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//在Index的header部分添加th代码
<span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">"nk-container"</span><span class="nt">&gt;</span>
    <span class="c">&lt;!-- 头部 --&gt;</span>
    <span class="nt">&lt;header</span> <span class="na">class=</span><span class="s">"bg-dark sticky-top"</span> <span class="na">th:fragment=</span><span class="s">"header"</span><span class="nt">&gt;</span>
//在register部分添加如下th代码
<span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">"nk-container"</span><span class="nt">&gt;</span>
    <span class="c">&lt;!-- 头部 --&gt;</span>
    <span class="nt">&lt;header</span> <span class="na">class=</span><span class="s">"bg-dark sticky-top"</span> <span class="na">th:replace=</span><span class="s">"index::header"</span><span class="nt">&gt;</span>
</code></pre></div></div>

<p>注意th的变量需要用@{}括起来，不然会报错</p>

<h3 id="提交注册数据">提交注册数据</h3>

<p>首先导入“判断字符串/集合空值”的包</p>

<p>把我们网站的链接做成可配置的。在properties中设置网站域名（本机）</p>

<p>写两个工具，可以生成随机字符串，以及加密工具。</p>

<p>写一个service类，帮助我们把传来的用户数据存到数据库里面，具体包括：用户查重，加密密码，发送用户激活码，代码如下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">UserService</span> <span class="o">{</span>
    <span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="nc">UserMapper</span> <span class="n">userMapper</span><span class="o">;</span>

    <span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="nc">MailClient</span> <span class="n">mailClient</span><span class="o">;</span>

    <span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="nc">TemplateEngine</span> <span class="n">templateEngine</span><span class="o">;</span>

    <span class="nd">@Value</span><span class="o">(</span><span class="s">"${community.path.domain}"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">domain</span><span class="o">;</span>

    <span class="nd">@Value</span><span class="o">(</span><span class="s">"${server.servlet.context-path}"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">contextPath</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nc">User</span> <span class="nf">findUserById</span><span class="o">(</span><span class="kt">int</span> <span class="n">id</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">userMapper</span><span class="o">.</span><span class="na">selectById</span><span class="o">(</span><span class="n">id</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Object</span><span class="o">&gt;</span> <span class="nf">register</span><span class="o">(</span><span class="nc">User</span> <span class="n">user</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Object</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="c1">//空值处理</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">user</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">(</span><span class="s">"参数不能为空，谢谢"</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="nc">StringUtils</span><span class="o">.</span><span class="na">isBlank</span><span class="o">(</span><span class="n">user</span><span class="o">.</span><span class="na">getUsername</span><span class="o">()))</span> <span class="o">{</span>
            <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"usernameMsg"</span><span class="o">,</span> <span class="s">"账号不能为空"</span><span class="o">);</span>
            <span class="k">return</span> <span class="n">map</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="nc">StringUtils</span><span class="o">.</span><span class="na">isBlank</span><span class="o">(</span><span class="n">user</span><span class="o">.</span><span class="na">getPassword</span><span class="o">()))</span> <span class="o">{</span>
            <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"passwordMsg"</span><span class="o">,</span> <span class="s">"密码不能为空"</span><span class="o">);</span>
            <span class="k">return</span> <span class="n">map</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="nc">StringUtils</span><span class="o">.</span><span class="na">isBlank</span><span class="o">(</span><span class="n">user</span><span class="o">.</span><span class="na">getEmail</span><span class="o">()))</span> <span class="o">{</span>
            <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"emailMsg"</span><span class="o">,</span> <span class="s">"邮箱不能为空"</span><span class="o">);</span>
            <span class="k">return</span> <span class="n">map</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">//验证账号</span>
        <span class="nc">User</span> <span class="n">findUser</span> <span class="o">=</span> <span class="n">userMapper</span><span class="o">.</span><span class="na">selectByName</span><span class="o">(</span><span class="n">user</span><span class="o">.</span><span class="na">getUsername</span><span class="o">());</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">findUser</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"usernameMsg"</span><span class="o">,</span> <span class="s">"该账号已存在"</span><span class="o">);</span>
            <span class="k">return</span> <span class="n">map</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">//验证邮箱</span>
        <span class="n">findUser</span> <span class="o">=</span> <span class="n">userMapper</span><span class="o">.</span><span class="na">selectByEmail</span><span class="o">(</span><span class="n">user</span><span class="o">.</span><span class="na">getEmail</span><span class="o">());</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">findUser</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"emailMsg"</span><span class="o">,</span> <span class="s">"该邮箱已存在"</span><span class="o">);</span>
            <span class="k">return</span> <span class="n">map</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">//注册用户</span>
        <span class="n">user</span><span class="o">.</span><span class="na">setSalt</span><span class="o">(</span><span class="nc">CommunityUtil</span><span class="o">.</span><span class="na">generateUUID</span><span class="o">().</span><span class="na">substring</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">5</span><span class="o">));</span>
        <span class="n">user</span><span class="o">.</span><span class="na">setPassword</span><span class="o">(</span><span class="nc">CommunityUtil</span><span class="o">.</span><span class="na">md5</span><span class="o">(</span><span class="n">user</span><span class="o">.</span><span class="na">getPassword</span><span class="o">()</span> <span class="o">+</span> <span class="n">user</span><span class="o">.</span><span class="na">getSalt</span><span class="o">()));</span>
        <span class="n">user</span><span class="o">.</span><span class="na">setType</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
        <span class="n">user</span><span class="o">.</span><span class="na">setStatus</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
        <span class="n">user</span><span class="o">.</span><span class="na">setActivationCode</span><span class="o">(</span><span class="nc">CommunityUtil</span><span class="o">.</span><span class="na">generateUUID</span><span class="o">());</span>
        <span class="n">user</span><span class="o">.</span><span class="na">setHeaderUrl</span><span class="o">(</span><span class="nc">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"http://images.nowcoder.com/head/%dt.png"</span><span class="o">,</span> <span class="k">new</span> <span class="nc">Random</span><span class="o">().</span><span class="na">nextInt</span><span class="o">(</span><span class="mi">1000</span><span class="o">)));</span>
        <span class="n">user</span><span class="o">.</span><span class="na">setCreatTime</span><span class="o">(</span><span class="k">new</span> <span class="nc">Date</span><span class="o">());</span>
        <span class="n">userMapper</span><span class="o">.</span><span class="na">insertUser</span><span class="o">(</span><span class="n">user</span><span class="o">);</span>

        <span class="c1">//发送激活邮件</span>
        <span class="nc">Context</span> <span class="n">context</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Context</span><span class="o">();</span>
        <span class="n">context</span><span class="o">.</span><span class="na">setVariable</span><span class="o">(</span><span class="s">"email"</span><span class="o">,</span> <span class="n">user</span><span class="o">.</span><span class="na">getEmail</span><span class="o">());</span>
        <span class="c1">//http://localhost:15213/communityactivation/101/code</span>
        <span class="nc">String</span> <span class="n">url</span> <span class="o">=</span> <span class="n">domain</span> <span class="o">+</span> <span class="n">contextPath</span> <span class="o">+</span> <span class="s">"/activation"</span> <span class="o">+</span> <span class="n">user</span><span class="o">.</span><span class="na">getId</span><span class="o">()</span> <span class="o">+</span> <span class="s">"/"</span> <span class="o">+</span> <span class="n">user</span><span class="o">.</span><span class="na">getActivationCode</span><span class="o">();</span>
        <span class="n">context</span><span class="o">.</span><span class="na">setVariable</span><span class="o">(</span><span class="s">"url"</span><span class="o">,</span> <span class="n">url</span><span class="o">);</span>
        <span class="nc">String</span> <span class="n">content</span> <span class="o">=</span> <span class="n">templateEngine</span><span class="o">.</span><span class="na">process</span><span class="o">(</span><span class="s">"/mail/activation"</span><span class="o">,</span> <span class="n">context</span><span class="o">);</span>
        <span class="n">mailClient</span><span class="o">.</span><span class="na">sendMail</span><span class="o">(</span><span class="n">user</span><span class="o">.</span><span class="na">getEmail</span><span class="o">(),</span> <span class="s">"激活账号"</span><span class="o">,</span> <span class="n">content</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>写一个controller类，来进行前后端交互</p>

<ul>
  <li>注册工程后，页面跳转到首页（第三方页面：operate-result.html，显示页面在多少秒后跳转（转到首页））</li>
  <li>在修改html时，需要给表单中的每一个获得的变量（账号名/邮箱等），指定参数名，和user中的参数名一一对应，这样spring mvc可以自动的创建user</li>
  <li>回到错误页面，需要把这些错误信息还在register中显示，使用th:value = “@{//判断user是否为null}”</li>
</ul>

<p>终于收到了激活邮箱。。</p>

<p><a href="https://imgchr.com/i/yhon74"><img src="https://s3.ax1x.com/2021/02/19/yhon74.png" alt="yhon74.png" /></a></p>

<h3 id="激活账号">激活账号</h3>

<p>有多种情况：</p>

<ul>
  <li>成功激活（第一次）</li>
  <li>重复激活</li>
  <li>无效的激活链接</li>
</ul>

<p><a href="https://imgchr.com/i/yhomBF"><img src="https://s3.ax1x.com/2021/02/19/yhomBF.png" alt="yhomBF.png" /></a></p>

<h2 id="会话管理">会话管理</h2>

<h3 id="定义">定义</h3>

<p>http是无状态且有会话的。</p>

<p>无状态：请求之间是没有联系的（无差别对待）（用户没有办法进行连续的交互）（服务器无法记住浏览器的状态）</p>

<p>如何解决业务之间的联系：使用cookies来解决无状态，形成整体。</p>

<p>所以有会话是指：使得服务器和浏览器之间能有连续的交互。使得服务器能够<strong>记住</strong>浏览器。</p>

<p>cookies：由服务器发送给浏览器（在响应头），表明其身份，浏览器保存到本地，下次浏览器携带着cookies再次访问服务器时（在请求头），服务器能够<strong>认识</strong>这个浏览器。所以cookies是一个特殊的数据.(很小的数据，只有一对key:value)（能够得到浏览器的一些特征数据）</p>

<h3 id="演示cookies">演示cookies</h3>

<p>为访问此路径的浏览器生成cookie并放在response中，代码如下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">//cookies演示</span>
    <span class="nd">@RequestMapping</span><span class="o">(</span><span class="n">path</span> <span class="o">=</span> <span class="s">"cookie/set"</span><span class="o">,</span> <span class="n">method</span> <span class="o">=</span> <span class="nc">RequestMethod</span><span class="o">.</span><span class="na">GET</span><span class="o">)</span>
    <span class="nd">@ResponseBody</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">setCookie</span><span class="o">(</span><span class="nc">HttpServletResponse</span> <span class="n">response</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//创建cookie</span>
        <span class="nc">Cookie</span> <span class="n">cookie</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Cookie</span><span class="o">(</span><span class="s">"code"</span><span class="o">,</span> <span class="nc">CommunityUtil</span><span class="o">.</span><span class="na">generateUUID</span><span class="o">());</span>
        <span class="c1">//设置cookie的生效范围（只有在哪些路径有效）</span>
        <span class="n">cookie</span><span class="o">.</span><span class="na">setPath</span><span class="o">(</span><span class="s">"/community/alpha"</span><span class="o">);</span>
        <span class="c1">//设置cookie的生存时间（因为默认是存在内存里的，关掉浏览器就没了）(单位是秒）</span>
        <span class="n">cookie</span><span class="o">.</span><span class="na">setMaxAge</span><span class="o">(</span><span class="mi">60</span> <span class="o">*</span> <span class="mi">10</span><span class="o">);</span>
        <span class="n">response</span><span class="o">.</span><span class="na">addCookie</span><span class="o">(</span><span class="n">cookie</span><span class="o">);</span>
        <span class="k">return</span> <span class="s">"set cookie"</span><span class="o">;</span>
    <span class="o">}</span>
</code></pre></div></div>

<p>如何使用浏览器发来的cookie，如下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="nd">@RequestMapping</span><span class="o">(</span><span class="n">path</span> <span class="o">=</span> <span class="s">"cookie/get"</span><span class="o">,</span> <span class="n">method</span> <span class="o">=</span> <span class="nc">RequestMethod</span><span class="o">.</span><span class="na">GET</span><span class="o">)</span>
    <span class="nd">@ResponseBody</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getCookie</span><span class="o">(</span><span class="nd">@CookieValue</span><span class="o">(</span><span class="s">"code"</span><span class="o">)</span> <span class="nc">String</span> <span class="n">code</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">code</span><span class="o">);</span>
        <span class="k">return</span> <span class="s">"get cookie"</span><span class="o">;</span>
    <span class="o">}</span>
</code></pre></div></div>

<p>优点：弥补http的无状态</p>

<p>缺点：</p>

<ul>
  <li>不安全，因为不知道浏览器所在系统的安全性</li>
  <li>对流量/性能有影响</li>
</ul>

<h3 id="演示session">演示Session</h3>

<p>另一种解决办法：session</p>

<ul>
  <li>用于在服务端的存储在客服端信息，优点是安全，缺点是造成了服务器的压力。</li>
  <li>与cookie是有关系的</li>
</ul>

<p>1，浏览器访问服务器，服务器创建一个对应的session对象，session依赖于cookie，自动创建了sessionID放在cookie中，发送给服务器</p>

<p>2，浏览器把存的cookie的sessionID，在下次请求中发送给服务器，从而服务器可以通过这个sessionID，找到与此浏览器对应的session对象</p>

<p>演示如何创建session，传入数据</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">//session示例</span>
    <span class="nd">@RequestMapping</span><span class="o">(</span><span class="n">path</span> <span class="o">=</span> <span class="s">"session/set"</span><span class="o">,</span> <span class="n">method</span> <span class="o">=</span> <span class="nc">RequestMethod</span><span class="o">.</span><span class="na">GET</span><span class="o">)</span>
    <span class="nd">@ResponseBody</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">setSession</span><span class="o">(</span><span class="nc">HttpSession</span> <span class="n">session</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//SpringMVC会自动地注入，只需要声明即可</span>
        <span class="n">session</span><span class="o">.</span><span class="na">setAttribute</span><span class="o">(</span><span class="s">"id"</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span>
        <span class="n">session</span><span class="o">.</span><span class="na">setAttribute</span><span class="o">(</span><span class="s">"name"</span><span class="o">,</span> <span class="s">"test"</span><span class="o">);</span>
        <span class="k">return</span> <span class="s">"set session"</span><span class="o">;</span>
    <span class="o">}</span>
</code></pre></div></div>

<p><a href="https://imgchr.com/i/yhoenU"><img src="https://s3.ax1x.com/2021/02/19/yhoenU.png" alt="yhoenU.png" /></a></p>

<p>服务端获得对应地seesion参数值以及sessionID</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="nd">@RequestMapping</span><span class="o">(</span><span class="n">path</span> <span class="o">=</span> <span class="s">"session/get"</span><span class="o">,</span> <span class="n">method</span> <span class="o">=</span> <span class="nc">RequestMethod</span><span class="o">.</span><span class="na">GET</span><span class="o">)</span>
    <span class="nd">@ResponseBody</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getSession</span><span class="o">(</span><span class="nc">HttpSession</span> <span class="n">session</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">session</span><span class="o">.</span><span class="na">getId</span><span class="o">());</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">session</span><span class="o">.</span><span class="na">getAttribute</span><span class="o">(</span><span class="s">"name"</span><span class="o">));</span>
        <span class="k">return</span> <span class="s">"get session"</span><span class="o">;</span>
    <span class="o">}</span>
</code></pre></div></div>

<p>所以session也能解决会话问题。</p>

<p>Q&amp;A</p>

<ul>
  <li>在分布式部署中，为什么不使用session呢？</li>
</ul>

<p>因为服务器是分布式部署的（承载大流量），浏览器访问的是服务器代替nginx，nginx按照负载均衡的原则分配请求。在多次请求的过程中，可能会有多台服务器处理同一个浏览器的请求，但session只保存在一台服务器中。</p>

<p>解决策略：</p>

<p>粘性session：浏览器只访问一个服务器。（负载不均衡）</p>

<p>同步session：每个服务器存的session都相同（性能降低，增大服务器的耦合性）</p>

<p>共享session：单独有一台服务器来存储session，当服务器需要使用session时，往这台服务器申请（这台服务器威胁到了整个集群）</p>

<p>常用解决方案：一般数据都使用cookie而不是session，必要重要的数据存到数据库（集群）（非关系型数据库redis）里。</p>

<h2 id="生成验证码">生成验证码</h2>

<p>使用现成工具：kaptcha，在服务端内存中画出验证码，发送给浏览器。</p>

<ol>
  <li>导入kaptcha的jar包</li>
  <li>编写Kaptcha的配置类</li>
  <li>生成随机字符，生成图片</li>
</ol>

<p>配置Kaptcha如下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Configuration</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">KaptchaConfig</span> <span class="o">{</span>
    <span class="nd">@Bean</span>
    <span class="kd">public</span> <span class="nc">Producer</span> <span class="nf">kaptchaProducer</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">Properties</span> <span class="n">properties</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Properties</span><span class="o">();</span>
        <span class="n">properties</span><span class="o">.</span><span class="na">setProperty</span><span class="o">(</span><span class="s">"kaptcha.image.width"</span><span class="o">,</span> <span class="s">"100"</span><span class="o">);</span>
        <span class="n">properties</span><span class="o">.</span><span class="na">setProperty</span><span class="o">(</span><span class="s">"kaptcha.image.height"</span><span class="o">,</span> <span class="s">"40"</span><span class="o">);</span>
        <span class="n">properties</span><span class="o">.</span><span class="na">setProperty</span><span class="o">(</span><span class="s">"kaptcha.textproducer.font.size"</span><span class="o">,</span> <span class="s">"32"</span><span class="o">);</span>
        <span class="n">properties</span><span class="o">.</span><span class="na">setProperty</span><span class="o">(</span><span class="s">"kaptcha.textproducer.font.color"</span><span class="o">,</span> <span class="s">"0,0,0"</span><span class="o">);</span>
        <span class="n">properties</span><span class="o">.</span><span class="na">setProperty</span><span class="o">(</span><span class="s">"kaptcha.textproducer.char.string"</span><span class="o">,</span> <span class="s">"1234567890qwertyuiopsdfghklzxcnvbm"</span><span class="o">);</span>
        <span class="n">properties</span><span class="o">.</span><span class="na">setProperty</span><span class="o">(</span><span class="s">"kaptcha.textproducer.char.length"</span><span class="o">,</span> <span class="s">"4"</span><span class="o">);</span>
        <span class="n">properties</span><span class="o">.</span><span class="na">setProperty</span><span class="o">(</span><span class="s">"kaptcha.noise,impl"</span><span class="o">,</span> <span class="s">"com.google.code.kaptcha.impl.NoNoise"</span><span class="o">);</span>
        <span class="nc">DefaultKaptcha</span> <span class="n">kaptcha</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">DefaultKaptcha</span><span class="o">();</span>
        <span class="nc">Config</span> <span class="n">config</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Config</span><span class="o">(</span><span class="n">properties</span><span class="o">);</span>
        <span class="n">kaptcha</span><span class="o">.</span><span class="na">setConfig</span><span class="o">(</span><span class="n">config</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">kaptcha</span><span class="o">;</span>
    <span class="o">}</span>
</code></pre></div></div>

<p>生成验证码，如下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@RequestMapping</span><span class="o">(</span><span class="n">path</span> <span class="o">=</span> <span class="s">"/kaptcha"</span><span class="o">,</span> <span class="n">method</span> <span class="o">=</span> <span class="nc">RequestMethod</span><span class="o">.</span><span class="na">GET</span><span class="o">)</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">getKaptcha</span><span class="o">(</span><span class="nc">HttpServletResponse</span> <span class="n">response</span><span class="o">,</span> <span class="nc">HttpSession</span> <span class="n">session</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//生成验证码</span>
        <span class="nc">String</span> <span class="n">text</span> <span class="o">=</span> <span class="n">kaptchaProducer</span><span class="o">.</span><span class="na">createText</span><span class="o">();</span>
        <span class="nc">BufferedImage</span> <span class="n">image</span> <span class="o">=</span> <span class="n">kaptchaProducer</span><span class="o">.</span><span class="na">createImage</span><span class="o">(</span><span class="n">text</span><span class="o">);</span>

        <span class="c1">//保存验证码到session</span>
        <span class="n">session</span><span class="o">.</span><span class="na">setAttribute</span><span class="o">(</span><span class="s">"kaptcha"</span><span class="o">,</span> <span class="n">text</span><span class="o">);</span>

        <span class="c1">//将图片输出到浏览器</span>
        <span class="n">response</span><span class="o">.</span><span class="na">setContentType</span><span class="o">(</span><span class="s">"image/png"</span><span class="o">);</span>

        <span class="k">try</span> <span class="o">{</span>
            <span class="nc">OutputStream</span> <span class="n">os</span> <span class="o">=</span> <span class="n">response</span><span class="o">.</span><span class="na">getOutputStream</span><span class="o">();</span>
            <span class="nc">ImageIO</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">image</span><span class="o">,</span> <span class="s">"png"</span><span class="o">,</span> <span class="n">os</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">logger</span><span class="o">.</span><span class="na">error</span><span class="o">(</span><span class="s">"响应验证码失败"</span> <span class="o">+</span> <span class="n">e</span><span class="o">.</span><span class="na">getMessage</span><span class="o">());</span>
        <span class="o">}</span>
</code></pre></div></div>

<p>login.html修改如下：</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">"col-sm-4"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;img</span> <span class="na">th:src=</span><span class="s">"@{/kaptcha}"</span> <span class="na">id=</span><span class="s">"kaptcha"</span> <span class="na">style=</span><span class="s">"width:100px;height:40px;"</span> <span class="na">class=</span><span class="s">"mr-2"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;a</span> <span class="na">href=</span><span class="s">"javascript:refresh_kaptcha();"</span> <span class="na">class=</span><span class="s">"font-size-12 align-bottom"</span><span class="nt">&gt;</span>刷新验证码<span class="nt">&lt;/a&gt;</span>
<span class="nt">&lt;/div&gt;</span>
</code></pre></div></div>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">refresh_kaptcha</span><span class="p">(){</span>
    <span class="kd">var</span> <span class="nx">path</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">/community/kaptcha?p=</span><span class="dl">"</span> <span class="o">+</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">random</span><span class="p">();</span>
    <span class="nx">$</span><span class="p">(</span><span class="dl">"</span><span class="s2">#kaptcha</span><span class="dl">"</span><span class="p">).</span><span class="nx">attr</span><span class="p">(</span><span class="dl">"</span><span class="s2">src</span><span class="dl">"</span><span class="p">,</span><span class="nx">path</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="开发登录退出功能">开发登录/退出功能</h2>

<p>包含有如下业务：</p>

<ul>
  <li>登录
    <ul>
      <li>验证账号，密码，验证码</li>
      <li>登录成功，生成登录凭证，发送给客户端</li>
      <li>登录失败，跳转到登录页</li>
    </ul>
  </li>
  <li>退出
    <ul>
      <li>将登录凭证修改为失效</li>
      <li>跳转至网站首页</li>
    </ul>
  </li>
</ul>

<p>登录凭证：一个key，包含有敏感数据，存在数据库（后面会存在redies），数据结构如下：</p>

<p><a href="https://imgchr.com/i/yhoKAJ"><img src="https://s3.ax1x.com/2021/02/19/yhoKAJ.png" alt="yhoKAJ.png" /></a></p>

<h3 id="实现数据层">实现数据层</h3>

<p>可以用注解来实现LoginTicketMapper接口（与之前在Mapper中写配置文件不同）</p>

<p>好处：方便，坏处：难以阅读，不够整洁</p>

<h3 id="实现业务层">实现业务层</h3>

<p>包括对用户名/密码的判断，已经验证是否存在该user，如果存在，需要返回一个唯一的ticket。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">public</span> <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Object</span><span class="o">&gt;</span> <span class="nf">login</span><span class="o">(</span><span class="nc">String</span> <span class="n">username</span><span class="o">,</span> <span class="nc">String</span> <span class="n">password</span><span class="o">,</span> <span class="kt">int</span> <span class="n">expiredSeconds</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Object</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>

        <span class="c1">//空值判断</span>
        <span class="k">if</span> <span class="o">(</span><span class="nc">StringUtils</span><span class="o">.</span><span class="na">isBlank</span><span class="o">(</span><span class="n">username</span><span class="o">))</span> <span class="o">{</span>
            <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"usernameMsg"</span><span class="o">,</span> <span class="s">"账号不能为空"</span><span class="o">);</span>
            <span class="k">return</span> <span class="n">map</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="nc">StringUtils</span><span class="o">.</span><span class="na">isBlank</span><span class="o">(</span><span class="n">password</span><span class="o">))</span> <span class="o">{</span>
            <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"passwordMsg"</span><span class="o">,</span> <span class="s">"密码不能为空"</span><span class="o">);</span>
            <span class="k">return</span> <span class="n">map</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">//验证账号</span>
        <span class="nc">User</span> <span class="n">user</span> <span class="o">=</span> <span class="n">userMapper</span><span class="o">.</span><span class="na">selectByName</span><span class="o">(</span><span class="n">username</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">user</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"usernameMsg"</span><span class="o">,</span> <span class="s">"账号不存在"</span><span class="o">);</span>
            <span class="k">return</span> <span class="n">map</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">user</span><span class="o">.</span><span class="na">getStatus</span><span class="o">()</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"usernameMsg"</span><span class="o">,</span> <span class="s">"账号还没有激活"</span><span class="o">);</span>
            <span class="k">return</span> <span class="n">map</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">//验证密码</span>
        <span class="n">password</span> <span class="o">=</span> <span class="nc">CommunityUtil</span><span class="o">.</span><span class="na">md5</span><span class="o">(</span><span class="n">password</span> <span class="o">+</span> <span class="n">user</span><span class="o">.</span><span class="na">getSalt</span><span class="o">());</span>
        <span class="k">if</span> <span class="o">(!</span><span class="n">password</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">user</span><span class="o">.</span><span class="na">getPassword</span><span class="o">()))</span> <span class="o">{</span>
            <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"passwordMsg"</span><span class="o">,</span> <span class="s">"密码错误"</span><span class="o">);</span>
            <span class="k">return</span> <span class="n">map</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">//生成登录凭证</span>
        <span class="nc">LoginTicket</span> <span class="n">loginTicket</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LoginTicket</span><span class="o">();</span>
        <span class="n">loginTicket</span><span class="o">.</span><span class="na">setUserId</span><span class="o">(</span><span class="n">user</span><span class="o">.</span><span class="na">getId</span><span class="o">());</span>
        <span class="n">loginTicket</span><span class="o">.</span><span class="na">setTicket</span><span class="o">(</span><span class="nc">CommunityUtil</span><span class="o">.</span><span class="na">generateUUID</span><span class="o">());</span>
        <span class="n">loginTicket</span><span class="o">.</span><span class="na">setStatus</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
        <span class="n">loginTicket</span><span class="o">.</span><span class="na">setExpired</span><span class="o">(</span><span class="k">new</span> <span class="nc">Date</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">()</span> <span class="o">+</span> <span class="n">expiredSeconds</span> <span class="o">*</span> <span class="mi">1000</span><span class="o">));</span>
        <span class="n">loginTicketMapper</span><span class="o">.</span><span class="na">insertLoginTicket</span><span class="o">(</span><span class="n">loginTicket</span><span class="o">);</span>
        <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"ticket"</span><span class="o">,</span> <span class="n">loginTicket</span><span class="o">.</span><span class="na">getTicket</span><span class="o">());</span>
        <span class="k">return</span> <span class="n">map</span><span class="o">;</span>
    <span class="o">}</span>
</code></pre></div></div>

<h3 id="实现处理层">实现处理层</h3>

<p>注意进行post请求后，当服务器返回错误的username给login页面时，需要获得该错误的username，显示在网页上, 如何获得该username呢？可以直接在request中取值（因为username是在request中的），使用param.username，可在request中取值。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="nd">@RequestMapping</span><span class="o">(</span><span class="n">path</span> <span class="o">=</span> <span class="s">"/login"</span><span class="o">,</span> <span class="n">method</span> <span class="o">=</span> <span class="nc">RequestMethod</span><span class="o">.</span><span class="na">POST</span><span class="o">)</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">login</span><span class="o">(</span><span class="nc">String</span> <span class="n">username</span><span class="o">,</span> <span class="nc">String</span> <span class="n">password</span><span class="o">,</span> <span class="nc">String</span> <span class="n">code</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">rememberMe</span><span class="o">,</span>
                        <span class="nc">Model</span> <span class="n">model</span><span class="o">,</span> <span class="nc">HttpSession</span> <span class="n">session</span><span class="o">,</span> <span class="nc">HttpServletResponse</span> <span class="n">response</span><span class="o">)</span> <span class="o">{</span>

        <span class="c1">//检查验证码</span>
        <span class="nc">String</span> <span class="n">kaptcha</span> <span class="o">=</span> <span class="o">(</span><span class="nc">String</span><span class="o">)</span> <span class="n">session</span><span class="o">.</span><span class="na">getAttribute</span><span class="o">(</span><span class="s">"kaptcha"</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="nc">StringUtils</span><span class="o">.</span><span class="na">isBlank</span><span class="o">(</span><span class="n">kaptcha</span><span class="o">)</span> <span class="o">||</span> <span class="nc">StringUtils</span><span class="o">.</span><span class="na">isBlank</span><span class="o">(</span><span class="n">code</span><span class="o">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">kaptcha</span><span class="o">.</span><span class="na">equalsIgnoreCase</span><span class="o">(</span><span class="n">code</span><span class="o">))</span> <span class="o">{</span>
            <span class="n">model</span><span class="o">.</span><span class="na">addAttribute</span><span class="o">(</span><span class="s">"codeMsg"</span><span class="o">,</span> <span class="s">"验证码错误"</span><span class="o">);</span>
            <span class="k">return</span> <span class="s">"/site/login"</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">//检查账号密码</span>
        <span class="kt">int</span> <span class="n">expiredSeconds</span> <span class="o">=</span> <span class="n">rememberMe</span> <span class="o">?</span> <span class="no">REMEMBER_EXPIRED_SECONDS</span> <span class="o">:</span> <span class="no">DEFALUT_EXPIRED_SECONDS</span><span class="o">;</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Object</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="n">userService</span><span class="o">.</span><span class="na">login</span><span class="o">(</span><span class="n">username</span><span class="o">,</span> <span class="n">password</span><span class="o">,</span> <span class="n">expiredSeconds</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="s">"ticket"</span><span class="o">))</span> <span class="o">{</span>
            <span class="nc">Cookie</span> <span class="n">cookie</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Cookie</span><span class="o">(</span><span class="s">"ticket"</span><span class="o">,</span> <span class="o">(</span><span class="nc">String</span><span class="o">)</span> <span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"ticket"</span><span class="o">));</span>
            <span class="n">cookie</span><span class="o">.</span><span class="na">setPath</span><span class="o">(</span><span class="n">contextPath</span><span class="o">);</span>
            <span class="n">cookie</span><span class="o">.</span><span class="na">setMaxAge</span><span class="o">(</span><span class="n">expiredSeconds</span><span class="o">);</span>
            <span class="n">response</span><span class="o">.</span><span class="na">addCookie</span><span class="o">(</span><span class="n">cookie</span><span class="o">);</span>
            <span class="k">return</span> <span class="s">"redirect:/index"</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="n">model</span><span class="o">.</span><span class="na">addAttribute</span><span class="o">(</span><span class="s">"usernameMsg"</span><span class="o">,</span> <span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"usernameMsg"</span><span class="o">));</span>
            <span class="n">model</span><span class="o">.</span><span class="na">addAttribute</span><span class="o">(</span><span class="s">"passwordMsg"</span><span class="o">,</span> <span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"passwordMsg"</span><span class="o">));</span>
            <span class="k">return</span> <span class="s">"/site/login"</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="nd">@RequestMapping</span><span class="o">(</span><span class="n">path</span> <span class="o">=</span> <span class="s">"/logout"</span><span class="o">,</span> <span class="n">method</span> <span class="o">=</span> <span class="nc">RequestMethod</span><span class="o">.</span><span class="na">GET</span><span class="o">)</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">logout</span><span class="o">(</span><span class="nd">@CookieValue</span><span class="o">(</span><span class="s">"ticket"</span><span class="o">)</span> <span class="nc">String</span> <span class="n">ticket</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">userService</span><span class="o">.</span><span class="na">logout</span><span class="o">(</span><span class="n">ticket</span><span class="o">);</span>
        <span class="c1">//默认get请求</span>
        <span class="k">return</span> <span class="s">"redirect:/login"</span><span class="o">;</span>
    <span class="o">}</span>
</code></pre></div></div>

<p>注意在index.html中把退出登录按钮的链接配置好。</p>

<h2 id="显示登录信息">显示登录信息</h2>

<ul>
  <li>根据登录与否，显示登录信息</li>
  <li>登录信息在头部，每一个页面都需要显示信息</li>
</ul>

<p>拦截器：拦截请求，然后在请求中添加代码，能以很低的耦合度，解决通用问题。</p>

<h3 id="拦截器示例">拦截器示例</h3>

<ul>
  <li>实现拦截器的接口</li>
  <li>配置拦截器：指定拦截哪些请求</li>
</ul>

<p>拦截器与controller没有直接关系，耦合度很低。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Component</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Alphainteceptor</span> <span class="kd">implements</span> <span class="nc">HandlerInterceptor</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">Logger</span> <span class="n">logger</span> <span class="o">=</span> <span class="nc">LoggerFactory</span><span class="o">.</span><span class="na">getLogger</span><span class="o">(</span><span class="nc">Alphainteceptor</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>

    <span class="c1">//在controller之前执行</span>
    <span class="c1">//返回false，表示controller不往下执行</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">preHandle</span><span class="o">(</span><span class="nc">HttpServletRequest</span> <span class="n">request</span><span class="o">,</span> <span class="nc">HttpServletResponse</span> <span class="n">response</span><span class="o">,</span> <span class="nc">Object</span> <span class="n">handler</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">logger</span><span class="o">.</span><span class="na">debug</span><span class="o">(</span><span class="s">"preHandler: "</span> <span class="o">+</span> <span class="n">handler</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">//调用完controller之后执行</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">postHandle</span><span class="o">(</span><span class="nc">HttpServletRequest</span> <span class="n">request</span><span class="o">,</span> <span class="nc">HttpServletResponse</span> <span class="n">response</span><span class="o">,</span> <span class="nc">Object</span> <span class="n">handler</span><span class="o">,</span> <span class="nc">ModelAndView</span> <span class="n">modelAndView</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">logger</span><span class="o">.</span><span class="na">debug</span><span class="o">(</span><span class="s">"postHander:"</span> <span class="o">+</span> <span class="n">handler</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
    <span class="o">}</span>

    <span class="c1">//在模板引擎执行完之后执行</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">afterCompletion</span><span class="o">(</span><span class="nc">HttpServletRequest</span> <span class="n">request</span><span class="o">,</span> <span class="nc">HttpServletResponse</span> <span class="n">response</span><span class="o">,</span> <span class="nc">Object</span> <span class="n">handler</span><span class="o">,</span> <span class="nc">Exception</span> <span class="n">ex</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">logger</span><span class="o">.</span><span class="na">debug</span><span class="o">(</span><span class="s">"afterCompletion : "</span> <span class="o">+</span> <span class="n">handler</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>实现了拦截器的类之后，还需要对这个拦截器进行进行配置，代码如下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Configuration</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">WebMvcConfig</span> <span class="kd">implements</span> <span class="nc">WebMvcConfigurer</span> <span class="o">{</span>
    <span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="nc">Alphainteceptor</span> <span class="n">alphainteceptor</span><span class="o">;</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">addInterceptors</span><span class="o">(</span><span class="nc">InterceptorRegistry</span> <span class="n">registry</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">registry</span><span class="o">.</span><span class="na">addInterceptor</span><span class="o">(</span><span class="n">alphainteceptor</span><span class="o">)</span>
                <span class="o">.</span><span class="na">excludePathPatterns</span><span class="o">(</span><span class="s">"/**/*.css"</span><span class="o">,</span> <span class="s">"/**/*.js"</span><span class="o">,</span> <span class="s">"/**/*.png"</span><span class="o">,</span> <span class="s">"/**/*.jpg"</span><span class="o">,</span> <span class="s">"/**/*.jpeg"</span><span class="o">)</span>
                <span class="o">.</span><span class="na">addPathPatterns</span><span class="o">(</span><span class="s">"/register"</span><span class="o">,</span> <span class="s">"/login"</span><span class="o">);</span>
        
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="拦截器应用">拦截器应用</h3>

<p>包括以下步骤：</p>

<ol>
  <li>在请求之前先查到登录用户</li>
  <li>在本次请求中持有用户数据</li>
  <li>在模板视图上显示用户数据</li>
  <li>在请求结束时清理用户数据</li>
</ol>

<p>浏览器存着ticket放在cookie中，每次访问服务器，都会把这个ticket发送给服务器，从而得到当前用户是谁（login_ticket），得到user后，把它放在model中，最终html中则显示了用户信息。</p>

<p>把user信息放在ThreadLocal中，这样在整个请求过程中，user都一直存在，并能被访问。</p>

<p>实现拦截器：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Component</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">LoginTicketiterceptor</span> <span class="kd">implements</span> <span class="nc">HandlerInterceptor</span> <span class="o">{</span>

    <span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="nc">UserService</span> <span class="n">userService</span><span class="o">;</span>
    <span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="nc">HostHolder</span> <span class="n">hostHolder</span><span class="o">;</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">preHandle</span><span class="o">(</span><span class="nc">HttpServletRequest</span> <span class="n">request</span><span class="o">,</span> <span class="nc">HttpServletResponse</span> <span class="n">response</span><span class="o">,</span> <span class="nc">Object</span> <span class="n">handler</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//从cookie中获取ticket</span>
        <span class="nc">String</span> <span class="n">ticket</span> <span class="o">=</span> <span class="nc">CookieUtil</span><span class="o">.</span><span class="na">getValue</span><span class="o">(</span><span class="n">request</span><span class="o">,</span> <span class="s">"ticket"</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">ticket</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">LoginTicket</span> <span class="n">loginTicket</span> <span class="o">=</span> <span class="n">userService</span><span class="o">.</span><span class="na">findLoginTicket</span><span class="o">(</span><span class="n">ticket</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">loginTicket</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">loginTicket</span><span class="o">.</span><span class="na">getStatus</span><span class="o">()</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">loginTicket</span><span class="o">.</span><span class="na">getExpired</span><span class="o">().</span><span class="na">after</span><span class="o">(</span><span class="k">new</span> <span class="nc">Date</span><span class="o">()))</span> <span class="o">{</span>
                <span class="nc">User</span> <span class="n">user</span> <span class="o">=</span> <span class="n">userService</span><span class="o">.</span><span class="na">findUserById</span><span class="o">(</span><span class="n">loginTicket</span><span class="o">.</span><span class="na">getUserId</span><span class="o">());</span>
                <span class="c1">//在本此请求中持有用户，考虑多线程并发，多线程隔离</span>
                <span class="n">hostHolder</span><span class="o">.</span><span class="na">setUser</span><span class="o">(</span><span class="n">user</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">postHandle</span><span class="o">(</span><span class="nc">HttpServletRequest</span> <span class="n">request</span><span class="o">,</span> <span class="nc">HttpServletResponse</span> <span class="n">response</span><span class="o">,</span> <span class="nc">Object</span> <span class="n">handler</span><span class="o">,</span> <span class="nc">ModelAndView</span> <span class="n">modelAndView</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">User</span> <span class="n">user</span> <span class="o">=</span> <span class="n">hostHolder</span><span class="o">.</span><span class="na">getUser</span><span class="o">();</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">user</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">modelAndView</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">modelAndView</span><span class="o">.</span><span class="na">addObject</span><span class="o">(</span><span class="s">"loginUser"</span><span class="o">,</span> <span class="n">user</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">afterCompletion</span><span class="o">(</span><span class="nc">HttpServletRequest</span> <span class="n">request</span><span class="o">,</span> <span class="nc">HttpServletResponse</span> <span class="n">response</span><span class="o">,</span> <span class="nc">Object</span> <span class="n">handler</span><span class="o">,</span> <span class="nc">Exception</span> <span class="n">ex</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">hostHolder</span><span class="o">.</span><span class="na">clear</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>实现HostHolder</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//持有用户信息，用于代替session对象，协程隔离</span>
<span class="nd">@Component</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">HostHolder</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">ThreadLocal</span><span class="o">&lt;</span><span class="nc">User</span><span class="o">&gt;</span> <span class="n">users</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ThreadLocal</span><span class="o">&lt;&gt;();</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setUser</span><span class="o">(</span><span class="nc">User</span> <span class="n">user</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">users</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">user</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">User</span> <span class="nf">getUser</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">users</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">clear</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">users</span><span class="o">.</span><span class="na">remove</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>配置拦截器</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Configuration</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">WebMvcConfig</span> <span class="kd">implements</span> <span class="nc">WebMvcConfigurer</span> <span class="o">{</span>
    <span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="nc">Alphainteceptor</span> <span class="n">alphainteceptor</span><span class="o">;</span>
    <span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="nc">LoginTicketiterceptor</span> <span class="n">loginTicketiterceptor</span><span class="o">;</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">addInterceptors</span><span class="o">(</span><span class="nc">InterceptorRegistry</span> <span class="n">registry</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">registry</span><span class="o">.</span><span class="na">addInterceptor</span><span class="o">(</span><span class="n">alphainteceptor</span><span class="o">)</span>
                <span class="o">.</span><span class="na">excludePathPatterns</span><span class="o">(</span><span class="s">"/**/*.css"</span><span class="o">,</span> <span class="s">"/**/*.js"</span><span class="o">,</span> <span class="s">"/**/*.png"</span><span class="o">,</span> <span class="s">"/**/*.jpg"</span><span class="o">,</span> <span class="s">"/**/*.jpeg"</span><span class="o">)</span>
                <span class="o">.</span><span class="na">addPathPatterns</span><span class="o">(</span><span class="s">"/register"</span><span class="o">,</span> <span class="s">"/login"</span><span class="o">);</span>

        <span class="n">registry</span><span class="o">.</span><span class="na">addInterceptor</span><span class="o">(</span><span class="n">loginTicketiterceptor</span><span class="o">)</span>
                <span class="o">.</span><span class="na">excludePathPatterns</span><span class="o">(</span><span class="s">"/**/*.css"</span><span class="o">,</span> <span class="s">"/**/*.js"</span><span class="o">,</span> <span class="s">"/**/*.png"</span><span class="o">,</span> <span class="s">"/**/*.jpg"</span><span class="o">,</span> <span class="s">"/**/*.jpeg"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="账号设置">账号设置</h2>

<p>开发步骤：</p>

<ol>
  <li>访问账号设置页面</li>
  <li>上传头像（存在服务器上）</li>
  <li>获取图像（页面能够在服务器上获取头像）</li>
</ol>

<h3 id="访问账号设置页面">访问账号设置页面</h3>

<p>新建UserController，并处理/user/setting的get方法，返回账号设置页面模板。</p>

<p>修改Index中的header，将对应账号设置按钮，设置相应路径，实现跳转。</p>

<h3 id="上传文件">上传文件</h3>

<p>在service层中，需要修改用户头像的url</p>

<p>在controller层中，直接处理传来的文件（利用Spring MVC中的MultipartFile）。</p>

<p>服务层代码如下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">int</span> <span class="nf">updataHeader</span><span class="o">(</span><span class="kt">int</span> <span class="n">userId</span><span class="o">,</span> <span class="nc">String</span> <span class="n">headerUrl</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">userMapper</span><span class="o">.</span><span class="na">updateHeader</span><span class="o">(</span><span class="n">userId</span><span class="o">,</span> <span class="n">headerUrl</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>控制层代码如下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@RequestMapping</span><span class="o">(</span><span class="n">path</span> <span class="o">=</span> <span class="s">"/upload"</span><span class="o">,</span> <span class="n">method</span> <span class="o">=</span> <span class="nc">RequestMethod</span><span class="o">.</span><span class="na">POST</span><span class="o">)</span>
<span class="kd">public</span> <span class="nc">String</span> <span class="nf">uploadHeader</span><span class="o">(</span><span class="nc">MultipartFile</span> <span class="n">headerImage</span><span class="o">,</span> <span class="nc">Model</span> <span class="n">model</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">headerImage</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">model</span><span class="o">.</span><span class="na">addAttribute</span><span class="o">(</span><span class="s">"error"</span><span class="o">,</span> <span class="s">"您没有选择图片"</span><span class="o">);</span>
        <span class="k">return</span> <span class="s">"/site/setting"</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="c1">//不能按照原始文件存储，所以需要生成一个随机名字，但是后缀不能变。</span>
    <span class="nc">String</span> <span class="n">fileName</span> <span class="o">=</span> <span class="n">headerImage</span><span class="o">.</span><span class="na">getOriginalFilename</span><span class="o">();</span>
    <span class="nc">String</span> <span class="n">suffix</span> <span class="o">=</span> <span class="n">fileName</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="n">fileName</span><span class="o">.</span><span class="na">lastIndexOf</span><span class="o">(</span><span class="s">"."</span><span class="o">));</span>
    <span class="k">if</span> <span class="o">(</span><span class="nc">StringUtils</span><span class="o">.</span><span class="na">isBlank</span><span class="o">(</span><span class="n">suffix</span><span class="o">))</span> <span class="o">{</span>
        <span class="n">model</span><span class="o">.</span><span class="na">addAttribute</span><span class="o">(</span><span class="s">"error"</span><span class="o">,</span> <span class="s">"文件格式不正确"</span><span class="o">);</span>
        <span class="k">return</span> <span class="s">"/site/setting"</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="c1">//生成随机文件名</span>
    <span class="n">fileName</span> <span class="o">=</span> <span class="nc">CommunityUtil</span><span class="o">.</span><span class="na">generateUUID</span><span class="o">()</span> <span class="o">+</span> <span class="n">suffix</span><span class="o">;</span>
    <span class="c1">//确定文件路径</span>
    <span class="nc">File</span> <span class="n">dest</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="n">uploadPath</span> <span class="o">+</span> <span class="s">"/"</span> <span class="o">+</span> <span class="n">fileName</span><span class="o">);</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="n">headerImage</span><span class="o">.</span><span class="na">transferTo</span><span class="o">(</span><span class="n">dest</span><span class="o">);</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">logger</span><span class="o">.</span><span class="na">error</span><span class="o">(</span><span class="s">"上传文件失败"</span> <span class="o">+</span> <span class="n">e</span><span class="o">.</span><span class="na">getMessage</span><span class="o">());</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="s">"上传文件失败，服务器发生异常"</span><span class="o">,</span> <span class="n">e</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="c1">//更新当前头像途径（外部路径，非本地路径）</span>
    <span class="c1">//http://localhost:15213/community/user/header/***.png</span>
    <span class="nc">User</span> <span class="n">user</span> <span class="o">=</span> <span class="n">hostHolder</span><span class="o">.</span><span class="na">getUser</span><span class="o">();</span>
    <span class="nc">String</span> <span class="n">headerUrl</span> <span class="o">=</span> <span class="n">domain</span> <span class="o">+</span> <span class="n">contextPath</span> <span class="o">+</span> <span class="s">"/user/header/"</span> <span class="o">+</span> <span class="n">fileName</span><span class="o">;</span>
    <span class="n">userService</span><span class="o">.</span><span class="na">updataHeader</span><span class="o">(</span><span class="n">user</span><span class="o">.</span><span class="na">getId</span><span class="o">(),</span> <span class="n">headerUrl</span><span class="o">);</span>
    <span class="k">return</span> <span class="s">"redirect:/index"</span><span class="o">;</span>

<span class="o">}</span>

<span class="nd">@RequestMapping</span><span class="o">(</span><span class="n">path</span> <span class="o">=</span> <span class="s">"/header/{filename}"</span><span class="o">,</span> <span class="n">method</span> <span class="o">=</span> <span class="nc">RequestMethod</span><span class="o">.</span><span class="na">GET</span><span class="o">)</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">getHeader</span><span class="o">(</span><span class="nd">@PathVariable</span><span class="o">(</span><span class="s">"filename"</span><span class="o">)</span> <span class="nc">String</span> <span class="n">filename</span><span class="o">,</span> <span class="nc">HttpServletResponse</span> <span class="n">response</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">//寻找服务器存放的路径</span>
    <span class="n">filename</span> <span class="o">=</span> <span class="n">uploadPath</span> <span class="o">+</span> <span class="s">"/"</span> <span class="o">+</span> <span class="n">filename</span><span class="o">;</span>
    <span class="c1">//解析文件后缀</span>
    <span class="nc">String</span> <span class="n">suffix</span> <span class="o">=</span> <span class="n">filename</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="n">filename</span><span class="o">.</span><span class="na">lastIndexOf</span><span class="o">(</span><span class="s">"."</span><span class="o">));</span>
    <span class="n">response</span><span class="o">.</span><span class="na">setContentType</span><span class="o">(</span><span class="s">"image/jpg"</span><span class="o">);</span>
    <span class="k">try</span> <span class="o">(</span>
        <span class="nc">OutputStream</span> <span class="n">os</span> <span class="o">=</span> <span class="n">response</span><span class="o">.</span><span class="na">getOutputStream</span><span class="o">();</span>
        <span class="nc">FileInputStream</span> <span class="n">fis</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="n">filename</span><span class="o">);</span>
    <span class="o">)</span> <span class="o">{</span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">buffer</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="o">[</span><span class="mi">1024</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">b</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">fis</span><span class="o">.</span><span class="na">read</span><span class="o">(</span><span class="n">buffer</span><span class="o">);</span>
            <span class="n">os</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">buffer</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">b</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">logger</span><span class="o">.</span><span class="na">error</span><span class="o">(</span><span class="s">"读取头像失败"</span> <span class="o">+</span> <span class="n">e</span><span class="o">.</span><span class="na">getMessage</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="检查登录状态">检查登录状态</h2>

<p>用户可以通过路径访问http://localhost:15213/community/user/setting，这个链接仅仅是隐藏是不够安全的，服务端需要判断用户是否登录，来允许是否访问。</p>

<p>可以使用拦截器进行配置，也可以直接在方法上加注解。</p>

<h3 id="自定义注解">自定义注解</h3>

<p>使用元注解来定义我们自己的注解：@Target,@Retention,@Document,@Inherited</p>

<p>如何读取注解：Method.getDeclaredAnnotations(),Method.getAnnotation(Class<T> annotationClass)</T></p>

<h3 id="通过加注解来拦截指定路径">通过加注解来拦截指定路径</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Component</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">LoginRequiredinteceptor</span> <span class="kd">implements</span> <span class="nc">HandlerInterceptor</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">Logger</span> <span class="n">logger</span> <span class="o">=</span> <span class="nc">LoggerFactory</span><span class="o">.</span><span class="na">getLogger</span><span class="o">(</span><span class="nc">LoginRequiredinteceptor</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
    <span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="nc">HostHolder</span> <span class="n">hostHolder</span><span class="o">;</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">preHandle</span><span class="o">(</span><span class="nc">HttpServletRequest</span> <span class="n">request</span><span class="o">,</span> <span class="nc">HttpServletResponse</span> <span class="n">response</span><span class="o">,</span> <span class="nc">Object</span> <span class="n">handler</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">handler</span> <span class="k">instanceof</span> <span class="nc">HandlerMethod</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">HandlerMethod</span> <span class="n">handlerMethod</span> <span class="o">=</span> <span class="o">(</span><span class="nc">HandlerMethod</span><span class="o">)</span> <span class="n">handler</span><span class="o">;</span>
            <span class="nc">Method</span> <span class="n">method</span> <span class="o">=</span> <span class="n">handlerMethod</span><span class="o">.</span><span class="na">getMethod</span><span class="o">();</span>
            <span class="nc">LoginRequired</span> <span class="n">loginRequired</span> <span class="o">=</span> <span class="n">method</span><span class="o">.</span><span class="na">getAnnotation</span><span class="o">(</span><span class="nc">LoginRequired</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">loginRequired</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">hostHolder</span><span class="o">.</span><span class="na">getUser</span><span class="o">()</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">try</span> <span class="o">{</span>
                    <span class="n">response</span><span class="o">.</span><span class="na">sendRedirect</span><span class="o">(</span><span class="n">request</span><span class="o">.</span><span class="na">getContextPath</span><span class="o">()</span> <span class="o">+</span> <span class="s">"/login"</span><span class="o">);</span>
                <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">logger</span><span class="o">.</span><span class="na">error</span><span class="o">(</span><span class="s">"重定向登录页面失败"</span> <span class="o">+</span> <span class="n">e</span><span class="o">.</span><span class="na">getMessage</span><span class="o">());</span>
                <span class="o">}</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>在一些需要登录的请求前，加上loginrequired注解，就可以对未登录的请求，强制重定向到登录页面。</p>

</article>
      </div>
    </main>

    
  </body>
</html>