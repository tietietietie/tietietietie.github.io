<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <title>CSAPP：同步-基础</title>

  <!-- Begin Jekyll SEO tag v2.6.1 -->
<meta name="generator" content="Jekyll v3.8.7" />
<meta property="og:title" content="CSAPP：同步-基础" />
<meta name="author" content="tie" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="同步-基础 线程中的共享数据 如何判断数据被多线程共享呢？并不是全局变量就是共享的，线程栈内的变量是私有的。需要具体分析。 共享数据定义：如果多个线程都对某个变量X的实例有引用，则称这个变量是共享变量。 从以下三个方面来理解共享变量。 线程内存模型 理论上多线程在一个进程内运行，每个线程都有自己的stack,线程ID等，都共享code,heap等。 但实际操作中，除了寄存器中的数据是严格的私有和保护起来的，线程中栈内的数据是可以被其他线程读写的。 如下图所示：传入线程的全局指针ptr指向的是主线程中的栈内局部变量msgs，此时peer线程可以通过此全局指针去访问主线程栈内数据。 变量映射到内存 包括：全局变量，本地自动变量，本地静态变量。 全局变量：定义在函数体之外，运行时只含有一个实例，放在data区域，每个线程都可以引用。 本地自动变量：每一个线程都有自己的栈来存储所有的本地自动变量实例，就算是他们执行的是相同的线程实例。 本地静态变量：定义在函数体内，也只包含有一个实例，只能在函数体内使用，不同线程都使用这个函数时，进行数据共享（都可以读写这个唯一的实例）。 分析共享变量 分析下面代码中，哪些代码是线程私有，哪些代码是共享的。 可以发现：ptr和static变量只有一个实例，但是thread routine被两个线程使用，里面的局部自动变量每个线程栈都有一份实例。 共享变量：ptr,msgs,cnt。 共享数据引起的同步问题 错误代码分析 可以发现：nither虽然是主线程的局部变量，但是因为不会被修改，所以可以引用传递。 cnt是volatile的，也会是不回被存在寄存器中，每次操作都要在内存中取出和存回去。 可以发现，cnt++,需要进行三个步骤，但是由于线程交替，可能会出现以下错误： 其中：线程1在Load cnt并加一后，还没来得及存储，cnt被线程2load,此时cnt为0，最后线程1和线程2都是在0的基础上加1，cnt被写了两次1。 进度图 利用进度图，在n维笛卡尔坐标系中画出轨迹线，来表示多线程指令的执行顺序。如下图为双线程的进度图，图中有不安全区域，轨迹进入此区域，会发生错误。 L1,U1,S1等涉及对共享变量cnt的操作，两线程不能对其同时操作，构成不安全区域。 如果一条路径线没有经过不安全区域，则说明是安全的。 使用信号量解决同步问题 为了确保不产生不安全的路径线，可以使用信号量。 定义 信号量：非负整数，全局变量，由P(s),V(s)操作。 P(s)：如果s非零，则减少1并立即返回（system call）（原子性），立即进行当前线程的下一条指令。 如果s为零，则暂停当前线程，知道某一线程执行了V(s)，使得s变成非零，此时当前线程p(s)重启，将s减少1，返回被暂停的线程继续操作。 V(s)：s加1，如果有悬停的线程，则通过某种算法，选择一条悬停线程重启。 所有信号量总是大于等于1的。 接口 包括init：设置信号量，wait()：减少信号量，post()：增加信号量。 互斥 使用二元信号量（互斥锁）（mutex)，调用P(mutex)：锁定。V(mutex)：解锁。 引入信号锁，对cnt进行锁定，从而只能有一个线程操作cnt，不回被打断。 会比较慢，因为一直system call。 进度图变成如下： 可以发现由于信号量不能是-1，线程路径不会经过不安全区域，从而保证了路径的安全。" />
<meta property="og:description" content="同步-基础 线程中的共享数据 如何判断数据被多线程共享呢？并不是全局变量就是共享的，线程栈内的变量是私有的。需要具体分析。 共享数据定义：如果多个线程都对某个变量X的实例有引用，则称这个变量是共享变量。 从以下三个方面来理解共享变量。 线程内存模型 理论上多线程在一个进程内运行，每个线程都有自己的stack,线程ID等，都共享code,heap等。 但实际操作中，除了寄存器中的数据是严格的私有和保护起来的，线程中栈内的数据是可以被其他线程读写的。 如下图所示：传入线程的全局指针ptr指向的是主线程中的栈内局部变量msgs，此时peer线程可以通过此全局指针去访问主线程栈内数据。 变量映射到内存 包括：全局变量，本地自动变量，本地静态变量。 全局变量：定义在函数体之外，运行时只含有一个实例，放在data区域，每个线程都可以引用。 本地自动变量：每一个线程都有自己的栈来存储所有的本地自动变量实例，就算是他们执行的是相同的线程实例。 本地静态变量：定义在函数体内，也只包含有一个实例，只能在函数体内使用，不同线程都使用这个函数时，进行数据共享（都可以读写这个唯一的实例）。 分析共享变量 分析下面代码中，哪些代码是线程私有，哪些代码是共享的。 可以发现：ptr和static变量只有一个实例，但是thread routine被两个线程使用，里面的局部自动变量每个线程栈都有一份实例。 共享变量：ptr,msgs,cnt。 共享数据引起的同步问题 错误代码分析 可以发现：nither虽然是主线程的局部变量，但是因为不会被修改，所以可以引用传递。 cnt是volatile的，也会是不回被存在寄存器中，每次操作都要在内存中取出和存回去。 可以发现，cnt++,需要进行三个步骤，但是由于线程交替，可能会出现以下错误： 其中：线程1在Load cnt并加一后，还没来得及存储，cnt被线程2load,此时cnt为0，最后线程1和线程2都是在0的基础上加1，cnt被写了两次1。 进度图 利用进度图，在n维笛卡尔坐标系中画出轨迹线，来表示多线程指令的执行顺序。如下图为双线程的进度图，图中有不安全区域，轨迹进入此区域，会发生错误。 L1,U1,S1等涉及对共享变量cnt的操作，两线程不能对其同时操作，构成不安全区域。 如果一条路径线没有经过不安全区域，则说明是安全的。 使用信号量解决同步问题 为了确保不产生不安全的路径线，可以使用信号量。 定义 信号量：非负整数，全局变量，由P(s),V(s)操作。 P(s)：如果s非零，则减少1并立即返回（system call）（原子性），立即进行当前线程的下一条指令。 如果s为零，则暂停当前线程，知道某一线程执行了V(s)，使得s变成非零，此时当前线程p(s)重启，将s减少1，返回被暂停的线程继续操作。 V(s)：s加1，如果有悬停的线程，则通过某种算法，选择一条悬停线程重启。 所有信号量总是大于等于1的。 接口 包括init：设置信号量，wait()：减少信号量，post()：增加信号量。 互斥 使用二元信号量（互斥锁）（mutex)，调用P(mutex)：锁定。V(mutex)：解锁。 引入信号锁，对cnt进行锁定，从而只能有一个线程操作cnt，不回被打断。 会比较慢，因为一直system call。 进度图变成如下： 可以发现由于信号量不能是-1，线程路径不会经过不安全区域，从而保证了路径的安全。" />
<link rel="canonical" href="http://localhost:4000/%E5%90%8C%E6%AD%A5-%E5%9F%BA%E7%A1%80.html" />
<meta property="og:url" content="http://localhost:4000/%E5%90%8C%E6%AD%A5-%E5%9F%BA%E7%A1%80.html" />
<meta property="og:site_name" content="tie’s blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-05-23T07:51:00+08:00" />
<script type="application/ld+json">
{"url":"http://localhost:4000/%E5%90%8C%E6%AD%A5-%E5%9F%BA%E7%A1%80.html","headline":"CSAPP：同步-基础","dateModified":"2020-05-23T07:51:00+08:00","datePublished":"2020-05-23T07:51:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/%E5%90%8C%E6%AD%A5-%E5%9F%BA%E7%A1%80.html"},"author":{"@type":"Person","name":"tie"},"description":"同步-基础 线程中的共享数据 如何判断数据被多线程共享呢？并不是全局变量就是共享的，线程栈内的变量是私有的。需要具体分析。 共享数据定义：如果多个线程都对某个变量X的实例有引用，则称这个变量是共享变量。 从以下三个方面来理解共享变量。 线程内存模型 理论上多线程在一个进程内运行，每个线程都有自己的stack,线程ID等，都共享code,heap等。 但实际操作中，除了寄存器中的数据是严格的私有和保护起来的，线程中栈内的数据是可以被其他线程读写的。 如下图所示：传入线程的全局指针ptr指向的是主线程中的栈内局部变量msgs，此时peer线程可以通过此全局指针去访问主线程栈内数据。 变量映射到内存 包括：全局变量，本地自动变量，本地静态变量。 全局变量：定义在函数体之外，运行时只含有一个实例，放在data区域，每个线程都可以引用。 本地自动变量：每一个线程都有自己的栈来存储所有的本地自动变量实例，就算是他们执行的是相同的线程实例。 本地静态变量：定义在函数体内，也只包含有一个实例，只能在函数体内使用，不同线程都使用这个函数时，进行数据共享（都可以读写这个唯一的实例）。 分析共享变量 分析下面代码中，哪些代码是线程私有，哪些代码是共享的。 可以发现：ptr和static变量只有一个实例，但是thread routine被两个线程使用，里面的局部自动变量每个线程栈都有一份实例。 共享变量：ptr,msgs,cnt。 共享数据引起的同步问题 错误代码分析 可以发现：nither虽然是主线程的局部变量，但是因为不会被修改，所以可以引用传递。 cnt是volatile的，也会是不回被存在寄存器中，每次操作都要在内存中取出和存回去。 可以发现，cnt++,需要进行三个步骤，但是由于线程交替，可能会出现以下错误： 其中：线程1在Load cnt并加一后，还没来得及存储，cnt被线程2load,此时cnt为0，最后线程1和线程2都是在0的基础上加1，cnt被写了两次1。 进度图 利用进度图，在n维笛卡尔坐标系中画出轨迹线，来表示多线程指令的执行顺序。如下图为双线程的进度图，图中有不安全区域，轨迹进入此区域，会发生错误。 L1,U1,S1等涉及对共享变量cnt的操作，两线程不能对其同时操作，构成不安全区域。 如果一条路径线没有经过不安全区域，则说明是安全的。 使用信号量解决同步问题 为了确保不产生不安全的路径线，可以使用信号量。 定义 信号量：非负整数，全局变量，由P(s),V(s)操作。 P(s)：如果s非零，则减少1并立即返回（system call）（原子性），立即进行当前线程的下一条指令。 如果s为零，则暂停当前线程，知道某一线程执行了V(s)，使得s变成非零，此时当前线程p(s)重启，将s减少1，返回被暂停的线程继续操作。 V(s)：s加1，如果有悬停的线程，则通过某种算法，选择一条悬停线程重启。 所有信号量总是大于等于1的。 接口 包括init：设置信号量，wait()：减少信号量，post()：增加信号量。 互斥 使用二元信号量（互斥锁）（mutex)，调用P(mutex)：锁定。V(mutex)：解锁。 引入信号锁，对cnt进行锁定，从而只能有一个线程操作cnt，不回被打断。 会比较慢，因为一直system call。 进度图变成如下： 可以发现由于信号量不能是-1，线程路径不会经过不安全区域，从而保证了路径的安全。","@type":"BlogPosting","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

  <link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="tie's blog" />

  <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
  <link rel="stylesheet" href="/assets/css/main.css" />
</head><body a="auto">
    <main class="page-content" aria-label="Content">
      <div class="w">
        <a href="/">..</a>

<article>
  <p class="post-meta">
    <time datetime="2020-05-23 07:51:00 +0800">2020-05-23</time>
  </p>
  
  <h1>CSAPP：同步-基础</h1>

  <h1 id="同步-基础">同步-基础</h1>

<h2 id="线程中的共享数据">线程中的共享数据</h2>

<p>如何判断数据被多线程共享呢？并不是全局变量就是共享的，线程栈内的变量是私有的。需要具体分析。</p>

<p>共享数据定义：如果多个线程都对某个变量X的实例有引用，则称这个变量是共享变量。</p>

<p>从以下三个方面来理解共享变量。</p>

<h3 id="线程内存模型">线程内存模型</h3>

<p>理论上多线程在一个进程内运行，每个线程都有自己的stack,线程ID等，都共享code,heap等。</p>

<p>但实际操作中，除了寄存器中的数据是严格的私有和保护起来的，线程中栈内的数据是可以被其他线程读写的。</p>

<p>如下图所示：传入线程的全局指针ptr指向的是主线程中的栈内局部变量msgs，此时peer线程可以通过此全局指针去访问主线程栈内数据。</p>

<p><a href="https://imgchr.com/i/yhBgJJ"><img src="https://s3.ax1x.com/2021/02/19/yhBgJJ.png" alt="yhBgJJ.png" /></a></p>

<h3 id="变量映射到内存">变量映射到内存</h3>

<p>包括：全局变量，本地自动变量，本地静态变量。</p>

<p>全局变量：定义在函数体之外，运行时只含有一个实例，放在data区域，每个线程都可以引用。</p>

<p>本地自动变量：每一个线程都有自己的栈来存储所有的本地自动变量实例，就算是他们执行的是相同的线程实例。</p>

<p>本地静态变量：定义在函数体内，也只包含有一个实例，只能在函数体内使用，不同线程都使用这个函数时，进行数据共享（都可以读写这个唯一的实例）。</p>

<h3 id="分析共享变量">分析共享变量</h3>

<p>分析下面代码中，哪些代码是线程私有，哪些代码是共享的。</p>

<p><a href="https://imgchr.com/i/yhBRzR"><img src="https://s3.ax1x.com/2021/02/19/yhBRzR.png" alt="yhBRzR.png" /></a></p>

<p>可以发现：ptr和static变量只有一个实例，但是thread routine被两个线程使用，里面的局部自动变量每个线程栈都有一份实例。</p>

<p>共享变量：ptr,msgs,cnt。</p>

<h2 id="共享数据引起的同步问题">共享数据引起的同步问题</h2>

<h3 id="错误代码分析">错误代码分析</h3>

<p><a href="https://imgchr.com/i/yhB2W9"><img src="https://s3.ax1x.com/2021/02/19/yhB2W9.png" alt="yhB2W9.png" /></a></p>

<p>可以发现：nither虽然是主线程的局部变量，但是因为不会被修改，所以可以引用传递。</p>

<p>cnt是volatile的，也会是不回被存在寄存器中，每次操作都要在内存中取出和存回去。</p>

<p><a href="https://imgchr.com/i/yhBci4"><img src="https://s3.ax1x.com/2021/02/19/yhBci4.png" alt="yhBci4.png" /></a></p>

<p>可以发现，cnt++,需要进行三个步骤，但是由于线程交替，可能会出现以下错误：</p>

<p><a href="https://imgchr.com/i/yhB0s0"><img src="https://s3.ax1x.com/2021/02/19/yhB0s0.png" alt="yhB0s0.png" /></a></p>

<p>其中：线程1在Load cnt并加一后，还没来得及存储，cnt被线程2load,此时cnt为0，最后线程1和线程2都是在0的基础上加1，cnt被写了两次1。</p>

<h3 id="进度图">进度图</h3>

<p>利用进度图，在n维笛卡尔坐标系中画出轨迹线，来表示多线程指令的执行顺序。如下图为双线程的进度图，图中有不安全区域，轨迹进入此区域，会发生错误。</p>

<p><a href="https://imgchr.com/i/yhBrZT"><img src="https://s3.ax1x.com/2021/02/19/yhBrZT.png" alt="yhBrZT.png" /></a></p>

<p>L1,U1,S1等涉及对共享变量cnt的操作，两线程不能对其同时操作，构成不安全区域。</p>

<p>如果一条路径线没有经过不安全区域，则说明是安全的。</p>

<h2 id="使用信号量解决同步问题">使用信号量解决同步问题</h2>

<p>为了确保不产生不安全的路径线，可以使用信号量。</p>

<h3 id="定义">定义</h3>

<p>信号量：非负整数，全局变量，由P(s),V(s)操作。</p>

<p>P(s)：如果s非零，则减少1并立即返回（system call）（原子性），立即进行当前线程的下一条指令。</p>

<p>如果s为零，则暂停当前线程，知道某一线程执行了V(s)，使得s变成非零，此时当前线程p(s)重启，将s减少1，返回被暂停的线程继续操作。</p>

<p>V(s)：s加1，如果有悬停的线程，则通过某种算法，选择一条悬停线程重启。</p>

<p>所有信号量总是大于等于1的。</p>

<h3 id="接口">接口</h3>

<p>包括init：设置信号量，wait()：减少信号量，post()：增加信号量。</p>

<p><a href="https://imgchr.com/i/yhBBLV"><img src="https://s3.ax1x.com/2021/02/19/yhBBLV.png" alt="yhBBLV.png" /></a></p>

<h3 id="互斥">互斥</h3>

<p>使用二元信号量（互斥锁）（mutex)，调用P(mutex)：锁定。V(mutex)：解锁。</p>

<p>引入信号锁，对cnt进行锁定，从而只能有一个线程操作cnt，不回被打断。</p>

<p><a href="https://imgchr.com/i/yhBsdU"><img src="https://s3.ax1x.com/2021/02/19/yhBsdU.png" alt="yhBsdU.png" /></a></p>

<p>会比较慢，因为一直system call。</p>

<p>进度图变成如下：</p>

<p><a href="https://imgchr.com/i/yhByoF"><img src="https://s3.ax1x.com/2021/02/19/yhByoF.png" alt="yhByoF.png" /></a></p>

<p>可以发现由于信号量不能是-1，线程路径不会经过不安全区域，从而保证了路径的安全。</p>

</article>
      </div>
    </main>

    
  </body>
</html>