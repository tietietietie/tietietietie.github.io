<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <title>CSAPP：同步-进阶</title>

  <!-- Begin Jekyll SEO tag v2.6.1 -->
<meta name="generator" content="Jekyll v3.8.7" />
<meta property="og:title" content="CSAPP：同步-进阶" />
<meta name="author" content="tie" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="同步-进阶 使用信号量来协调线程 基本思想：使用信号量操作函数（P(),V()）来提醒其他线程某些状态的改变。 两个常见的例子：1，生产者-消费者模型。2，读/写模型 生产者-消费者问题 基本思想 生产者：等待空槽（slot），把资源（Item）插入空槽，并提醒消费者。 消费者：等待资源，把资源提取出来（slot），产生空槽，并提醒生产者。 举例：多媒体系统/图形用户接口设计。 信号量：需要三个，分别是mutex，保证只能有一个线程在操作buffer。slots：表示当前的空槽位。items：表示当前有多少资源。 sbuf package 使用sbuf来实现此模型。具体实现如下所示： 可以发现sbuf包定义了一个结构体以及4个函数。其中sbuf_t结构体中包含有buffer指针，buffer大小，两个首尾指针，以及三个信号量。 初始化过程：动态分配buffer（则可以共享），以及初始化信号量。 也可以使用deinit来释放动态分配的内存。 插入和取出资源的过程：需要先等待是否有空槽或者资源，然后插入资源或者取资源时，需要用互斥锁保护起来。 ​ 读者/写者问题 基本思想 读者线程：只能够读取某个对象。 写者线程：可以修改某个对象。 显然写者只能互斥访问对象，但是读者可以无限制的访问对象。 举例：航线预约系统，多线程web服务器的缓存 解决方式 读者优先：当读者大于等于1时，我们会锁住写者，此时写者必须等所有读者（包括后来加入的读者）全部完成，才能开始写。 写者优先：只要写者开始写，则尽可能地执行写操作。 两者方式都会造成写者或者读者线程的饥饿。 读者优先程序举例： 可以发现： 需要用互斥锁保护readcnt。 一旦读者数量大于1，就把写者锁住，直到读者数量为0，才释放写者锁。 预线程化并发服务器 首先会创建N个预先的线程，然后等待连接，将每一个连接的connfd插入到buffer中。 当Buffer中有item也就是connfd时，线程会执行echo，注意线程detached，并且永远不会终止。 ehch_cnt程序统计用户发来的所有字节，存储在byte_cnt这个全局变量中，所以需要互斥锁，init_echo_cnt将echo初始化，这可以在主线程中进行，但是如下代码展示了在工作线程中初始化的方法。 通过使用static变量，只会被第一个线程初始化一次（老师说不是这样。。），所以Pthread_once只会被调用一次，从而只会初始化一次echo_cnt。 线程安全函数 基本概念 定义：当一个函数被多个并发线程调用，并总能产生正确结果时，则这个函数为线程安全函数。 四种常见的线程不安全函数： 没有保护共享变量的函数 保持跨越多个调用的状态的函数 返回指向静态变量指针的函数 调用线程不安全函数的函数 线程不安全函数分析 没有保护共享数据的函数 如之前的badcnt.c程序，没有对共享数据cnt进行保护，从而发生了线程交替，造成错误结果。 保持跨越多个调用的状态的函数 典型例子是伪随机数生成函数，其当前调用的返回值，依赖于前一次调用的结果。 返回指向静态变量的指针的函数 很容易理解，因为静态变量的地址不变，此类函数的返回值是固定的，当多个线程调用此类函数，线程1的结果可以覆盖线程2的结果，可以选择重写（我们得有权限访问源代码），或者包装此函数，如下图，由于ctime返回的是静态函数地址，我们使用加锁-复制技术，对线程不安全函数加锁，然后将静态函数地址和我们的私有内存地址练习起来，这样就能保护此线程得到的地址不会被其它线程覆盖。 调用了线程不安全函数的函数 修改其调用函数，确保此函数的调用函数都是安全的。 可重入函数（reentrant function） 定义：当函数被多线程调用，没有任何共享数据时，则此函数是可重入的。 可重入函数和线程安全函数的关系如下所示： 注意：所有C标准库中的函数，都是线程安全的！大部分unix的system call也是线程安全的。 竞争 当程序运行的正确性，取决于一个线程必须在另一线程到达y点前，到达x点，则称存在竞争。 如下图，由于所有线程都共享数据i，而数据i为了能提供正确的id给线程i，则必须不能在解引用前，被增加1. 如何消除？给每一个i分配动态空间，这样传入的是ptr，且没有被共享。 死锁 当一个进程（线程）等待一个永远不会发生的条件时，会出现死锁。 常见例子： 线程1和线程2都需要A，B资源才能继续进行，线程1先锁定了资源A，接着线程2锁定了资源B，此时两线程都无法继续进行，永远的等待下去。 下图代码表示两线程对两二元信号量的锁定顺序，导致了死锁。 其线程图如下： 所有进入死锁区域的轨迹都最终会到死锁点。 简单修改锁定顺序，就可以防止上述代码的死锁现象。" />
<meta property="og:description" content="同步-进阶 使用信号量来协调线程 基本思想：使用信号量操作函数（P(),V()）来提醒其他线程某些状态的改变。 两个常见的例子：1，生产者-消费者模型。2，读/写模型 生产者-消费者问题 基本思想 生产者：等待空槽（slot），把资源（Item）插入空槽，并提醒消费者。 消费者：等待资源，把资源提取出来（slot），产生空槽，并提醒生产者。 举例：多媒体系统/图形用户接口设计。 信号量：需要三个，分别是mutex，保证只能有一个线程在操作buffer。slots：表示当前的空槽位。items：表示当前有多少资源。 sbuf package 使用sbuf来实现此模型。具体实现如下所示： 可以发现sbuf包定义了一个结构体以及4个函数。其中sbuf_t结构体中包含有buffer指针，buffer大小，两个首尾指针，以及三个信号量。 初始化过程：动态分配buffer（则可以共享），以及初始化信号量。 也可以使用deinit来释放动态分配的内存。 插入和取出资源的过程：需要先等待是否有空槽或者资源，然后插入资源或者取资源时，需要用互斥锁保护起来。 ​ 读者/写者问题 基本思想 读者线程：只能够读取某个对象。 写者线程：可以修改某个对象。 显然写者只能互斥访问对象，但是读者可以无限制的访问对象。 举例：航线预约系统，多线程web服务器的缓存 解决方式 读者优先：当读者大于等于1时，我们会锁住写者，此时写者必须等所有读者（包括后来加入的读者）全部完成，才能开始写。 写者优先：只要写者开始写，则尽可能地执行写操作。 两者方式都会造成写者或者读者线程的饥饿。 读者优先程序举例： 可以发现： 需要用互斥锁保护readcnt。 一旦读者数量大于1，就把写者锁住，直到读者数量为0，才释放写者锁。 预线程化并发服务器 首先会创建N个预先的线程，然后等待连接，将每一个连接的connfd插入到buffer中。 当Buffer中有item也就是connfd时，线程会执行echo，注意线程detached，并且永远不会终止。 ehch_cnt程序统计用户发来的所有字节，存储在byte_cnt这个全局变量中，所以需要互斥锁，init_echo_cnt将echo初始化，这可以在主线程中进行，但是如下代码展示了在工作线程中初始化的方法。 通过使用static变量，只会被第一个线程初始化一次（老师说不是这样。。），所以Pthread_once只会被调用一次，从而只会初始化一次echo_cnt。 线程安全函数 基本概念 定义：当一个函数被多个并发线程调用，并总能产生正确结果时，则这个函数为线程安全函数。 四种常见的线程不安全函数： 没有保护共享变量的函数 保持跨越多个调用的状态的函数 返回指向静态变量指针的函数 调用线程不安全函数的函数 线程不安全函数分析 没有保护共享数据的函数 如之前的badcnt.c程序，没有对共享数据cnt进行保护，从而发生了线程交替，造成错误结果。 保持跨越多个调用的状态的函数 典型例子是伪随机数生成函数，其当前调用的返回值，依赖于前一次调用的结果。 返回指向静态变量的指针的函数 很容易理解，因为静态变量的地址不变，此类函数的返回值是固定的，当多个线程调用此类函数，线程1的结果可以覆盖线程2的结果，可以选择重写（我们得有权限访问源代码），或者包装此函数，如下图，由于ctime返回的是静态函数地址，我们使用加锁-复制技术，对线程不安全函数加锁，然后将静态函数地址和我们的私有内存地址练习起来，这样就能保护此线程得到的地址不会被其它线程覆盖。 调用了线程不安全函数的函数 修改其调用函数，确保此函数的调用函数都是安全的。 可重入函数（reentrant function） 定义：当函数被多线程调用，没有任何共享数据时，则此函数是可重入的。 可重入函数和线程安全函数的关系如下所示： 注意：所有C标准库中的函数，都是线程安全的！大部分unix的system call也是线程安全的。 竞争 当程序运行的正确性，取决于一个线程必须在另一线程到达y点前，到达x点，则称存在竞争。 如下图，由于所有线程都共享数据i，而数据i为了能提供正确的id给线程i，则必须不能在解引用前，被增加1. 如何消除？给每一个i分配动态空间，这样传入的是ptr，且没有被共享。 死锁 当一个进程（线程）等待一个永远不会发生的条件时，会出现死锁。 常见例子： 线程1和线程2都需要A，B资源才能继续进行，线程1先锁定了资源A，接着线程2锁定了资源B，此时两线程都无法继续进行，永远的等待下去。 下图代码表示两线程对两二元信号量的锁定顺序，导致了死锁。 其线程图如下： 所有进入死锁区域的轨迹都最终会到死锁点。 简单修改锁定顺序，就可以防止上述代码的死锁现象。" />
<link rel="canonical" href="http://localhost:4000/%E5%90%8C%E6%AD%A5-%E8%BF%9B%E9%98%B6.html" />
<meta property="og:url" content="http://localhost:4000/%E5%90%8C%E6%AD%A5-%E8%BF%9B%E9%98%B6.html" />
<meta property="og:site_name" content="tie’s blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-06-02T07:23:00+08:00" />
<script type="application/ld+json">
{"url":"http://localhost:4000/%E5%90%8C%E6%AD%A5-%E8%BF%9B%E9%98%B6.html","headline":"CSAPP：同步-进阶","dateModified":"2020-06-02T07:23:00+08:00","datePublished":"2020-06-02T07:23:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/%E5%90%8C%E6%AD%A5-%E8%BF%9B%E9%98%B6.html"},"author":{"@type":"Person","name":"tie"},"description":"同步-进阶 使用信号量来协调线程 基本思想：使用信号量操作函数（P(),V()）来提醒其他线程某些状态的改变。 两个常见的例子：1，生产者-消费者模型。2，读/写模型 生产者-消费者问题 基本思想 生产者：等待空槽（slot），把资源（Item）插入空槽，并提醒消费者。 消费者：等待资源，把资源提取出来（slot），产生空槽，并提醒生产者。 举例：多媒体系统/图形用户接口设计。 信号量：需要三个，分别是mutex，保证只能有一个线程在操作buffer。slots：表示当前的空槽位。items：表示当前有多少资源。 sbuf package 使用sbuf来实现此模型。具体实现如下所示： 可以发现sbuf包定义了一个结构体以及4个函数。其中sbuf_t结构体中包含有buffer指针，buffer大小，两个首尾指针，以及三个信号量。 初始化过程：动态分配buffer（则可以共享），以及初始化信号量。 也可以使用deinit来释放动态分配的内存。 插入和取出资源的过程：需要先等待是否有空槽或者资源，然后插入资源或者取资源时，需要用互斥锁保护起来。 ​ 读者/写者问题 基本思想 读者线程：只能够读取某个对象。 写者线程：可以修改某个对象。 显然写者只能互斥访问对象，但是读者可以无限制的访问对象。 举例：航线预约系统，多线程web服务器的缓存 解决方式 读者优先：当读者大于等于1时，我们会锁住写者，此时写者必须等所有读者（包括后来加入的读者）全部完成，才能开始写。 写者优先：只要写者开始写，则尽可能地执行写操作。 两者方式都会造成写者或者读者线程的饥饿。 读者优先程序举例： 可以发现： 需要用互斥锁保护readcnt。 一旦读者数量大于1，就把写者锁住，直到读者数量为0，才释放写者锁。 预线程化并发服务器 首先会创建N个预先的线程，然后等待连接，将每一个连接的connfd插入到buffer中。 当Buffer中有item也就是connfd时，线程会执行echo，注意线程detached，并且永远不会终止。 ehch_cnt程序统计用户发来的所有字节，存储在byte_cnt这个全局变量中，所以需要互斥锁，init_echo_cnt将echo初始化，这可以在主线程中进行，但是如下代码展示了在工作线程中初始化的方法。 通过使用static变量，只会被第一个线程初始化一次（老师说不是这样。。），所以Pthread_once只会被调用一次，从而只会初始化一次echo_cnt。 线程安全函数 基本概念 定义：当一个函数被多个并发线程调用，并总能产生正确结果时，则这个函数为线程安全函数。 四种常见的线程不安全函数： 没有保护共享变量的函数 保持跨越多个调用的状态的函数 返回指向静态变量指针的函数 调用线程不安全函数的函数 线程不安全函数分析 没有保护共享数据的函数 如之前的badcnt.c程序，没有对共享数据cnt进行保护，从而发生了线程交替，造成错误结果。 保持跨越多个调用的状态的函数 典型例子是伪随机数生成函数，其当前调用的返回值，依赖于前一次调用的结果。 返回指向静态变量的指针的函数 很容易理解，因为静态变量的地址不变，此类函数的返回值是固定的，当多个线程调用此类函数，线程1的结果可以覆盖线程2的结果，可以选择重写（我们得有权限访问源代码），或者包装此函数，如下图，由于ctime返回的是静态函数地址，我们使用加锁-复制技术，对线程不安全函数加锁，然后将静态函数地址和我们的私有内存地址练习起来，这样就能保护此线程得到的地址不会被其它线程覆盖。 调用了线程不安全函数的函数 修改其调用函数，确保此函数的调用函数都是安全的。 可重入函数（reentrant function） 定义：当函数被多线程调用，没有任何共享数据时，则此函数是可重入的。 可重入函数和线程安全函数的关系如下所示： 注意：所有C标准库中的函数，都是线程安全的！大部分unix的system call也是线程安全的。 竞争 当程序运行的正确性，取决于一个线程必须在另一线程到达y点前，到达x点，则称存在竞争。 如下图，由于所有线程都共享数据i，而数据i为了能提供正确的id给线程i，则必须不能在解引用前，被增加1. 如何消除？给每一个i分配动态空间，这样传入的是ptr，且没有被共享。 死锁 当一个进程（线程）等待一个永远不会发生的条件时，会出现死锁。 常见例子： 线程1和线程2都需要A，B资源才能继续进行，线程1先锁定了资源A，接着线程2锁定了资源B，此时两线程都无法继续进行，永远的等待下去。 下图代码表示两线程对两二元信号量的锁定顺序，导致了死锁。 其线程图如下： 所有进入死锁区域的轨迹都最终会到死锁点。 简单修改锁定顺序，就可以防止上述代码的死锁现象。","@type":"BlogPosting","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

  <link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="tie's blog" />

  <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
  <link rel="stylesheet" href="/assets/css/main.css" />
</head><body a="auto">
    <main class="page-content" aria-label="Content">
      <div class="w">
        <a href="/">..</a>

<article>
  <p class="post-meta">
    <time datetime="2020-06-02 07:23:00 +0800">2020-06-02</time>
  </p>
  
  <h1>CSAPP：同步-进阶</h1>

  <h1 id="同步-进阶">同步-进阶</h1>

<h2 id="使用信号量来协调线程">使用信号量来协调线程</h2>

<p>基本思想：使用信号量操作函数（P(),V()）来提醒其他线程某些状态的改变。</p>

<p>两个常见的例子：1，生产者-消费者模型。2，读/写模型</p>

<h3 id="生产者-消费者问题">生产者-消费者问题</h3>

<h4 id="基本思想">基本思想</h4>

<p>生产者：等待空槽（slot），把资源（Item）插入空槽，并提醒消费者。</p>

<p>消费者：等待资源，把资源提取出来（slot），产生空槽，并提醒生产者。</p>

<p>举例：多媒体系统/图形用户接口设计。</p>

<p><a href="https://imgchr.com/i/yhDBpd"><img src="https://s3.ax1x.com/2021/02/19/yhDBpd.png" alt="yhDBpd.png" /></a></p>

<p>信号量：需要三个，分别是mutex，保证只能有一个线程在操作buffer。slots：表示当前的空槽位。items：表示当前有多少资源。</p>

<h4 id="sbuf-package">sbuf package</h4>

<p>使用sbuf来实现此模型。具体实现如下所示：</p>

<p><a href="https://imgchr.com/i/yhDD1A"><img src="https://s3.ax1x.com/2021/02/19/yhDD1A.png" alt="yhDD1A.png" /></a></p>

<p>可以发现sbuf包定义了一个结构体以及4个函数。其中sbuf_t结构体中包含有buffer指针，buffer大小，两个首尾指针，以及三个信号量。</p>

<p><a href="https://imgchr.com/i/yhDr6I"><img src="https://s3.ax1x.com/2021/02/19/yhDr6I.png" alt="yhDr6I.png" /></a></p>

<p>初始化过程：动态分配buffer（则可以共享），以及初始化信号量。</p>

<p>也可以使用deinit来释放动态分配的内存。</p>

<p><a href="https://imgchr.com/i/yhD6nP"><img src="https://s3.ax1x.com/2021/02/19/yhD6nP.png" alt="yhD6nP.png" /></a></p>

<p>插入和取出资源的过程：需要先等待是否有空槽或者资源，然后插入资源或者取资源时，需要用互斥锁保护起来。</p>

<p>​</p>

<h3 id="读者写者问题">读者/写者问题</h3>

<h4 id="基本思想-1">基本思想</h4>

<p>读者线程：只能够读取某个对象。</p>

<p>写者线程：可以修改某个对象。</p>

<p>显然写者只能互斥访问对象，但是读者可以无限制的访问对象。</p>

<p>举例：航线预约系统，多线程web服务器的缓存</p>

<h4 id="解决方式">解决方式</h4>

<p>读者优先：当读者大于等于1时，我们会锁住写者，此时写者必须等所有读者（包括后来加入的读者）全部完成，才能开始写。</p>

<p>写者优先：只要写者开始写，则尽可能地执行写操作。</p>

<p>两者方式都会造成写者或者读者线程的饥饿。</p>

<p>读者优先程序举例：</p>

<p><a href="https://imgchr.com/i/yhDc0f"><img src="https://s3.ax1x.com/2021/02/19/yhDc0f.png" alt="yhDc0f.png" /></a></p>

<p>可以发现：</p>

<ol>
  <li>需要用互斥锁保护readcnt。</li>
  <li>一旦读者数量大于1，就把写者锁住，直到读者数量为0，才释放写者锁。</li>
</ol>

<h3 id="预线程化并发服务器">预线程化并发服务器</h3>

<p><a href="https://imgchr.com/i/yhDfhQ"><img src="https://s3.ax1x.com/2021/02/19/yhDfhQ.png" alt="yhDfhQ.png" /></a></p>

<p>首先会创建N个预先的线程，然后等待连接，将每一个连接的connfd插入到buffer中。</p>

<p><a href="https://imgchr.com/i/yhDRAS"><img src="https://s3.ax1x.com/2021/02/19/yhDRAS.png" alt="yhDRAS.png" /></a></p>

<p>当Buffer中有item也就是connfd时，线程会执行echo，注意线程detached，并且永远不会终止。</p>

<p><a href="https://imgchr.com/i/yhDg78"><img src="https://s3.ax1x.com/2021/02/19/yhDg78.png" alt="yhDg78.png" /></a></p>

<p>ehch_cnt程序统计用户发来的所有字节，存储在byte_cnt这个全局变量中，所以需要互斥锁，init_echo_cnt将echo初始化，这可以在主线程中进行，但是如下代码展示了在工作线程中初始化的方法。</p>

<p><a href="https://imgchr.com/i/yhDWtg"><img src="https://s3.ax1x.com/2021/02/19/yhDWtg.png" alt="yhDWtg.png" /></a></p>

<p>通过使用static变量，只会被第一个线程初始化一次（老师说不是这样。。），所以Pthread_once只会被调用一次，从而只会初始化一次echo_cnt。</p>

<h2 id="线程安全函数">线程安全函数</h2>

<h3 id="基本概念">基本概念</h3>

<p>定义：当一个函数被多个并发线程调用，并总能产生正确结果时，则这个函数为线程安全函数。</p>

<p>四种常见的线程不安全函数：</p>

<ol>
  <li>没有保护共享变量的函数</li>
  <li>保持跨越多个调用的状态的函数</li>
  <li>返回指向静态变量指针的函数</li>
  <li>调用线程不安全函数的函数</li>
</ol>

<h3 id="线程不安全函数分析">线程不安全函数分析</h3>

<ul>
  <li>没有保护共享数据的函数</li>
</ul>

<p>如之前的badcnt.c程序，没有对共享数据cnt进行保护，从而发生了线程交替，造成错误结果。</p>

<ul>
  <li>保持跨越多个调用的状态的函数</li>
</ul>

<p>典型例子是伪随机数生成函数，其当前调用的返回值，依赖于前一次调用的结果。</p>

<ul>
  <li>返回指向静态变量的指针的函数</li>
</ul>

<p>很容易理解，因为静态变量的地址不变，此类函数的返回值是固定的，当多个线程调用此类函数，线程1的结果可以覆盖线程2的结果，可以选择重写（我们得有权限访问源代码），或者包装此函数，如下图，由于ctime返回的是静态函数地址，我们使用<strong>加锁-复制</strong>技术，对线程不安全函数加锁，然后将静态函数地址和我们的私有内存地址练习起来，这样就能保护此线程得到的地址不会被其它线程覆盖。</p>

<p><a href="https://imgchr.com/i/yhD4pj"><img src="https://s3.ax1x.com/2021/02/19/yhD4pj.png" alt="yhD4pj.png" /></a></p>

<ul>
  <li>调用了线程不安全函数的函数</li>
</ul>

<p>修改其调用函数，确保此函数的调用函数都是安全的。</p>

<h3 id="可重入函数reentrant-function">可重入函数（reentrant function）</h3>

<p>定义：当函数被多线程调用，没有任何共享数据时，则此函数是可重入的。</p>

<p>可重入函数和线程安全函数的关系如下所示：</p>

<p><a href="https://imgchr.com/i/yhD51s"><img src="https://s3.ax1x.com/2021/02/19/yhD51s.png" alt="yhD51s.png" /></a></p>

<p>注意：所有C标准库中的函数，都是线程安全的！大部分unix的system call也是线程安全的。</p>

<h3 id="竞争">竞争</h3>

<p>当程序运行的正确性，取决于一个线程必须在另一线程到达y点前，到达x点，则称存在竞争。</p>

<p>如下图，由于所有线程都共享数据i，而数据i为了能提供正确的id给线程i，则必须不能在解引用前，被增加1.</p>

<p><a href="https://imgchr.com/i/yhDIcn"><img src="https://s3.ax1x.com/2021/02/19/yhDIcn.png" alt="yhDIcn.png" /></a></p>

<p>如何消除？给每一个i分配动态空间，这样传入的是ptr，且没有被共享。</p>

<p><a href="https://imgchr.com/i/yhDHBV"><img src="https://s3.ax1x.com/2021/02/19/yhDHBV.png" alt="yhDHBV.png" /></a></p>

<h3 id="死锁">死锁</h3>

<p>当一个进程（线程）等待一个永远不会发生的条件时，会出现死锁。</p>

<p>常见例子：</p>

<p>线程1和线程2都需要A，B资源才能继续进行，线程1先锁定了资源A，接着线程2锁定了资源B，此时两线程都无法继续进行，永远的等待下去。</p>

<p>下图代码表示两线程对两二元信号量的<strong>锁定顺序</strong>，导致了死锁。</p>

<p><a href="https://imgchr.com/i/yhD7n0"><img src="https://s3.ax1x.com/2021/02/19/yhD7n0.png" alt="yhD7n0.png" /></a></p>

<p>其线程图如下：</p>

<p><a href="https://imgchr.com/i/yhDoXq"><img src="https://s3.ax1x.com/2021/02/19/yhDoXq.png" alt="yhDoXq.png" /></a></p>

<p>所有进入死锁区域的轨迹都最终会到死锁点。</p>

<p>简单修改锁定顺序，就可以防止上述代码的死锁现象。</p>

<p><a href="https://imgchr.com/i/yhDLAU"><img src="https://s3.ax1x.com/2021/02/19/yhDLAU.png" alt="yhDLAU.png" /></a></p>

</article>
      </div>
    </main>

    
  </body>
</html>